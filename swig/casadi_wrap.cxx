/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.2
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#include <cmath>
#ifdef _XOPEN_SOURCE
#undef _XOPEN_SOURCE
#endif
#ifdef _POSIX_C_SOURCE
#undef _POSIX_C_SOURCE
#endif


#define SWIG_PYTHON_OUTPUT_TUPLE



#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_DIRECTORS
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(__GNUC__) && defined(_WIN32) && !defined(SWIG_PYTHON_NO_HYPOT_WORKAROUND)
/* Workaround for '::hypot' has not been declared', see https://bugs.python.org/issue11566 */
# include <math.h>
#endif

#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG 1
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03030000
  return (char *)PyUnicode_AsUTF8(str);
#elif PY_VERSION_HEX >= 0x03000000
  char *newstr = 0;
  str = PyUnicode_AsUTF8String(str);
  if (str) {
    char *cstr;
    Py_ssize_t len;
    if (PyBytes_AsStringAndSize(str, &cstr, &len) != -1) {
      newstr = (char *) malloc(len+1);
      if (newstr)
        memcpy(newstr, cstr, len+1);
    }
    Py_XDECREF(str);
  }
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03030000 || PY_VERSION_HEX < 0x03000000
#  define SWIG_Python_str_DelForPy3(x)
#else
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

// SWIGPY_USE_CAPSULE is no longer used within SWIG itself, but some user
// interface files check for it.
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ("swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred())
    PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    PyObject *old_str = PyObject_Str(value);
    const char *tmp = SWIG_Python_str_AsChar(old_str);
    PyErr_Clear();
    Py_XINCREF(type);
    if (tmp)
      PyErr_Format(type, "%s %s", tmp, mesg);
    else
      PyErr_Format(type, "%s", mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

SWIGRUNTIME int
SWIG_Python_TypeErrorOccurred(PyObject *obj)
{
  PyObject *error;
  if (obj)
    return 0;
  error = PyErr_Occurred();
  return error && PyErr_GivenExceptionMatches(error, PyExc_TypeError);
}

SWIGRUNTIME void
SWIG_Python_RaiseOrModifyTypeError(const char *message)
{
  if (SWIG_Python_TypeErrorOccurred(NULL)) {
    /* Use existing TypeError to preserve stacktrace and enhance with given message */
    PyObject *newvalue;
    PyObject *type = NULL, *value = NULL, *traceback = NULL;
    PyErr_Fetch(&type, &value, &traceback);
#if PY_VERSION_HEX >= 0x03000000
    newvalue = PyUnicode_FromFormat("%S\nAdditional information:\n%s", value, message);
#else
    newvalue = PyString_FromFormat("%s\nAdditional information:\n%s", PyString_AsString(value), message);
#endif
    Py_XDECREF(value);
    PyErr_Restore(type, newvalue, traceback);
  } else {
    /* Raise TypeError using given message */
    PyErr_SetString(PyExc_TypeError, message);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    define SWIG_PYTHON_USE_GIL
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  const char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

#if PY_VERSION_HEX < 0x02070000 /* 2.7.0 */
# error "This version of SWIG only supports Python >= 2.7"
#endif

#if PY_VERSION_HEX >= 0x03000000 && PY_VERSION_HEX < 0x03020000
# error "This version of SWIG only supports Python 3 >= 3.2"
#endif

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
  PyDict_SetItemString(d, name, obj);
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

SWIGINTERN int
SWIG_Python_CheckNoKeywords(PyObject *kwargs, const char *name) {
  int no_kwargs = 1;
  if (kwargs) {
    assert(PyDict_Check(kwargs));
    if (PyDict_Size(kwargs) > 0) {
      PyErr_Format(PyExc_TypeError, "%s() does not take keyword arguments", name);
      no_kwargs = 0;
    }
  }
  return no_kwargs;
}

/* A functor is a function object with one single object argument */
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  int fail = data ? data->implicitconv : 0;
  if (fail)
    PyErr_SetString(PyExc_TypeError, "Implicit conversion is prohibited for explicit constructors.");
  return fail;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
      data->newraw = PyObject_GetAttrString(data->klass, "__new__");
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, "__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
      data->delargs = !(flags & (METH_O));
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_repr(SwigPyObject *v)
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

/* We need a version taking two PyObject* parameters so it's a valid
 * PyCFunction to use in swigobject_methods[]. */
SWIGRUNTIME PyObject *
SwigPyObject_repr2(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  return SwigPyObject_repr((SwigPyObject*)v);
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *type = NULL, *value = NULL, *traceback = NULL;
      PyErr_Fetch(&type, &value, &traceback);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(type, value, traceback);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) {
    return NULL;
  } else {
    SwigPyObject *sobj = (SwigPyObject *)v;
    PyObject *obj = PyBool_FromLong(sobj->own);
    if (val) {
      if (PyObject_IsTrue(val)) {
        SwigPyObject_acquire(v,args);
      } else {
        SwigPyObject_disown(v,args);
      }
    } 
    return obj;
  }
}

static PyMethodDef
swigobject_methods[] = {
  {"disown",  SwigPyObject_disown,  METH_NOARGS,  "releases ownership of the pointer"},
  {"acquire", SwigPyObject_acquire, METH_NOARGS,  "acquires ownership of the pointer"},
  {"own",     SwigPyObject_own,     METH_VARARGS, "returns/sets ownership of the pointer"},
  {"append",  SwigPyObject_append,  METH_O,       "appends another 'this' object"},
  {"next",    SwigPyObject_next,    METH_NOARGS,  "returns the next 'this' object"},
  {"__repr__",SwigPyObject_repr2,   METH_NOARGS,  "returns object representation"},
  {0, 0, 0, 0}  
};

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#else
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyObject",                       /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                    /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                    /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((const char *)v->pack, (const char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      "SwigPyPacked",                       /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
      0,                                    /* tp_del */
      0,                                    /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
      0,                                    /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
      0,                                    /* tp_print */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
      0,                                    /* tp_prev */
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

static PyObject *Swig_This_global = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (Swig_This_global == NULL)
    Swig_This_global = SWIG_Python_str_FromChar("this");
  return Swig_This_global;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
      if (!SWIG_IsOK(res) && obj == Py_None) {
        if (ptr)
          *ptr = 0;
        if (PyErr_Occurred())
          PyErr_Clear();
        res = SWIG_OK;
      }
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    swig_cast_info *tc;

    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc)
      return SWIG_ERROR;
    tc = SWIG_TypeCheck(desc,ty);
    if (tc) {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    } else {
      return SWIG_ERROR;
    }
    return SWIG_OK;
  }
}

/* Convert a packed pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
        Py_DECREF(inst);
        inst = 0;
      }
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *empty_args = PyTuple_New(0);
    if (empty_args) {
      PyObject *empty_kwargs = PyDict_New();
      if (empty_kwargs) {
        inst = ((PyTypeObject *)data->newargs)->tp_new((PyTypeObject *)data->newargs, empty_args, empty_kwargs);
        Py_DECREF(empty_kwargs);
        if (inst) {
          if (PyObject_SetAttr(inst, SWIG_This(), swig_this) == -1) {
            Py_DECREF(inst);
            inst = 0;
          } else {
            Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
          }
        }
      }
      Py_DECREF(empty_args);
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
}

SWIGRUNTIME int
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
  PyObject **dictptr = _PyObject_GetDictPtr(inst);
  if (dictptr != NULL) {
    PyObject *dict = *dictptr;
    if (dict == NULL) {
      dict = PyDict_New();
      *dictptr = dict;
    }
    return PyDict_SetItem(dict, SWIG_This(), swig_this);
  }
#endif
  return PyObject_SetAttr(inst, SWIG_This(), swig_this);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      if (SWIG_Python_SetSwigThis(obj[0], obj[1]) != 0)
        return NULL;
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

SWIGRUNTIME void
SWIG_Python_DestroyModule(PyObject *obj)
{
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  Swig_This_global = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule("swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule("swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, "type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      PyObject *old_str = PyObject_Str(value);
      const char *tmp = SWIG_Python_str_AsChar(old_str);
      const char *errmesg = tmp ? tmp : "Invalid error message";
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, errmesg);
      } else {
	PyErr_Format(type, "%s %s", errmesg, mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
      if (!encoded_name)
        return -1;
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



#ifdef __cplusplus
extern "C" {
#endif

/* Method creation and docstring support functions */

SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name);
SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);
SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func);

#ifdef __cplusplus
}
#endif


  #define SWIG_exception(code, msg) do { SWIG_Error(code, msg); SWIG_fail;; } while(0) 

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that Python proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_DIRECTOR_PYTHON_HEADER_
#define SWIG_DIRECTOR_PYTHON_HEADER_

#include <string>
#include <iostream>
#include <exception>
#include <vector>
#include <map>


/*
  Use -DSWIG_PYTHON_DIRECTOR_NO_VTABLE if you don't want to generate a 'virtual
  table', and avoid multiple GetAttr calls to retrieve the python
  methods.
*/

#ifndef SWIG_PYTHON_DIRECTOR_NO_VTABLE
#ifndef SWIG_PYTHON_DIRECTOR_VTABLE
#define SWIG_PYTHON_DIRECTOR_VTABLE
#endif
#endif



/*
  Use -DSWIG_DIRECTOR_NO_UEH if you prefer to avoid the use of the
  Undefined Exception Handler provided by swig.
*/
#ifndef SWIG_DIRECTOR_NO_UEH
#ifndef SWIG_DIRECTOR_UEH
#define SWIG_DIRECTOR_UEH
#endif
#endif


/*
  Use -DSWIG_DIRECTOR_NORTTI if you prefer to avoid the use of the
  native C++ RTTI and dynamic_cast<>. But be aware that directors
  could stop working when using this option.
*/
#ifdef SWIG_DIRECTOR_NORTTI
/*
   When we don't use the native C++ RTTI, we implement a minimal one
   only for Directors.
*/
# ifndef SWIG_DIRECTOR_RTDIR
# define SWIG_DIRECTOR_RTDIR

namespace Swig {
  class Director;
  SWIGINTERN std::map<void *, Director *>& get_rtdir_map() {
    static std::map<void *, Director *> rtdir_map;
    return rtdir_map;
  }

  SWIGINTERNINLINE void set_rtdir(void *vptr, Director *rtdir) {
    get_rtdir_map()[vptr] = rtdir;
  }

  SWIGINTERNINLINE Director *get_rtdir(void *vptr) {
    std::map<void *, Director *>::const_iterator pos = get_rtdir_map().find(vptr);
    Director *rtdir = (pos != get_rtdir_map().end()) ? pos->second : 0;
    return rtdir;
  }
}
# endif /* SWIG_DIRECTOR_RTDIR */

# define SWIG_DIRECTOR_CAST(ARG) Swig::get_rtdir(static_cast<void *>(ARG))
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2) Swig::set_rtdir(static_cast<void *>(ARG1), ARG2)

#else

# define SWIG_DIRECTOR_CAST(ARG) dynamic_cast<Swig::Director *>(ARG)
# define SWIG_DIRECTOR_RGTR(ARG1, ARG2)

#endif /* SWIG_DIRECTOR_NORTTI */

extern "C" {
  struct swig_type_info;
}

namespace Swig {

  /* memory handler */
  struct GCItem {
    virtual ~GCItem() {}

    virtual int get_own() const {
      return 0;
    }
  };

  struct GCItem_var {
    GCItem_var(GCItem *item = 0) : _item(item) {
    }

    GCItem_var& operator=(GCItem *item) {
      GCItem *tmp = _item;
      _item = item;
      delete tmp;
      return *this;
    }

    ~GCItem_var() {
      delete _item;
    }

    GCItem * operator->() const {
      return _item;
    }

  private:
    GCItem *_item;
  };

  struct GCItem_Object : GCItem {
    GCItem_Object(int own) : _own(own) {
    }

    virtual ~GCItem_Object() {
    }

    int get_own() const {
      return _own;
    }

  private:
    int _own;
  };

  template <typename Type>
  struct GCItem_T : GCItem {
    GCItem_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCItem_T() {
      delete _ptr;
    }

  private:
    Type *_ptr;
  };

  template <typename Type>
  struct GCArray_T : GCItem {
    GCArray_T(Type *ptr) : _ptr(ptr) {
    }

    virtual ~GCArray_T() {
      delete[] _ptr;
    }

  private:
    Type *_ptr;
  };

  /* base class for director exceptions */
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;
  public:
    DirectorException(PyObject *error, const char *hdr ="", const char *msg ="") : swig_msg(hdr) {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      if (msg[0]) {
        swig_msg += " ";
        swig_msg += msg;
      }
      if (!PyErr_Occurred()) {
        PyErr_SetString(error, what());
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
    }

    virtual ~DirectorException() throw() {
    }

    /* Deprecated, use what() instead */
    const char *getMessage() const {
      return what();
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorException(error, msg);
    }

    static void raise(const char *msg) {
      raise(PyExc_RuntimeError, msg);
    }
  };

  /* type mismatch in the return value from a python method call */
  class DirectorTypeMismatchException : public DirectorException {
  public:
    DirectorTypeMismatchException(PyObject *error, const char *msg="")
      : DirectorException(error, "SWIG director type mismatch", msg) {
    }

    DirectorTypeMismatchException(const char *msg="")
      : DirectorException(PyExc_TypeError, "SWIG director type mismatch", msg) {
    }

    static void raise(PyObject *error, const char *msg) {
      throw DirectorTypeMismatchException(error, msg);
    }

    static void raise(const char *msg) {
      throw DirectorTypeMismatchException(msg);
    }
  };

  /* any python exception that occurs during a director method call */
  class DirectorMethodException : public DirectorException {
  public:
    DirectorMethodException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director method error.", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorMethodException(msg);
    }
  };

  /* attempt to call a pure virtual method via a director method */
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg = "")
      : DirectorException(PyExc_RuntimeError, "SWIG director pure virtual method called", msg) {
    }

    static void raise(const char *msg) {
      throw DirectorPureVirtualException(msg);
    }
  };


#if defined(SWIG_PYTHON_THREADS)
/*  __THREAD__ is the old macro to activate some thread support */
# if !defined(__THREAD__)
#   define __THREAD__ 1
# endif
#endif

#ifdef __THREAD__
# include "pythread.h"
  class Guard {
    PyThread_type_lock &mutex_;

  public:
    Guard(PyThread_type_lock & mutex) : mutex_(mutex) {
      PyThread_acquire_lock(mutex_, WAIT_LOCK);
    }

    ~Guard() {
      PyThread_release_lock(mutex_);
    }
  };
# define SWIG_GUARD(mutex) Guard _guard(mutex)
#else
# define SWIG_GUARD(mutex)
#endif

  /* director base class */
  class Director {
  private:
    /* pointer to the wrapped python object */
    PyObject *swig_self;
    /* flag indicating whether the object is owned by python or c++ */
    mutable bool swig_disown_flag;

    /* decrement the reference count of the wrapped python object */
    void swig_decref() const {
      if (swig_disown_flag) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_DECREF(swig_self);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }

  public:
    /* wrap a python object. */
    Director(PyObject *self) : swig_self(self), swig_disown_flag(false) {
    }

    /* discard our reference at destruction */
    virtual ~Director() {
      swig_decref();
    }

    /* return a pointer to the wrapped python object */
    PyObject *swig_get_self() const {
      return swig_self;
    }

    /* acquire ownership of the wrapped python object (the sense of "disown" is from python) */
    void swig_disown() const {
      if (!swig_disown_flag) {
        swig_disown_flag=true;
        swig_incref();
      }
    }

    /* increase the reference count of the wrapped python object */
    void swig_incref() const {
      if (swig_disown_flag) {
        Py_INCREF(swig_self);
      }
    }

    /* methods to implement pseudo protected director members */
    virtual bool swig_get_inner(const char * /* swig_protected_method_name */) const {
      return true;
    }

    virtual void swig_set_inner(const char * /* swig_protected_method_name */, bool /* swig_val */) const {
    }

  /* ownership management */
  private:
    typedef std::map<void *, GCItem_var> swig_ownership_map;
    mutable swig_ownership_map swig_owner;
#ifdef __THREAD__
    static PyThread_type_lock swig_mutex_own;
#endif

  public:
    template <typename Type>
    void swig_acquire_ownership_array(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCArray_T<Type>(vptr);
      }
    }

    template <typename Type>
    void swig_acquire_ownership(Type *vptr) const {
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_T<Type>(vptr);
      }
    }

    void swig_acquire_ownership_obj(void *vptr, int own) const {
      if (vptr && own) {
        SWIG_GUARD(swig_mutex_own);
        swig_owner[vptr] = new GCItem_Object(own);
      }
    }

    int swig_release_ownership(void *vptr) const {
      int own = 0;
      if (vptr) {
        SWIG_GUARD(swig_mutex_own);
        swig_ownership_map::iterator iter = swig_owner.find(vptr);
        if (iter != swig_owner.end()) {
          own = iter->second->get_own();
          swig_owner.erase(iter);
        }
      }
      return own;
    }

    template <typename Type>
    static PyObject *swig_pyobj_disown(PyObject *pyobj, PyObject *SWIGUNUSEDPARM(args)) {
      SwigPyObject *sobj = (SwigPyObject *)pyobj;
      sobj->own = 0;
      Director *d = SWIG_DIRECTOR_CAST(reinterpret_cast<Type *>(sobj->ptr));
      if (d)
        d->swig_disown();
      return PyWeakref_NewProxy(pyobj, NULL);
    }
  };

#ifdef __THREAD__
  PyThread_type_lock Director::swig_mutex_own = PyThread_allocate_lock();
#endif
}

#endif

/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_AuxOut swig_types[0]
#define SWIGTYPE_p_Dict swig_types[1]
#define SWIGTYPE_p_MXDict swig_types[2]
#define SWIGTYPE_p_allocator_type swig_types[3]
#define SWIGTYPE_p_casadi__Callback swig_types[4]
#define SWIGTYPE_p_casadi__CasadiMeta swig_types[5]
#define SWIGTYPE_p_casadi__CodeGenerator swig_types[6]
#define SWIGTYPE_p_casadi__DaeBuilder swig_types[7]
#define SWIGTYPE_p_casadi__DeserializerBase swig_types[8]
#define SWIGTYPE_p_casadi__DeserializingStream swig_types[9]
#define SWIGTYPE_p_casadi__FileDeserializer swig_types[10]
#define SWIGTYPE_p_casadi__FileSerializer swig_types[11]
#define SWIGTYPE_p_casadi__Function swig_types[12]
#define SWIGTYPE_p_casadi__FunctionBuffer swig_types[13]
#define SWIGTYPE_p_casadi__GenericExpressionCommon swig_types[14]
#define SWIGTYPE_p_casadi__GenericMatrixCommon swig_types[15]
#define SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t swig_types[16]
#define SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t swig_types[17]
#define SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t swig_types[18]
#define SWIGTYPE_p_casadi__GenericType swig_types[19]
#define SWIGTYPE_p_casadi__GlobalOptions swig_types[20]
#define SWIGTYPE_p_casadi__Importer swig_types[21]
#define SWIGTYPE_p_casadi__IndexAbstraction swig_types[22]
#define SWIGTYPE_p_casadi__Linsol swig_types[23]
#define SWIGTYPE_p_casadi__MX swig_types[24]
#define SWIGTYPE_p_casadi__MatrixCommon swig_types[25]
#define SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t swig_types[26]
#define SWIGTYPE_p_casadi__MatrixT_double_t swig_types[27]
#define SWIGTYPE_p_casadi__MatrixT_long_long_t swig_types[28]
#define SWIGTYPE_p_casadi__MetaCon swig_types[29]
#define SWIGTYPE_p_casadi__MetaVar swig_types[30]
#define SWIGTYPE_p_casadi__NlpBuilder swig_types[31]
#define SWIGTYPE_p_casadi__Opti swig_types[32]
#define SWIGTYPE_p_casadi__OptiAdvanced swig_types[33]
#define SWIGTYPE_p_casadi__OptiCallback swig_types[34]
#define SWIGTYPE_p_casadi__OptiSol swig_types[35]
#define SWIGTYPE_p_casadi__PrintableCommon swig_types[36]
#define SWIGTYPE_p_casadi__SXElem swig_types[37]
#define SWIGTYPE_p_casadi__SerializerBase swig_types[38]
#define SWIGTYPE_p_casadi__SerializingStream swig_types[39]
#define SWIGTYPE_p_casadi__SharedObject swig_types[40]
#define SWIGTYPE_p_casadi__SharedObjectInternal swig_types[41]
#define SWIGTYPE_p_casadi__Slice swig_types[42]
#define SWIGTYPE_p_casadi__Sparsity swig_types[43]
#define SWIGTYPE_p_casadi__SparsityInterfaceCommon swig_types[44]
#define SWIGTYPE_p_casadi__StringDeserializer swig_types[45]
#define SWIGTYPE_p_casadi__StringSerializer swig_types[46]
#define SWIGTYPE_p_casadi__Variable swig_types[47]
#define SWIGTYPE_p_casadi__WeakRef swig_types[48]
#define SWIGTYPE_p_casadi__XmlFile swig_types[49]
#define SWIGTYPE_p_char swig_types[50]
#define SWIGTYPE_p_const_reference swig_types[51]
#define SWIGTYPE_p_difference_type swig_types[52]
#define SWIGTYPE_p_double swig_types[53]
#define SWIGTYPE_p_first_type swig_types[54]
#define SWIGTYPE_p_key_type swig_types[55]
#define SWIGTYPE_p_long_long swig_types[56]
#define SWIGTYPE_p_mapped_type swig_types[57]
#define SWIGTYPE_p_p_double swig_types[58]
#define SWIGTYPE_p_second_type swig_types[59]
#define SWIGTYPE_p_size_type swig_types[60]
#define SWIGTYPE_p_std__initializer_listT_casadi__MX_t swig_types[61]
#define SWIGTYPE_p_std__initializer_listT_casadi__MatrixT_casadi__SXElem_t_t swig_types[62]
#define SWIGTYPE_p_std__invalid_argument swig_types[63]
#define SWIGTYPE_p_std__istream swig_types[64]
#define SWIGTYPE_p_std__mapT_std__string_casadi__GenericType_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__GenericType_t_t_t swig_types[65]
#define SWIGTYPE_p_std__mapT_std__string_casadi__MX_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MX_t_t_t swig_types[66]
#define SWIGTYPE_p_std__mapT_std__string_casadi__MatrixT_casadi__SXElem_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_casadi__SXElem_t_t_t_t swig_types[67]
#define SWIGTYPE_p_std__mapT_std__string_casadi__MatrixT_double_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_double_t_t_t_t swig_types[68]
#define SWIGTYPE_p_std__mapT_std__string_casadi__Sparsity_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__Sparsity_t_t_t swig_types[69]
#define SWIGTYPE_p_std__ostream swig_types[70]
#define SWIGTYPE_p_std__pairT_casadi__Slice_casadi__Slice_t swig_types[71]
#define SWIGTYPE_p_std__size_t swig_types[72]
#define SWIGTYPE_p_std__string swig_types[73]
#define SWIGTYPE_p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t swig_types[74]
#define SWIGTYPE_p_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t swig_types[75]
#define SWIGTYPE_p_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t swig_types[76]
#define SWIGTYPE_p_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t swig_types[77]
#define SWIGTYPE_p_std__vectorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_std__allocatorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_t_t swig_types[78]
#define SWIGTYPE_p_std__vectorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_t_t swig_types[79]
#define SWIGTYPE_p_std__vectorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_t_t swig_types[80]
#define SWIGTYPE_p_swig__SwigPyIterator swig_types[81]
#define SWIGTYPE_p_value_type swig_types[82]
static swig_type_info *swig_types[84];
static swig_module_info swig_module = {swig_types, 83, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#ifdef SWIG_TypeQuery
# undef SWIG_TypeQuery
#endif
#define SWIG_TypeQuery SWIG_Python_TypeQuery

/*-----------------------------------------------
              @(target):= _casadi.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit__casadi

#else
#  define SWIG_init    init_casadi

#endif
#define SWIG_name    "_casadi"

#define SWIGVERSION 0x040002 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(_obj);      
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_XINCREF(_obj);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      SWIG_PYTHON_THREAD_END_BLOCK;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XDECREF(_obj);
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}


namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}


#include <casadi/casadi.hpp>
#include <casadi/core/casadi_interrupt.hpp>


SWIGINTERN swig_type_info*
SWIG_pchar_descriptor(void)
{
  static int init = 0;
  static swig_type_info* info = 0;
  if (!init) {
    info = SWIG_TypeQuery("_p_char");
    init = 1;
  }
  return info;
}


SWIGINTERNINLINE PyObject *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  if (carray) {
    if (size > INT_MAX) {
      swig_type_info* pchar_descriptor = SWIG_pchar_descriptor();
      return pchar_descriptor ? 
	SWIG_InternalNewPointerObj(const_cast< char * >(carray), pchar_descriptor, 0) : SWIG_Py_Void();
    } else {
#if PY_VERSION_HEX >= 0x03000000
#if defined(SWIG_PYTHON_STRICT_BYTE_CHAR)
      return PyBytes_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#else
      return PyUnicode_DecodeUTF8(carray, static_cast< Py_ssize_t >(size), "surrogateescape");
#endif
#else
      return PyString_FromStringAndSize(carray, static_cast< Py_ssize_t >(size));
#endif
    }
  } else {
    return SWIG_Py_Void();
  }
}


SWIGINTERNINLINE PyObject * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


  namespace casadi {
    // Redirect printout
    static void pythonlogger(const char* s, std::streamsize num, bool error) {
      if (error) {
        PySys_WriteStderr("%.*s", static_cast<int>(num), s);
      } else {
        PySys_WriteStdout("%.*s", static_cast<int>(num), s);
      }
    }

    static bool pythoncheckinterrupted() {
      if (!casadi::InterruptHandler::is_main_thread()) return false;
      return PyErr_CheckSignals();
    }

    void handle_director_exception() {
	    std::string msg = "Exception in SWIG director ";
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      if (PyErr_ExceptionMatches(PyExc_KeyboardInterrupt)) {
        PyErr_Clear();
        SWIG_PYTHON_THREAD_END_BLOCK;
        throw casadi::KeyboardInterruptException();
      }
      PyObject *ptype, *pvalue, *ptraceback;
      PyErr_Fetch(&ptype, &pvalue, &ptraceback);
      PyObject* msg_py = PyObject_Str(pvalue);
      char *msg_char = SWIG_Python_str_AsChar(msg_py);
      msg = msg_char;
      SWIG_Python_str_DelForPy3(msg_char);
      Py_DECREF(msg_py);
      PyErr_Restore(ptype, pvalue, ptraceback);
      PyErr_Print();
      SWIG_PYTHON_THREAD_END_BLOCK;
      casadi_error(msg.c_str());
	  }
  }



#include <typeinfo>
#include <stdexcept>


#if defined(__GNUC__)
#  if __GNUC__ == 2 && __GNUC_MINOR <= 96
#     define SWIG_STD_NOMODERN_STL
#  endif
#endif


#include <string>


#include <stddef.h>


#include <iostream>

#if PY_VERSION_HEX >= 0x03020000
# define SWIGPY_SLICE_ARG(obj) ((PyObject*) (obj))
#else
# define SWIGPY_SLICE_ARG(obj) ((PySliceObject*) (obj))
#endif


namespace swig {
  struct stop_iteration {
  };

  struct SwigPyIterator {
  private:
    SwigPtr_PyObject _seq;

  protected:
    SwigPyIterator(PyObject *seq) : _seq(seq)
    {
    }
      
  public:
    virtual ~SwigPyIterator() {}

    // Access iterator method, required by Python
    virtual PyObject *value() const = 0;

    // Forward iterator method, required by Python
    virtual SwigPyIterator *incr(size_t n = 1) = 0;
    
    // Backward iterator method, very common in C++, but not required in Python
    virtual SwigPyIterator *decr(size_t /*n*/ = 1)
    {
      throw stop_iteration();
    }

    // Random access iterator methods, but not required in Python
    virtual ptrdiff_t distance(const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }

    virtual bool equal (const SwigPyIterator &/*x*/) const
    {
      throw std::invalid_argument("operation not supported");
    }
    
    // C++ common/needed methods
    virtual SwigPyIterator *copy() const = 0;

    PyObject *next()     
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      PyObject *obj = value();
      incr();       
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads
      return obj;     
    }

    /* Make an alias for Python 3.x */
    PyObject *__next__()
    {
      return next();
    }

    PyObject *previous()
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK; // disable threads       
      decr();
      PyObject *obj = value();
      SWIG_PYTHON_THREAD_END_BLOCK; // re-enable threads       
      return obj;
    }

    SwigPyIterator *advance(ptrdiff_t n)
    {
      return  (n > 0) ?  incr(n) : decr(-n);
    }
      
    bool operator == (const SwigPyIterator& x)  const
    {
      return equal(x);
    }
      
    bool operator != (const SwigPyIterator& x) const
    {
      return ! operator==(x);
    }
      
    SwigPyIterator& operator += (ptrdiff_t n)
    {
      return *advance(n);
    }

    SwigPyIterator& operator -= (ptrdiff_t n)
    {
      return *advance(-n);
    }
      
    SwigPyIterator* operator + (ptrdiff_t n) const
    {
      return copy()->advance(n);
    }

    SwigPyIterator* operator - (ptrdiff_t n) const
    {
      return copy()->advance(-n);
    }
      
    ptrdiff_t operator - (const SwigPyIterator& x) const
    {
      return x.distance(*this);
    }
      
    static swig_type_info* descriptor() {
      static int init = 0;
      static swig_type_info* desc = 0;
      if (!init) {
	desc = SWIG_TypeQuery("swig::SwigPyIterator *");
	init = 1;
      }	
      return desc;
    }    
  };

#if defined(SWIGPYTHON_BUILTIN)
  inline PyObject* make_output_iterator_builtin (PyObject *pyself)
  {
    Py_INCREF(pyself);
    return pyself;
  }
#endif
}


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  }
#endif
  return res;
}


  #define SWIG_From_long   PyInt_FromLong 


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_long_SS_long  (long long value)
{
  return ((value < LONG_MIN) || (value > LONG_MAX)) ?
    PyLong_FromLongLong(value) : PyInt_FromLong(static_cast< long >(value));
}
#endif


SWIGINTERNINLINE PyObject *
SWIG_From_ptrdiff_t  (ptrdiff_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    return SWIG_From_long  (static_cast< long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(ptrdiff_t) <= sizeof(long long) */
    return SWIG_From_long_SS_long  (static_cast< long long >(value));
  }
#endif
}


SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_long_SS_long (PyObject *obj, long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    long long v = PyLong_AsLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    long v;
    res = SWIG_AsVal_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    const double mant_min = -mant_max;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, mant_min, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, mant_min, mant_max)) {
      if (val) *val = (long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


SWIGINTERNINLINE int
SWIG_AsVal_ptrdiff_t (PyObject * obj, ptrdiff_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(ptrdiff_t) <= sizeof(long)) {
#endif
    long v;
    res = SWIG_AsVal_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(ptrdiff_t) <= sizeof(long long)) {
    long long v;
    res = SWIG_AsVal_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< ptrdiff_t >(v);
  }
#endif
  return res;
}


#include <algorithm>


#include <vector>


#include <utility>


#include <map>


#include <algorithm>


#define SWIG_FILE_WITH_INIT


#define SWIG_Error_return(code, msg)  { std::cerr << "Error occured in CasADi SWIG interface code:" << std::endl << "  "<< msg << std::endl;SWIG_Error(code, msg); return 0; }


namespace swig {
  template <class Type>
  struct noconst_traits {
    typedef Type noconst_type;
  };

  template <class Type>
  struct noconst_traits<const Type> {
    typedef Type noconst_type;
  };

  /*
    type categories
  */
  struct pointer_category { };
  struct value_category { };

  /*
    General traits that provides type_name and type_info
  */
  template <class Type> struct traits { };

  template <class Type>
  inline const char* type_name() {
    return traits<typename noconst_traits<Type >::noconst_type >::type_name();
  }

  template <class Type> struct traits_info {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  /*
    Partial specialization for pointers (traits_info)
  */
  template <class Type> struct traits_info<Type *> {
    static swig_type_info *type_query(std::string name) {
      name += " *";
      return SWIG_TypeQuery(name.c_str());
    }
    static swig_type_info *type_info() {
      static swig_type_info *info = type_query(type_name<Type>());
      return info;
    }
  };

  template <class Type>
  inline swig_type_info *type_info() {
    return traits_info<Type>::type_info();
  }

  /*
    Partial specialization for pointers (traits)
  */
  template <class Type> struct traits <Type *> {
    typedef pointer_category category;
    static std::string make_ptr_name(const char* name) {
      std::string ptrname = name;
      ptrname += " *";
      return ptrname;
    }
    static const char* type_name() {
      static std::string name = make_ptr_name(swig::type_name<Type>());
      return name.c_str();
    }
  };

  template <class Type, class Category>
  struct traits_as { };

  template <class Type, class Category>
  struct traits_check { };

}


namespace swig {  
  /*
    Traits that provides the from method
  */
  template <class Type> struct traits_from_ptr {
    static PyObject *from(Type *val, int owner = 0) {
      return SWIG_InternalNewPointerObj(val, type_info<Type>(), owner);
    }
  };

  template <class Type> struct traits_from {
    static PyObject *from(const Type& val) {
      return traits_from_ptr<Type>::from(new Type(val), 1);
    }
  };

  template <class Type> struct traits_from<Type *> {
    static PyObject *from(Type* val) {
      return traits_from_ptr<Type>::from(val, 0);
    }
  };

  template <class Type> struct traits_from<const Type *> {
    static PyObject *from(const Type* val) {
      return traits_from_ptr<Type>::from(const_cast<Type*>(val), 0);
    }
  };


  template <class Type>
  inline PyObject *from(const Type& val) {
    return traits_from<Type>::from(val);
  }

  template <class Type>
  inline PyObject *from_ptr(Type* val, int owner) {
    return traits_from_ptr<Type>::from(val, owner);
  }

  /*
    Traits that provides the asval/as/check method
  */
  template <class Type>
  struct traits_asptr {   
    static int asptr(PyObject *obj, Type **val) {
      int res = SWIG_ERROR;
      swig_type_info *descriptor = type_info<Type>();
      if (val) {
        Type *p = 0;
        int newmem = 0;
        res = descriptor ? SWIG_ConvertPtrAndOwn(obj, (void **)&p, descriptor, 0, &newmem) : SWIG_ERROR;
        if (SWIG_IsOK(res)) {
          if (newmem & SWIG_CAST_NEW_MEMORY) {
            res |= SWIG_NEWOBJMASK;
          }
          *val = p;
        }
      } else {
        res = descriptor ? SWIG_ConvertPtr(obj, 0, descriptor, 0) : SWIG_ERROR;
      }
      return res;
    }
  }; 

  template <class Type>
  inline int asptr(PyObject *obj, Type **vptr) {
    return traits_asptr<Type>::asptr(obj, vptr);
  }

  template <class Type> 
  struct traits_asval {
    static int asval(PyObject *obj, Type *val) {
      if (val) {
	Type *p = 0;
	int res = traits_asptr<Type>::asptr(obj, &p);
	if (!SWIG_IsOK(res)) return res;	
	if (p) {
	  typedef typename noconst_traits<Type>::noconst_type noconst_type;
	  *(const_cast<noconst_type*>(val)) = *p;
	  if (SWIG_IsNewObj(res)){
	    delete p;
	    res = SWIG_DelNewMask(res);
	  }
	  return res;
	} else {
	  return SWIG_ERROR;
	}
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };

  template <class Type> struct traits_asval<Type*> {
    static int asval(PyObject *obj, Type **val) {
      if (val) {
        typedef typename noconst_traits<Type>::noconst_type noconst_type;
        noconst_type *p = 0;
        int res = traits_asptr<noconst_type>::asptr(obj,  &p);
        if (SWIG_IsOK(res)) {
          *(const_cast<noconst_type**>(val)) = p;
	}
	return res;
      } else {
	return traits_asptr<Type>::asptr(obj, (Type **)(0));
      }
    }
  };
  
  template <class Type>
  inline int asval(PyObject *obj, Type *val) {
    return traits_asval<Type>::asval(obj, val);
  }

  template <class Type> 
  struct traits_as<Type, value_category> {
    static Type as(PyObject *obj) {
      Type v;
      int res = asval(obj, &v);
      if (!obj || !SWIG_IsOK(res)) {
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	throw std::invalid_argument("bad type");
      }
      return v;
    }
  };

  template <class Type> 
  struct traits_as<Type, pointer_category> {
    static Type as(PyObject *obj) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res) && v) {
	if (SWIG_IsNewObj(res)) {
	  Type r(*v);
	  delete v;
	  return r;
	} else {
	  return *v;
	}
      } else {
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	throw std::invalid_argument("bad type");
      }
    }
  };

  template <class Type> 
  struct traits_as<Type*, pointer_category> {
    static Type* as(PyObject *obj) {
      Type *v = 0;      
      int res = (obj ? traits_asptr<Type>::asptr(obj, &v) : SWIG_ERROR);
      if (SWIG_IsOK(res)) {
	return v;
      } else {
	if (!PyErr_Occurred()) {
	  SWIG_Error(SWIG_TypeError,  swig::type_name<Type>());
	}
	throw std::invalid_argument("bad type");
      }
    }
  };
    
  template <class Type>
  inline Type as(PyObject *obj) {
    return traits_as<Type, typename traits<Type>::category>::as(obj);
  }

  template <class Type> 
  struct traits_check<Type, value_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asval(obj, (Type *)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type> 
  struct traits_check<Type, pointer_category> {
    static bool check(PyObject *obj) {
      int res = obj ? asptr(obj, (Type **)(0)) : SWIG_ERROR;
      return SWIG_IsOK(res) ? true : false;
    }
  };

  template <class Type>
  inline bool check(PyObject *obj) {
    return traits_check<Type, typename traits<Type>::category>::check(obj);
  }
}


#include <functional>

namespace std {
  template <>
  struct less <PyObject *>
  {
    bool
    operator()(PyObject * v, PyObject *w) const
    { 
      bool res;
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      res = PyObject_RichCompareBool(v, w, Py_LT) ? true : false;
      /* This may fall into a case of inconsistent
               eg. ObjA > ObjX > ObjB
               but ObjA < ObjB
      */
      if( PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError) )
      {
        /* Objects can't be compared, this mostly occurred in Python 3.0 */
        /* Compare their ptr directly for a workaround */
        res = (v < w);
        PyErr_Clear();
      }
      SWIG_PYTHON_THREAD_END_BLOCK;
      return res;
    }
  };

  template <>
  struct less <swig::SwigPtr_PyObject>
  {
    bool
    operator()(const swig::SwigPtr_PyObject& v, const swig::SwigPtr_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

  template <>
  struct less <swig::SwigVar_PyObject>
  {
    bool
    operator()(const swig::SwigVar_PyObject& v, const swig::SwigVar_PyObject& w) const
    {
      return std::less<PyObject *>()(v, w);
    }
  };

}

namespace swig {
  template <> struct traits<PyObject *> {
    typedef value_category category;
    static const char* type_name() { return "PyObject *"; }
  };  

  template <>  struct traits_asval<PyObject * > {   
    typedef PyObject * value_type;
    static int asval(PyObject *obj, value_type *val) {
      if (val) *val = obj;
      return SWIG_OK;
    }
  };

  template <> 
  struct traits_check<PyObject *, value_category> {
    static bool check(PyObject *) {
      return true;
    }
  };

  template <>  struct traits_from<PyObject *> {
    typedef PyObject * value_type;
    static PyObject *from(const value_type& val) {
      Py_XINCREF(val);
      return val;
    }
  };
  
}

namespace swig {
  template <class Difference>
  inline size_t
  check_index(Difference i, size_t size, bool insert = false) {
    if ( i < 0 ) {
      if ((size_t) (-i) <= size)
	return (size_t) (i + size);
    } else if ( (size_t) i < size ) {
      return (size_t) i;
    } else if (insert && ((size_t) i == size)) {
      return size;
    }
    throw std::out_of_range("index out of range");
  }

  template <class Difference>
  void
  slice_adjust(Difference i, Difference j, Py_ssize_t step, size_t size, Difference &ii, Difference &jj, bool insert = false) {
    if (step == 0) {
      throw std::invalid_argument("slice step cannot be zero");
    } else if (step > 0) {
      // Required range: 0 <= i < size, 0 <= j < size, i <= j
      if (i < 0) {
        ii = 0;
      } else if (i < (Difference)size) {
        ii = i;
      } else if (insert && (i >= (Difference)size)) {
        ii = (Difference)size;
      }
      if (j < 0) {
        jj = 0;
      } else {
        jj = (j < (Difference)size) ? j : (Difference)size;
      }
      if (jj < ii)
        jj = ii;
    } else {
      // Required range: -1 <= i < size-1, -1 <= j < size-1, i >= j
      if (i < -1) {
        ii = -1;
      } else if (i < (Difference) size) {
        ii = i;
      } else if (i >= (Difference)(size-1)) {
        ii = (Difference)(size-1);
      }
      if (j < -1) {
        jj = -1;
      } else {
        jj = (j < (Difference)size ) ? j : (Difference)(size-1);
      }
      if (ii < jj)
        ii = jj;
    }
  }

  template <class Sequence, class Difference>
  inline typename Sequence::iterator
  getpos(Sequence* self, Difference i)  {
    typename Sequence::iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence, class Difference>
  inline typename Sequence::const_iterator
  cgetpos(const Sequence* self, Difference i)  {
    typename Sequence::const_iterator pos = self->begin();
    std::advance(pos, check_index(i,self->size()));
    return pos;
  }

  template <class Sequence>
  inline void
  erase(Sequence* seq, const typename Sequence::iterator& position) {
    seq->erase(position);
  }

  template <class Sequence>
  struct traits_reserve {
    static void reserve(Sequence & /*seq*/, typename Sequence::size_type /*n*/) {
      // This should be specialized for types that support reserve
    }
  };

  template <class Sequence, class Difference>
  inline Sequence*
  getslice(const Sequence* self, Difference i, Difference j, Py_ssize_t step) {
    typename Sequence::size_type size = self->size();
    Difference ii = 0;
    Difference jj = 0;
    swig::slice_adjust(i, j, step, size, ii, jj);

    if (step > 0) {
      typename Sequence::const_iterator sb = self->begin();
      typename Sequence::const_iterator se = self->begin();
      std::advance(sb,ii);
      std::advance(se,jj);
      if (step == 1) {
        return new Sequence(sb, se);
      } else {
        Sequence *sequence = new Sequence();
        swig::traits_reserve<Sequence>::reserve(*sequence, (jj - ii + step - 1) / step);
        typename Sequence::const_iterator it = sb;
        while (it!=se) {
          sequence->push_back(*it);
          for (Py_ssize_t c=0; c<step && it!=se; ++c)
            it++;
        }
        return sequence;
      } 
    } else {
      Sequence *sequence = new Sequence();
      swig::traits_reserve<Sequence>::reserve(*sequence, (ii - jj - step - 1) / -step);
      typename Sequence::const_reverse_iterator sb = self->rbegin();
      typename Sequence::const_reverse_iterator se = self->rbegin();
      std::advance(sb,size-ii-1);
      std::advance(se,size-jj-1);
      typename Sequence::const_reverse_iterator it = sb;
      while (it!=se) {
        sequence->push_back(*it);
        for (Py_ssize_t c=0; c<-step && it!=se; ++c)
          it++;
      }
      return sequence;
    }
  }

  template <class Sequence, class Difference, class InputSeq>
  inline void
  setslice(Sequence* self, Difference i, Difference j, Py_ssize_t step, const InputSeq& is = InputSeq()) {
    typename Sequence::size_type size = self->size();
    Difference ii = 0;
    Difference jj = 0;
    swig::slice_adjust(i, j, step, size, ii, jj, true);
    if (step > 0) {
      if (step == 1) {
        size_t ssize = jj - ii;
        if (ssize <= is.size()) {
          // expanding/staying the same size
          swig::traits_reserve<Sequence>::reserve(*self, self->size() - ssize + is.size());
          typename Sequence::iterator sb = self->begin();
          typename InputSeq::const_iterator isit = is.begin();
          std::advance(sb,ii);
          std::advance(isit, jj - ii);
          self->insert(std::copy(is.begin(), isit, sb), isit, is.end());
        } else {
          // shrinking
          typename Sequence::iterator sb = self->begin();
          typename Sequence::iterator se = self->begin();
          std::advance(sb,ii);
          std::advance(se,jj);
          self->erase(sb,se);
          sb = self->begin();
          std::advance(sb,ii);
          self->insert(sb, is.begin(), is.end());
        }
      } else {
        size_t replacecount = (jj - ii + step - 1) / step;
        if (is.size() != replacecount) {
          char msg[1024];
          sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
          throw std::invalid_argument(msg);
        }
        typename Sequence::const_iterator isit = is.begin();
        typename Sequence::iterator it = self->begin();
        std::advance(it,ii);
        for (size_t rc=0; rc<replacecount && it != self->end(); ++rc) {
          *it++ = *isit++;
          for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
            it++;
        }
      }
    } else {
      size_t replacecount = (ii - jj - step - 1) / -step;
      if (is.size() != replacecount) {
        char msg[1024];
        sprintf(msg, "attempt to assign sequence of size %lu to extended slice of size %lu", (unsigned long)is.size(), (unsigned long)replacecount);
        throw std::invalid_argument(msg);
      }
      typename Sequence::const_iterator isit = is.begin();
      typename Sequence::reverse_iterator it = self->rbegin();
      std::advance(it,size-ii-1);
      for (size_t rc=0; rc<replacecount && it != self->rend(); ++rc) {
        *it++ = *isit++;
        for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
          it++;
      }
    }
  }

  template <class Sequence, class Difference>
  inline void
  delslice(Sequence* self, Difference i, Difference j, Py_ssize_t step) {
    typename Sequence::size_type size = self->size();
    Difference ii = 0;
    Difference jj = 0;
    swig::slice_adjust(i, j, step, size, ii, jj, true);
    if (step > 0) {
      typename Sequence::iterator sb = self->begin();
      std::advance(sb,ii);
      if (step == 1) {
        typename Sequence::iterator se = self->begin();
        std::advance(se,jj);
        self->erase(sb,se);
      } else {
        typename Sequence::iterator it = sb;
        size_t delcount = (jj - ii + step - 1) / step;
        while (delcount) {
          it = self->erase(it);
          for (Py_ssize_t c=0; c<(step-1) && it != self->end(); ++c)
            it++;
          delcount--;
        }
      }
    } else {
      typename Sequence::reverse_iterator sb = self->rbegin();
      std::advance(sb,size-ii-1);
      typename Sequence::reverse_iterator it = sb;
      size_t delcount = (ii - jj - step - 1) / -step;
      while (delcount) {
        it = typename Sequence::reverse_iterator(self->erase((++it).base()));
        for (Py_ssize_t c=0; c<(-step-1) && it != self->rend(); ++c)
          it++;
        delcount--;
      }
    }
  }
}


#if defined(__SUNPRO_CC) && defined(_RWSTD_VER)
#  if !defined(SWIG_NO_STD_NOITERATOR_TRAITS_STL)
#    define SWIG_STD_NOITERATOR_TRAITS_STL
#  endif
#endif

#if !defined(SWIG_STD_NOITERATOR_TRAITS_STL)
#include <iterator>
#else
namespace std {
  template <class Iterator>
  struct iterator_traits {
    typedef ptrdiff_t difference_type;
    typedef typename Iterator::value_type value_type;
  };

  template <class Iterator, class Category,class T, class Reference, class Pointer, class Distance>
  struct iterator_traits<__reverse_bi_iterator<Iterator,Category,T,Reference,Pointer,Distance> > {
    typedef Distance difference_type;
    typedef T value_type;
  };

  template <class T>
  struct iterator_traits<T*> {
    typedef T value_type;
    typedef ptrdiff_t difference_type;
  };

  template<typename _InputIterator>
  inline typename iterator_traits<_InputIterator>::difference_type
  distance(_InputIterator __first, _InputIterator __last)
  {
    typename iterator_traits<_InputIterator>::difference_type __n = 0;
    while (__first != __last) {
      ++__first; ++__n;
    }
    return __n;
  }
}
#endif


namespace swig {
  template<typename OutIterator>
  class SwigPyIterator_T :  public SwigPyIterator
  {
  public:
    typedef OutIterator out_iterator;
    typedef typename std::iterator_traits<out_iterator>::value_type value_type;    
    typedef SwigPyIterator_T<out_iterator> self_type;

    SwigPyIterator_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator(seq), current(curr)
    {
    }

    const out_iterator& get_current() const
    {
      return current;
    }

    
    bool equal (const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return (current == iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }
    
    ptrdiff_t distance(const SwigPyIterator &iter) const
    {
      const self_type *iters = dynamic_cast<const self_type *>(&iter);
      if (iters) {
	return std::distance(current, iters->get_current());
      } else {
	throw std::invalid_argument("bad iterator type");
      }
    }    
    
  protected:
    out_iterator current;
  };
  
  template <class ValueType>
  struct from_oper 
  {
    typedef const ValueType& argument_type;
    typedef PyObject *result_type;
    result_type operator()(argument_type v) const
    {
      return swig::from(v);
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyForwardIteratorOpen_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;
    typedef SwigPyForwardIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyForwardIteratorOpen_T(out_iterator curr, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq)
    {
    }
    
    PyObject *value() const {
      return from(static_cast<const value_type&>(*(base::current)));
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	++base::current;
      }
      return this;
    }

  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorOpen_T :  public SwigPyForwardIteratorOpen_T<OutIterator, ValueType, FromOper>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;
    typedef SwigPyIteratorOpen_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorOpen_T(out_iterator curr, PyObject *seq)
      : SwigPyForwardIteratorOpen_T<OutIterator>(curr, seq)
    {
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	--base::current;
      }
      return this;
    }
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyForwardIteratorClosed_T :  public SwigPyIterator_T<OutIterator>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;    
    typedef SwigPyForwardIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyForwardIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
      : SwigPyIterator_T<OutIterator>(curr, seq), begin(first), end(last)
    {
    }
    
    PyObject *value() const {
      if (base::current == end) {
	throw stop_iteration();
      } else {
	return from(static_cast<const value_type&>(*(base::current)));
      }
    }
    
    SwigPyIterator *copy() const
    {
      return new self_type(*this);
    }

    SwigPyIterator *incr(size_t n = 1)
    {
      while (n--) {
	if (base::current == end) {
	  throw stop_iteration();
	} else {
	  ++base::current;
	}
      }
      return this;
    }

  protected:
    out_iterator begin;
    out_iterator end;
  };

  template<typename OutIterator, 
	   typename ValueType = typename std::iterator_traits<OutIterator>::value_type,
	   typename FromOper = from_oper<ValueType> >
  class SwigPyIteratorClosed_T :  public SwigPyForwardIteratorClosed_T<OutIterator,ValueType,FromOper>
  {
  public:
    FromOper from;
    typedef OutIterator out_iterator;
    typedef ValueType value_type;
    typedef SwigPyIterator_T<out_iterator>  base;
    typedef SwigPyForwardIteratorClosed_T<OutIterator, ValueType, FromOper> base0;
    typedef SwigPyIteratorClosed_T<OutIterator, ValueType, FromOper> self_type;
    
    SwigPyIteratorClosed_T(out_iterator curr, out_iterator first, out_iterator last, PyObject *seq)
      : SwigPyForwardIteratorClosed_T<OutIterator,ValueType,FromOper>(curr, first, last, seq)
    {
    }

    SwigPyIterator *decr(size_t n = 1)
    {
      while (n--) {
	if (base::current == base0::begin) {
	  throw stop_iteration();
	} else {
	  --base::current;
	}
      }
      return this;
    }
  };


  template<typename OutIter>
  inline SwigPyIterator*
  make_output_forward_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
  {
    return new SwigPyForwardIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, const OutIter& begin,const OutIter& end, PyObject *seq = 0)
  {
    return new SwigPyIteratorClosed_T<OutIter>(current, begin, end, seq);
  }

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_forward_iterator(const OutIter& current, PyObject *seq = 0)
  {
    return new SwigPyForwardIteratorOpen_T<OutIter>(current, seq);
  }

  template<typename OutIter>
  inline SwigPyIterator*
  make_output_iterator(const OutIter& current, PyObject *seq = 0)
  {
    return new SwigPyIteratorOpen_T<OutIter>(current, seq);
  }

}


namespace swig
{
  template <class T>
  struct SwigPySequence_Ref
  {
    SwigPySequence_Ref(PyObject* seq, Py_ssize_t index)
      : _seq(seq), _index(index)
    {
    }
    
    operator T () const
    {
      swig::SwigVar_PyObject item = PySequence_GetItem(_seq, _index);
      try {
	return swig::as<T>(item);
      } catch (const std::invalid_argument& e) {
	char msg[1024];
	sprintf(msg, "in sequence element %d ", (int)_index);
	if (!PyErr_Occurred()) {
	  ::SWIG_Error(SWIG_TypeError,  swig::type_name<T>());
	}
	SWIG_Python_AddErrorMsg(msg);
	SWIG_Python_AddErrorMsg(e.what());
	throw;
      }
    }

    SwigPySequence_Ref& operator=(const T& v)
    {
      PySequence_SetItem(_seq, _index, swig::from<T>(v));
      return *this;
    }

  private:
    PyObject* _seq;
    Py_ssize_t _index;
  };

  template <class T>
  struct SwigPySequence_ArrowProxy
  {
    SwigPySequence_ArrowProxy(const T& x): m_value(x) {}
    const T* operator->() const { return &m_value; }
    operator const T*() const { return &m_value; }
    T m_value;
  };

  template <class T, class Reference >
  struct SwigPySequence_InputIterator
  {
    typedef SwigPySequence_InputIterator<T, Reference > self;

    typedef std::random_access_iterator_tag iterator_category;
    typedef Reference reference;
    typedef T value_type;
    typedef T* pointer;
    typedef Py_ssize_t difference_type;

    SwigPySequence_InputIterator()
    {
    }

    SwigPySequence_InputIterator(PyObject* seq, Py_ssize_t index)
      : _seq(seq), _index(index)
    {
    }

    reference operator*() const
    {
      return reference(_seq, _index);
    }

    SwigPySequence_ArrowProxy<T>
    operator->() const {
      return SwigPySequence_ArrowProxy<T>(operator*());
    }

    bool operator==(const self& ri) const
    {
      return (_index == ri._index) && (_seq == ri._seq);
    }

    bool operator!=(const self& ri) const
    {
      return !(operator==(ri));
    }

    self& operator ++ ()
    {
      ++_index;
      return *this;
    }

    self& operator -- ()
    {
      --_index;
      return *this;
    }

    self& operator += (difference_type n)
    {
      _index += n;
      return *this;
    }

    self operator +(difference_type n) const
    {
      return self(_seq, _index + n);
    }

    self& operator -= (difference_type n)
    {
      _index -= n;
      return *this;
    }

    self operator -(difference_type n) const
    {
      return self(_seq, _index - n);
    }

    difference_type operator - (const self& ri) const
    {
      return _index - ri._index;
    }

    bool operator < (const self& ri) const
    {
      return _index < ri._index;
    }

    reference
    operator[](difference_type n) const
    {
      return reference(_seq, _index + n);
    }

  private:
    PyObject* _seq;
    difference_type _index;
  };

  // STL container wrapper around a Python sequence
  template <class T>
  struct SwigPySequence_Cont
  {
    typedef SwigPySequence_Ref<T> reference;
    typedef const SwigPySequence_Ref<T> const_reference;
    typedef T value_type;
    typedef T* pointer;
    typedef Py_ssize_t difference_type;
    typedef size_t size_type;
    typedef const pointer const_pointer;
    typedef SwigPySequence_InputIterator<T, reference> iterator;
    typedef SwigPySequence_InputIterator<T, const_reference> const_iterator;

    SwigPySequence_Cont(PyObject* seq) : _seq(0)
    {
      if (!PySequence_Check(seq)) {
	throw std::invalid_argument("a sequence is expected");
      }
      _seq = seq;
      Py_INCREF(_seq);
    }

    ~SwigPySequence_Cont()
    {
      Py_XDECREF(_seq);
    }

    size_type size() const
    {
      return static_cast<size_type>(PySequence_Size(_seq));
    }

    bool empty() const
    {
      return size() == 0;
    }

    iterator begin()
    {
      return iterator(_seq, 0);
    }

    const_iterator begin() const
    {
      return const_iterator(_seq, 0);
    }

    iterator end()
    {
      return iterator(_seq, size());
    }

    const_iterator end() const
    {
      return const_iterator(_seq, size());
    }

    reference operator[](difference_type n)
    {
      return reference(_seq, n);
    }

    const_reference operator[](difference_type n)  const
    {
      return const_reference(_seq, n);
    }

    bool check() const
    {
      Py_ssize_t s = size();
      for (Py_ssize_t i = 0; i < s; ++i) {
	swig::SwigVar_PyObject item = PySequence_GetItem(_seq, i);
	if (!swig::check<value_type>(item))
	  return false;
      }
      return true;
    }

  private:
    PyObject* _seq;
  };

}



  namespace casadi {
    /* Check if Null or None */
    bool is_null(PyObject *p);

    /* Typemaps from CasADi types to types in the interfaced language:
     *
     * to_ptr: Converts a pointer in interfaced language to C++:
     *   Input: GUESTOBJECT pointer p
     *   Output: Pointer to pointer: At input, pointer to pointer to temporary
     *   The routine will either:
     *     - Do nothing, if 0
     *     - Change the pointer
     *     - Change the temporary object
     *   Returns true upon success, else false
     *
     * from_ptr: Converts result from CasADi to interfaced language
     */

    // Basic types
    bool to_ptr(PyObject *p, bool** m);
    PyObject* from_ptr(const bool *a);
    bool to_ptr(PyObject *p, casadi_int** m);
    PyObject* from_ptr(const casadi_int *a);
    bool to_ptr(PyObject *p, double** m);
    PyObject* from_ptr(const double *a);
    bool to_ptr(PyObject *p, std::string** m);
    PyObject* from_ptr(const std::string *a);

    // std::vector










    template<typename M> bool to_ptr(PyObject *p, std::vector<M>** m);
    template<typename M> bool to_ptr(PyObject *p, std::vector< std::vector<M> >** m);
    template<typename M> PyObject* from_ptr(const std::vector<M> *a);

    // std::pair




    template<typename M1, typename M2> bool to_ptr(PyObject *p, std::pair<M1, M2>** m);
    template<typename M1, typename M2> PyObject* from_ptr(const std::pair<M1, M2>* a);

    // std::map
    template<typename M> bool to_ptr(PyObject *p, std::map<std::string, M>** m);
    template<typename M> PyObject* from_ptr(const std::map<std::string, M> *a);

    // Slice
    bool to_ptr(PyObject *p, casadi::Slice** m);
    PyObject* from_ptr(const casadi::Slice *a);

    // Sparsity
    bool to_ptr(PyObject *p, casadi::Sparsity** m);
    PyObject* from_ptr(const casadi::Sparsity *a);

    // Matrix<>
    bool to_ptr(PyObject *p, casadi::DM** m);
    PyObject* from_ptr(const casadi::DM *a);
    bool to_ptr(PyObject *p, casadi::IM** m);
    PyObject* from_ptr(const casadi::IM *a);
    bool to_ptr(PyObject *p, casadi::SX** m);
    PyObject* from_ptr(const casadi::SX *a);

    // MX
    bool to_ptr(PyObject *p, casadi::MX** m);
    PyObject* from_ptr(const casadi::MX *a);

    // Function
    bool to_ptr(PyObject *p, casadi::Function** m);
    PyObject* from_ptr(const casadi::Function *a);

    // SXElem
    bool to_ptr(PyObject *p, casadi::SXElem** m);
    PyObject* from_ptr(const casadi::SXElem *a);

    // GenericType
    bool to_ptr(PyObject *p, casadi::GenericType** m);
    PyObject* from_ptr(const casadi::GenericType *a);

    // Same as to_ptr, but with pointer instead of pointer to pointer
    template<typename M> bool to_val(PyObject *p, M* m);

    // Check if conversion is possible
    template<typename M> bool can_convert(PyObject *p) { return to_ptr(p, static_cast<M**>(0));}

    // Same as the above, but with reference instead of pointer
    template<typename M> PyObject* from_ref(const M& m) { return from_ptr(&m);}

    // Specialization for std::vectors of booleans
    PyObject* from_ref(std::vector<bool>::const_reference m) {
      bool tmp = m;
      return from_ptr(&tmp);
    }

    // Same as the above, but with a temporary object
    template<typename M> PyObject* from_tmp(M m) { return from_ptr(&m);}








    PyObject* full(const DM& m, bool simplify=false) {

      PyObject *p = from_ptr(&m);
      PyObject *method_name = PyString_FromString("toarray");
      PyObject *cr = PyObject_CallMethodObjArgs(p, method_name, (simplify? Py_True: Py_False), 0);
      Py_DECREF(method_name);
      Py_DECREF(p);
      if (cr) return cr;
      return Py_None;








    }


    // Convert to a sparse matrix
    PyObject* sparse(const DM& m) {

      PyObject *p = from_ptr(&m);
      PyObject *cr = PyObject_CallMethod(p, (char*) "tocsc", 0);
      Py_DECREF(p);
      if (cr) return cr;
      return Py_None;










    }

    PyObject* full_or_sparse(const DM& m, bool simplify=false) {
      if (m.is_dense()) {
        return full(m, simplify);
      } else {
        PyObject* p = sparse(m);
        if (is_null(p)) return from_ptr(&m);
        return p;
      }
    }



    PyObject* get_Python_helper(const std::string& name) {
#if PY_VERSION_HEX < 0x03070000
      PyObject* module = PyImport_AddModule("casadi");
#else
      PyObject* c_name = PyString_FromString("casadi");
      PyObject* module = PyImport_GetModule(c_name);
      Py_DECREF(c_name);
#endif
      if (!module) {
        if (PyErr_Occurred()) {
          PyErr_Clear();
        }
      }
      PyObject* dict = PyModule_GetDict(module);
      return PyDict_GetItemString(dict, (char*) name.c_str());
    }

    template<class T>
    bool casadi_object_from_fun(PyObject *p, T** m, const std::string& fun, const std::function<bool(PyObject*, T**)> & conv) {
      PyObject* dm = get_Python_helper(fun);
      if (!dm) return false;
      PyObject *check_only = m? Py_False : Py_True;
      PyObject *cr = PyObject_CallFunctionObjArgs(dm, p, check_only, NULL);
      if (!cr) return false;
      bool ret;
      if (PyBool_Check(cr)) {
        ret = PyObject_IsTrue(cr);
      } else {
        ret = conv(cr, m);
      }
      Py_DECREF(cr);
      return ret;
    }

    bool SX_from_array_conv(PyObject *p, casadi::SX** m) {
      std::vector<SXElem> data;
      if (!to_val(PyTuple_GetItem(p, 2), &data)) return false;
      casadi_int nrow; to_val(PyTuple_GetItem(p, 0), &nrow);
      casadi_int ncol; to_val(PyTuple_GetItem(p, 1), &ncol);
      if (m) {
        **m = casadi::SX::zeros(nrow, ncol);
        casadi_densify(get_ptr(data), (**m).sparsity().T(), (**m).ptr(), true);
      }
      return true;
    }

    bool IM_from_array_conv(PyObject *p, casadi::IM** m) {
      if (!m) return true;
      std::vector<casadi_int> data;
      if (!to_val(PyTuple_GetItem(p, 2), &data)) return false;
      casadi_int nrow; to_val(PyTuple_GetItem(p, 0), &nrow);
      casadi_int ncol; to_val(PyTuple_GetItem(p, 1), &ncol);
      **m = IM::zeros(nrow, ncol);
      casadi_densify(get_ptr(data), (**m).sparsity().T(), (**m).ptr(), true);
      return true;
    }

    bool DM_from_array_conv(PyObject *p, casadi::DM** m) {
      if (!m) return true;
      std::vector<double> data;
      if (!to_val(PyTuple_GetItem(p, 2), &data)) return false;
      casadi_int nrow; to_val(PyTuple_GetItem(p, 0), &nrow);
      casadi_int ncol; to_val(PyTuple_GetItem(p, 1), &ncol);
      **m = DM::zeros(nrow, ncol);
      casadi_densify(get_ptr(data), (**m).sparsity().T(), (**m).ptr(), true);
      return true;
    }

    bool DM_from_csc_conv(PyObject *p, casadi::DM** m) {
      std::vector<double> data;
      std::vector<casadi_int> colind, row;
      if (!to_val(PyTuple_GetItem(p, 4), &data)) return false;
      if (!to_val(PyTuple_GetItem(p, 3), &row)) return false;
      if (!to_val(PyTuple_GetItem(p, 2), &colind)) return false;
      casadi_int nrow; to_val(PyTuple_GetItem(p, 0), &nrow);
      casadi_int ncol; to_val(PyTuple_GetItem(p, 1), &ncol);
      **m = casadi::Matrix<double>(casadi::Sparsity(nrow,ncol,colind,row), data, false);
      return true;
    }

    bool SX_from_array(PyObject *p, casadi::SX** m) {
      return casadi_object_from_fun<casadi::SX>(p, m, "SX_from_array", SX_from_array_conv);
    }

    bool IM_from_array(PyObject *p, casadi::IM** m) {
      return casadi_object_from_fun<casadi::IM>(p, m, "IM_from_array", IM_from_array_conv);
    }

    bool DM_from_array(PyObject *p, casadi::DM** m) {
      return casadi_object_from_fun<casadi::DM>(p, m, "DM_from_array", DM_from_array_conv);
    }

    bool DM_from_csc(PyObject *p, casadi::DM** m) {
      return casadi_object_from_fun<casadi::DM>(p, m, "DM_from_csc", DM_from_csc_conv);
    }

    bool is_scalar_np_array(PyObject *p) {
      if (PyObject_HasAttrString(p, "__array__")) {
        PyObject *cr = PyObject_GetAttrString(p, (char*) "size");
        if (cr) {
          casadi_int size;
          casadi_int res = to_val(cr, &size);
          Py_DECREF(cr);
          if (!res) return false;
          return size==1;
        } else {
          PyErr_Clear();
          return false;
        }
      }
      return false;
   }




  } // namespace CasADi
 

  namespace casadi {
    template<typename M> bool to_val(PyObject *p, M* m) {
      // Copy the pointer
      M *m2 = m;
      bool ret = to_ptr(p, m ? &m2 : 0);
      // If pointer changed, copy the object
      if (m!=m2) *m=*m2;
      return ret;
    }

    // Same as to_ptr, but with GenericType
    template<typename M> bool to_generic(PyObject *p, GenericType** m) {
      if (m) {
        // Temporary
        M tmp, *tmp_ptr=&tmp;
        bool ret = to_ptr(p, &tmp_ptr);
        if (!ret) return ret;
        **m = GenericType(*tmp_ptr);
        return ret;
      } else {
        return to_ptr(p, static_cast<M**>(0));
      }
    }

    // Check if casadi_int
    template<typename T> struct is_int {
      static inline bool check() {return false;}
    };

    template<> struct is_int<casadi_int> {
      static inline bool check() {return true;}
    };

    bool is_null(PyObject *p) {

      if (p == Py_None) return true;




      return false;
    }






































  } // namespace casadi
 


SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r;
  if (!PyBool_Check(obj))
    return SWIG_ERROR;
  r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}


  namespace casadi {
    bool to_ptr(PyObject *p, bool** m) {
      // Treat Null
      if (is_null(p)) return false;

      // Standard typemaps
      if (SWIG_IsOK(SWIG_AsVal_bool (p, m ? *m : 0))) return true;








      // No match
      return false;
    }

    PyObject * from_ptr(const bool *a) {

      return PyBool_FromLong(*a);





    }
  } // namespace casadi
 

SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


  namespace casadi {
    bool to_ptr(PyObject *p, casadi_int** m) {
      // Treat Null
      if (is_null(p)) return false;

      // long long
      {
        long long tmp;
        if (SWIG_IsOK(SWIG_AsVal_long_SS_long (p, &tmp))) {
          if (m) **m = static_cast<casadi_int>(tmp);
          return true;
        }
      }


      if (is_scalar_np_array(p)) {
        PyObject *cr = PyObject_CallMethod(p, (char*) "item", 0);
        if (cr) {
          casadi_int res = to_ptr(cr, m);
          Py_DECREF(cr);
          if (!res) return false;
          return true;
        } else {
          PyErr_Clear();
          return false;
        }
      }


      bool tmp;
      if (to_val(p, m? &tmp : 0)) {
        if (m) **m = tmp;
        return true;
      }

      // No match
      return false;
    }

    PyObject * from_ptr(const casadi_int *a) {




      // For python on Windows
      if (*a > PyInt_GetMax() || *a < -(PyInt_GetMax()-1)) return PyLong_FromLongLong(*a);
      return PyInt_FromLong(*a);







    }
  } // namespace casadi
 

  namespace casadi {
    bool to_ptr(PyObject *p, double** m) {
      // Treat Null
      if (is_null(p)) return false;

      // Standard typemaps
      if (SWIG_IsOK(SWIG_AsVal_double (p, m ? *m : 0))) return true;


      if (is_scalar_np_array(p)) {
        PyObject *cr = PyObject_CallMethod(p, (char*) "item", 0);
        if (cr) {
          casadi_int res = to_ptr(cr, m);
          Py_DECREF(cr);
          if (!res) return false;
          return true;
        } else {
          PyErr_Clear();
          return false;
        }
      }


      casadi_int tmp;
      if (to_val(p, m? &tmp: 0)) {
        if (m) **m = tmp;
        return true;
      }

      // No match
      return false;
    }

    PyObject * from_ptr(const double *a) {

      return PyFloat_FromDouble(*a);





    }
  } // namespace casadi
 

  namespace casadi {






























































































































































































    template<typename M> bool to_ptr(PyObject *p, std::vector<M>** m) {
      // Treat Null
      if (is_null(p)) return false;


      // Some built-in types are iterable
      if (PyDict_Check(p) || PyString_Check(p) || PySet_Check(p) || PyUnicode_Check(p)) return false;

      // Make sure shape is 1D, if defined.
      if (PyObject_HasAttrString(p, "shape")) {
        PyObject * shape = PyObject_GetAttrString(p, "shape");
        if(!PyTuple_Check(shape) || PyTuple_Size(shape)!=1) {
          Py_DECREF(shape);
          return false;
        }
      }

      // Iterator to the sequence
      PyObject *it = PyObject_GetIter(p);
      if (!it) {
        PyErr_Clear();
        return false;
      }

      // Allocate elements
      if (m) (**m).clear();

      // Temporary
      M tmp;

      PyObject *pe;
      // Iterate over sequence
      while ((pe=PyIter_Next(it))) {
        // Convert element
        M *m_i = m ? &tmp : 0;
        if (!to_ptr(pe, m_i ? &m_i : 0)) {
          // Failure
          Py_DECREF(pe);
          Py_DECREF(it);
          return false;
        }
        if (m) (**m).push_back(*m_i);
        Py_DECREF(pe);
      }
      Py_DECREF(it);
      return true;





      // No match
      return false;
    }



























    template<typename M> PyObject* from_ptr(const std::vector<M> *a) {

      // std::vector maps to Python list
      PyObject* ret = PyList_New(a->size());
      if (!ret) return 0;
      for (casadi_int k=0; k<a->size(); ++k) {
        PyObject* el = from_ref(a->at(k));
        if (!el) {
          Py_DECREF(ret);
          return 0;
        }
        PyList_SetItem(ret, k, el);
      }
      return ret;













    }
  } // namespace casadi


  namespace casadi {








































    template<typename M> bool to_ptr(PyObject *p, std::vector< std::vector<M> >** m) {
      // Treat Null
      if (is_null(p)) return false;

      // Pass on to to_ptr(GUESTOBJECT *p, std::vector<M>** m)
      if (to_ptr< std::vector<M> >(p, m)) return true;





      return false;
    }

  } // namespace casadi


  namespace casadi {
    bool to_ptr(PyObject *p, Function** m) {
      // Treat Null
      if (is_null(p)) return false;

      // Function already?
      if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(m),
                                    SWIGTYPE_p_casadi__Function, 0))) {
        return true;
      }

      // No match
      return false;
    }

    PyObject* from_ptr(const Function *a) {
      return SWIG_NewPointerObj(new Function(*a), SWIGTYPE_p_casadi__Function, SWIG_POINTER_OWN);
    }
  } // namespace casadi


  namespace casadi {
    bool to_ptr(PyObject *p, GenericType** m) {

      if (p==Py_None) {
        if (m) **m=GenericType();
        return true;
      }


      // Treat Null
      if (is_null(p)) return false;

      // GenericType already?
      if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(m),
                                    SWIGTYPE_p_casadi__GenericType, 0))) {
        return true;
      }

      // Try to convert to different types
      if (to_generic<casadi_int>(p, m)
          || to_generic<double>(p, m)
          || to_generic<std::string>(p, m)
          || to_generic<std::vector<casadi_int> >(p, m)
          || to_generic<std::vector<double> >(p, m)
          || to_generic<std::vector<bool> >(p, m)
          || to_generic<std::vector<std::string> >(p, m)
          || to_generic<std::vector<std::vector<casadi_int> > >(p, m)
          || to_generic<std::vector<std::vector<double> > >(p, m)
          || to_generic<casadi::Function>(p, m)
          || to_generic<std::vector<casadi::Function> >(p, m)
          || to_generic<casadi::GenericType::Dict>(p, m)) {
        return true;
      }

      // Check if it can be converted to boolean (last as e.g. can be converted to boolean)
      if (to_generic<bool>(p, m)) return true;

      // No match
      return false;
    }

    PyObject * from_ptr(const GenericType *a) {
      switch (a->getType()) {
      case OT_BOOL: return from_tmp(a->as_bool());
      case OT_INT: return from_tmp(a->as_int());
      case OT_DOUBLE: return from_tmp(a->as_double());
      case OT_STRING: return from_tmp(a->as_string());
      case OT_INTVECTOR: return from_tmp(a->as_int_vector());
      case OT_INTVECTORVECTOR: return from_tmp(a->as_int_vector_vector());
      case OT_BOOLVECTOR: return from_tmp(a->as_bool_vector());
      case OT_DOUBLEVECTOR: return from_tmp(a->as_double_vector());
      case OT_DOUBLEVECTORVECTOR: return from_tmp(a->as_double_vector_vector());
      case OT_STRINGVECTOR: return from_tmp(a->as_string_vector());
      case OT_DICT: return from_tmp(a->as_dict());
      case OT_FUNCTION: return from_tmp(a->as_function());
      case OT_FUNCTIONVECTOR: return from_tmp(a->as_function_vector());

      case OT_NULL:
      case OT_VOIDPTR:
        return Py_None;





      default: return 0;
      }
    }
  } // namespace casadi


  namespace casadi {
    bool to_ptr(PyObject *p, std::string** m) {
      // Treat Null
      if (is_null(p)) return false;

      // String already?
      if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(m),
                                    SWIGTYPE_p_std__string, 0))) {
        return true;
      }


      if (PyString_Check(p) || PyUnicode_Check(p)) {
        if (m) (*m)->clear();
        char* my_char = SWIG_Python_str_AsChar(p);
        if (m) (*m)->append(my_char);
        SWIG_Python_str_DelForPy3(my_char);
        return true;
      }














      // No match
      return false;
    }

    PyObject* from_ptr(const std::string *a) {

      return PyString_FromString(a->c_str());





    }
  } // namespace casadi


  namespace casadi {
    bool to_ptr(PyObject *p, Slice** m) {
      // Treat Null
      if (is_null(p)) return false;

      // Slice already?
      if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(m),
                                    SWIGTYPE_p_casadi__Slice, 0))) {
        return true;
      }



      // Python casadi_int
      if (PyInt_Check(p)) {
        if (m) {
          (**m).start = PyInt_AsLong(p);
          (**m).stop = (**m).start+1;
          if ((**m).stop==0) (**m).stop = std::numeric_limits<casadi_int>::max();
        }
        return true;
      }
      // Python slice
      if (PySlice_Check(p)) {
        PySliceObject *r = (PySliceObject*)(p);
        if (m) {
          (**m).start = (r->start == Py_None || PyNumber_AsSsize_t(r->start, NULL) <= std::numeric_limits<int>::min())
            ? std::numeric_limits<casadi_int>::min() : PyInt_AsLong(r->start);
          (**m).stop  = (r->stop ==Py_None || PyNumber_AsSsize_t(r->stop, NULL)>= std::numeric_limits<int>::max())
            ? std::numeric_limits<casadi_int>::max() : PyInt_AsLong(r->stop);
          if(r->step !=Py_None) (**m).step  = PyInt_AsLong(r->step);
        }
        return true;
      }


      // No match
      return false;
    }

    PyObject* from_ptr(const Slice *a) {
      return SWIG_NewPointerObj(new Slice(*a), SWIGTYPE_p_casadi__Slice, SWIG_POINTER_OWN);
    }

  } // namespace casadi


  namespace casadi {
    template<typename M> bool to_ptr(PyObject *p, std::map<std::string, M>** m) {

      if (PyDict_Check(p)) {
        PyObject *key, *value;
        Py_ssize_t pos = 0;
        while (PyDict_Next(p, &pos, &key, &value)) {
          if (!(PyString_Check(key) || PyUnicode_Check(key))) return false;
          if (m) {
            char* c_key = SWIG_Python_str_AsChar(key);
            M *v=&(**m)[std::string(c_key)], *v2=v;
            SWIG_Python_str_DelForPy3(c_key);
            if (!casadi::to_ptr(value, &v)) return false;
            if (v!=v2) *v2=*v; // if only pointer changed
          } else {
            if (!casadi::to_ptr(value, static_cast<M**>(0))) return false;
          }
        }
        return true;
      }
















      return false;
    }

    template<typename M> PyObject* from_ptr(const std::map<std::string, M> *a) {

      PyObject *p = PyDict_New();
      for (typename std::map<std::string, M>::const_iterator it=a->begin(); it!=a->end(); ++it) {
        PyObject * e = from_ptr(&it->second);
        if (!e) {
          Py_DECREF(p);
          return 0;
        }
        PyDict_SetItemString(p, it->first.c_str(), e);
        Py_DECREF(e);
      }
      return p;























    }
  } // namespace casadi


  namespace casadi {





















    template<typename M1, typename M2> bool to_ptr(PyObject *p, std::pair<M1, M2>** m) {

      if (PyTuple_Check(p) && PyTuple_Size(p)==2) {
        PyObject *p_first = PyTuple_GetItem(p, 0);
        PyObject *p_second = PyTuple_GetItem(p, 1);
	return to_val(p_first, m ? &(**m).first : 0)
	  && to_val(p_second, m ? &(**m).second : 0);
      }









      // No match
      return false;
    }












    template<typename M1, typename M2> PyObject* from_ptr(const std::pair<M1, M2>* a) {

      PyObject* ret = PyTuple_New(2);
      PyTuple_SetItem(ret, 0, from_ref(a->first));
      PyTuple_SetItem(ret, 1, from_ref(a->second));
      return ret;









    }
  } // namespace casadi
 

  namespace casadi {
    bool to_ptr(PyObject *p, SX** m) {
      // Treat Null
      if (is_null(p)) return false;

      // SX already?
      if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(m),
                                    SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0))) {
        return true;
      }

      // Try first converting to a temporary DM
      {
        DM tmp;
        if(to_val(p, m? &tmp: 0)) {
          if (m) **m = tmp;
          return true;
        }
      }


      // Numpy arrays will be cast to dense SX
      if (SX_from_array(p, m)) return true;
      // Object has __SX__ method
      if (PyObject_HasAttrString(p,"__SX__")) {
        PyObject *cr = PyObject_CallMethod(p, (char*) "__SX__", 0);
        if (!cr) return false;
        casadi_int flag = to_ptr(cr, m);
        Py_DECREF(cr);
        return flag;
      }


      // No match
      return false;
    }

    PyObject* from_ptr(const SX *a) {
      return SWIG_NewPointerObj(new SX(*a), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_OWN);
    }
  } // namespace casadi
 

  namespace casadi {
    bool to_ptr(PyObject *p, SXElem** m) {
      // Treat Null
      if (is_null(p)) return false;

      // Try first converting to a temporary SX
      {
        SX tmp, *mt=&tmp;
        if(casadi::to_ptr(p, m ? &mt : 0)) {
          if (m && !mt->is_scalar()) return false;
          if (m) **m = mt->scalar();
          return true;
        }
      }

      // No match
      return false;
    }

    PyObject* from_ptr(const SXElem *a) {
      return from_ref(SX(*a));
    }
  } // namespace casadi
 

  namespace casadi {
    bool to_ptr(PyObject *p, MX** m) {
      // Treat Null
      if (is_null(p)) return false;

      // MX already?
      if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(m),
                                    SWIGTYPE_p_casadi__MX, 0))) {
        return true;
      }

      // Try first converting to a temporary DM
      {
        DM tmp;
        if(to_val(p, m ? &tmp : 0)) {
          if (m) **m = tmp;
          return true;
        }
      }


      if (PyObject_HasAttrString(p,"__MX__")) {
        PyObject *cr = PyObject_CallMethod(p, (char*) "__MX__", 0);
        if (!cr) return false;
        casadi_int flag = to_ptr(cr, m);
        Py_DECREF(cr);
        return flag;
      }


      // No match
      return false;
    }

    PyObject* from_ptr(const MX *a) {
      return SWIG_NewPointerObj(new MX(*a), SWIGTYPE_p_casadi__MX, SWIG_POINTER_OWN);
    }
  } // namespace casadi
 

  namespace casadi {

    /** Check PyObjects by class name */
    bool PyObjectHasClassName(PyObject* p, const char * name) {
      PyObject * classo = PyObject_GetAttrString( p, "__class__");
      PyObject * classname = PyObject_GetAttrString( classo, "__name__");

      char* c_classname = SWIG_Python_str_AsChar(classname);
      bool ret = strcmp(c_classname, name)==0;

      Py_DECREF(classo);Py_DECREF(classname);
      SWIG_Python_str_DelForPy3(c_classname);
      return ret;
    }


    bool to_ptr(PyObject *p, DM** m) {
      // Treat Null
      if (is_null(p)) return false;

      // DM already?
      if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(m),
                                    SWIGTYPE_p_casadi__MatrixT_double_t, 0))) {
        return true;
      }

      // Object is a sparsity pattern
      {
        Sparsity *m2;
        if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(&m2),
                                      SWIGTYPE_p_casadi__Sparsity, 0))) {
          if (m) **m=DM::ones(*m2);
          return true;
        }
      }

      // Double scalar
      {
        double tmp;
        if (to_val(p, m? &tmp: 0)) {
          if (m) **m=tmp;
          return true;
        }
      }


      // Object has __DM__ method
      if (PyObject_HasAttrString(p,"__DM__")) {
        char name[] = "__DM__";
        PyObject *cr = PyObject_CallMethod(p, name, 0);
        if (!cr) return false;
        casadi_int result = to_val(cr, m ? *m : 0);
        Py_DECREF(cr);
        return result;
      }

      if (DM_from_array(p, m)) return true;

      if (DM_from_csc(p,m)) return true;

      {
        std::vector <double> t;
        casadi_int res = to_val(p, &t);
        if (t.size()>0) {
          if (m) **m = casadi::Matrix<double>(t);
        } else {
          if (m) **m = casadi::Matrix<double>(0,0);
        }
        return res;
      }













      // No match
      return false;
    }

    PyObject* from_ptr(const DM *a) {
      return SWIG_NewPointerObj(new DM(*a), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_OWN);
    }
  } // namespace casadi


  namespace casadi {
    bool to_ptr(PyObject *p, Sparsity** m) {
      // Treat Null
      if (is_null(p)) return false;

      // Sparsity already?
      if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(m),
                                    SWIGTYPE_p_casadi__Sparsity, 0))) {
        return true;
      }

      // No match
      return false;
    }

    PyObject* from_ptr(const Sparsity *a) {
      return SWIG_NewPointerObj(new Sparsity(*a), SWIGTYPE_p_casadi__Sparsity, SWIG_POINTER_OWN);
    }
  } // namespace casadi


  namespace casadi {
    bool to_ptr(PyObject *p, IM** m) {
      // Treat Null
      if (is_null(p)) return false;

      // Object is a sparsity pattern
      {
        Sparsity *m2;
        if (SWIG_IsOK(SWIG_ConvertPtr(p, reinterpret_cast<void**>(&m2),
                                      SWIGTYPE_p_casadi__Sparsity, 0))) {
          if (m) **m=IM::ones(*m2);
          return true;
        }
      }

      // First convert to integer
      {
        casadi_int tmp;
        if (to_val(p, m? &tmp: 0)) {
          if (m) **m=tmp;
          return true;
        }
      }


      // Numpy arrays will be cast to dense Matrix<casadi_int>
      if (IM_from_array(p, m)) return true;

      if (PyObject_HasAttrString(p,"__IM__")) {
        PyObject *cr = PyObject_CallMethod(p, (char*) "__IM__", 0);
        if (!cr) return false;
        casadi_int result = to_val(cr, m ? *m : 0);
        Py_DECREF(cr);
        return result;
      }

      {
        std::vector <casadi_int> t;
        if (to_val(p, &t)) {
          if (m) **m = casadi::Matrix<casadi_int>(t);
          return true;
        }
      }






























      // Convert from DM
      {
        DM tmp;
        if (to_val(p, m? &tmp: 0)) {
          // Check integrality
          for (double d : tmp.nonzeros()) {
            if (d!=casadi_int(d)) return false;
          }
          // Convert
          if (m) {
            **m = casadi::Matrix<double>(tmp);
          }
          return true;
        }
      }

      // No match
      return false;
    }
    PyObject* from_ptr(const IM *a) {
      DM tmp(*a);
      return from_ref(tmp);
    }

  } // namespace casadi
 
 

SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast< long >(value));
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLongLong(value) : PyInt_FromLong(static_cast< long >(value));
}
#endif


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  (static_cast< unsigned long long >(value));
  }
#endif
}

SWIGINTERN void casadi_Matrix_Sl_double_Sg__assign(casadi::Matrix< double > *self,casadi::Matrix< double > const &rhs){ (*self)=rhs; }
SWIGINTERN PyObject *casadi_Matrix_Sl_double_Sg__full(casadi::Matrix< double > const *self){
      return full(*self);
    }
SWIGINTERN PyObject *casadi_Matrix_Sl_double_Sg__sparse(casadi::Matrix< double > const *self){
      return sparse(*self);
    }

  namespace casadi {
    /*@SWIG:swig/casadi.i,2984,SPARSITY_INTERFACE_ALL@*/
/*@SWIG:swig/casadi.i,3001,SPARSITY_INTERFACE_FUN@*/
    /*@SWIG:swig/casadi.i,2868,SPARSITY_INTERFACE_FUN_BASE@*/


 inline Sparsity casadi_horzcat(const std::vector< Sparsity > &v) {
  return horzcat(v);
 }
 inline Sparsity casadi_vertcat(const std::vector< Sparsity > &v) {
 return vertcat(v);
 }
 inline std::vector< Sparsity >
 casadi_horzsplit(const Sparsity& v, const std::vector<casadi_int>& offset) {
 return horzsplit(v, offset);
 }
 inline std::vector< Sparsity > casadi_horzsplit(const Sparsity& v, casadi_int incr=1) {
 return horzsplit(v, incr);
 }
 inline std::vector< Sparsity >
 casadi_vertsplit(const Sparsity& v, const std::vector<casadi_int>& offset) {
 return vertsplit(v, offset);
 }
 inline std::vector<casadi_int >
 casadi_offset(const std::vector< Sparsity > &v, bool vert=true) {
 return offset(v, vert);
 }
 inline std::vector< Sparsity >
 casadi_vertsplit(const Sparsity& v, casadi_int incr=1) {
 return vertsplit(v, incr);
 }
 inline Sparsity casadi_blockcat(const Sparsity& A, const Sparsity& B, const Sparsity& C, const Sparsity& D) {
 return vertcat(horzcat(A, B), horzcat(C, D));
 }
 inline std::vector< std::vector< Sparsity > >
 casadi_blocksplit(const Sparsity& x, const std::vector<casadi_int>& vert_offset,
 const std::vector<casadi_int>& horz_offset) {
 return blocksplit(x, vert_offset, horz_offset);
 }
 inline std::vector< std::vector< Sparsity > >
 casadi_blocksplit(const Sparsity& x, casadi_int vert_incr=1, casadi_int horz_incr=1) {
 return blocksplit(x, vert_incr, horz_incr);
 }
 inline Sparsity casadi_diagcat(const std::vector< Sparsity > &A) {
 return diagcat(A);
 }
 inline std::vector< Sparsity >
 casadi_diagsplit(const Sparsity& x, const std::vector<casadi_int>& output_offset1,
 const std::vector<casadi_int>& output_offset2) {
 return diagsplit(x, output_offset1, output_offset2);
 }
 inline std::vector< Sparsity >
 casadi_diagsplit(const Sparsity& x, const std::vector<casadi_int>& output_offset) {
 return diagsplit(x, output_offset);
 }
 inline std::vector< Sparsity > casadi_diagsplit(const Sparsity& x, casadi_int incr=1) {
 return diagsplit(x, incr);
 }
 inline std::vector< Sparsity >
 casadi_diagsplit(const Sparsity& x, casadi_int incr1, casadi_int incr2) {
 return diagsplit(x, incr1, incr2);
 }
 inline Sparsity casadi_veccat(const std::vector< Sparsity >& x) {
 return veccat(x);
 }
 inline Sparsity casadi_mtimes(const Sparsity& x, const Sparsity& y) {
 return mtimes(x, y);
 }
 inline Sparsity casadi_mtimes(const std::vector< Sparsity > &args) {
 return mtimes(args);
 }
 inline Sparsity casadi_mac(const Sparsity& X, const Sparsity& Y, const Sparsity& Z) {
 return mac(X, Y, Z);
 }
 inline Sparsity casadi_transpose(const Sparsity& X) {
 return X.T();
 }
 inline Sparsity casadi_vec(const Sparsity& a) {
 return vec(a);
 }
 inline Sparsity casadi_reshape(const Sparsity& a, casadi_int nrow, casadi_int ncol) {
 return reshape(a, nrow, ncol);
 }
 inline Sparsity casadi_reshape(const Sparsity& a, std::pair<casadi_int, casadi_int> rc) {
 return reshape(a, rc.first, rc.second);
 }
 inline Sparsity casadi_reshape(const Sparsity& a, const Sparsity& sp) {
 return reshape(a, sp);
 }
 inline casadi_int casadi_sprank(const Sparsity& A) {
 return sprank(A);
 }
 inline casadi_int casadi_norm_0_mul(const Sparsity& x, const Sparsity& y) {
 return norm_0_mul(x, y);
 }
 inline Sparsity casadi_triu(const Sparsity& a, bool includeDiagonal=true) {
 return triu(a, includeDiagonal);
 }
 inline Sparsity casadi_tril(const Sparsity& a, bool includeDiagonal=true) {
 return tril(a, includeDiagonal);
 }
 inline Sparsity casadi_kron(const Sparsity& a, const Sparsity& b) {
 return kron(a, b);
 }
 inline Sparsity casadi_repmat(const Sparsity& A, casadi_int n, casadi_int m=1) {
 return repmat(A, n, m);
 }
 inline Sparsity casadi_repmat(const Sparsity& A, const std::pair<casadi_int, casadi_int>& rc) {
 return repmat(A, rc.first, rc.second);
 }
 inline Sparsity casadi_sum2(const Sparsity& x) {
 return sum2(x);
 }
 inline Sparsity casadi_sum1(const Sparsity& x) {
 return sum1(x);
 }

/*@SWIG@*/
  /*@SWIG@*/
/*@SWIG:swig/casadi.i,3001,SPARSITY_INTERFACE_FUN@*/
    /*@SWIG:swig/casadi.i,2868,SPARSITY_INTERFACE_FUN_BASE@*/


 inline MX casadi_horzcat(const std::vector< MX > &v) {
  return horzcat(v);
 }
 inline MX casadi_vertcat(const std::vector< MX > &v) {
 return vertcat(v);
 }
 inline std::vector< MX >
 casadi_horzsplit(const MX& v, const std::vector<casadi_int>& offset) {
 return horzsplit(v, offset);
 }
 inline std::vector< MX > casadi_horzsplit(const MX& v, casadi_int incr=1) {
 return horzsplit(v, incr);
 }
 inline std::vector< MX >
 casadi_vertsplit(const MX& v, const std::vector<casadi_int>& offset) {
 return vertsplit(v, offset);
 }
 inline std::vector<casadi_int >
 casadi_offset(const std::vector< MX > &v, bool vert=true) {
 return offset(v, vert);
 }
 inline std::vector< MX >
 casadi_vertsplit(const MX& v, casadi_int incr=1) {
 return vertsplit(v, incr);
 }
 inline MX casadi_blockcat(const MX& A, const MX& B, const MX& C, const MX& D) {
 return vertcat(horzcat(A, B), horzcat(C, D));
 }
 inline std::vector< std::vector< MX > >
 casadi_blocksplit(const MX& x, const std::vector<casadi_int>& vert_offset,
 const std::vector<casadi_int>& horz_offset) {
 return blocksplit(x, vert_offset, horz_offset);
 }
 inline std::vector< std::vector< MX > >
 casadi_blocksplit(const MX& x, casadi_int vert_incr=1, casadi_int horz_incr=1) {
 return blocksplit(x, vert_incr, horz_incr);
 }
 inline MX casadi_diagcat(const std::vector< MX > &A) {
 return diagcat(A);
 }
 inline std::vector< MX >
 casadi_diagsplit(const MX& x, const std::vector<casadi_int>& output_offset1,
 const std::vector<casadi_int>& output_offset2) {
 return diagsplit(x, output_offset1, output_offset2);
 }
 inline std::vector< MX >
 casadi_diagsplit(const MX& x, const std::vector<casadi_int>& output_offset) {
 return diagsplit(x, output_offset);
 }
 inline std::vector< MX > casadi_diagsplit(const MX& x, casadi_int incr=1) {
 return diagsplit(x, incr);
 }
 inline std::vector< MX >
 casadi_diagsplit(const MX& x, casadi_int incr1, casadi_int incr2) {
 return diagsplit(x, incr1, incr2);
 }
 inline MX casadi_veccat(const std::vector< MX >& x) {
 return veccat(x);
 }
 inline MX casadi_mtimes(const MX& x, const MX& y) {
 return mtimes(x, y);
 }
 inline MX casadi_mtimes(const std::vector< MX > &args) {
 return mtimes(args);
 }
 inline MX casadi_mac(const MX& X, const MX& Y, const MX& Z) {
 return mac(X, Y, Z);
 }
 inline MX casadi_transpose(const MX& X) {
 return X.T();
 }
 inline MX casadi_vec(const MX& a) {
 return vec(a);
 }
 inline MX casadi_reshape(const MX& a, casadi_int nrow, casadi_int ncol) {
 return reshape(a, nrow, ncol);
 }
 inline MX casadi_reshape(const MX& a, std::pair<casadi_int, casadi_int> rc) {
 return reshape(a, rc.first, rc.second);
 }
 inline MX casadi_reshape(const MX& a, const Sparsity& sp) {
 return reshape(a, sp);
 }
 inline casadi_int casadi_sprank(const MX& A) {
 return sprank(A);
 }
 inline casadi_int casadi_norm_0_mul(const MX& x, const MX& y) {
 return norm_0_mul(x, y);
 }
 inline MX casadi_triu(const MX& a, bool includeDiagonal=true) {
 return triu(a, includeDiagonal);
 }
 inline MX casadi_tril(const MX& a, bool includeDiagonal=true) {
 return tril(a, includeDiagonal);
 }
 inline MX casadi_kron(const MX& a, const MX& b) {
 return kron(a, b);
 }
 inline MX casadi_repmat(const MX& A, casadi_int n, casadi_int m=1) {
 return repmat(A, n, m);
 }
 inline MX casadi_repmat(const MX& A, const std::pair<casadi_int, casadi_int>& rc) {
 return repmat(A, rc.first, rc.second);
 }
 inline MX casadi_sum2(const MX& x) {
 return sum2(x);
 }
 inline MX casadi_sum1(const MX& x) {
 return sum1(x);
 }

/*@SWIG@*/
  /*@SWIG@*/
/*@SWIG:swig/casadi.i,3001,SPARSITY_INTERFACE_FUN@*/
    /*@SWIG:swig/casadi.i,2868,SPARSITY_INTERFACE_FUN_BASE@*/


 inline Matrix<double> casadi_horzcat(const std::vector< Matrix<double> > &v) {
  return horzcat(v);
 }
 inline Matrix<double> casadi_vertcat(const std::vector< Matrix<double> > &v) {
 return vertcat(v);
 }
 inline std::vector< Matrix<double> >
 casadi_horzsplit(const Matrix<double>& v, const std::vector<casadi_int>& offset) {
 return horzsplit(v, offset);
 }
 inline std::vector< Matrix<double> > casadi_horzsplit(const Matrix<double>& v, casadi_int incr=1) {
 return horzsplit(v, incr);
 }
 inline std::vector< Matrix<double> >
 casadi_vertsplit(const Matrix<double>& v, const std::vector<casadi_int>& offset) {
 return vertsplit(v, offset);
 }
 inline std::vector<casadi_int >
 casadi_offset(const std::vector< Matrix<double> > &v, bool vert=true) {
 return offset(v, vert);
 }
 inline std::vector< Matrix<double> >
 casadi_vertsplit(const Matrix<double>& v, casadi_int incr=1) {
 return vertsplit(v, incr);
 }
 inline Matrix<double> casadi_blockcat(const Matrix<double>& A, const Matrix<double>& B, const Matrix<double>& C, const Matrix<double>& D) {
 return vertcat(horzcat(A, B), horzcat(C, D));
 }
 inline std::vector< std::vector< Matrix<double> > >
 casadi_blocksplit(const Matrix<double>& x, const std::vector<casadi_int>& vert_offset,
 const std::vector<casadi_int>& horz_offset) {
 return blocksplit(x, vert_offset, horz_offset);
 }
 inline std::vector< std::vector< Matrix<double> > >
 casadi_blocksplit(const Matrix<double>& x, casadi_int vert_incr=1, casadi_int horz_incr=1) {
 return blocksplit(x, vert_incr, horz_incr);
 }
 inline Matrix<double> casadi_diagcat(const std::vector< Matrix<double> > &A) {
 return diagcat(A);
 }
 inline std::vector< Matrix<double> >
 casadi_diagsplit(const Matrix<double>& x, const std::vector<casadi_int>& output_offset1,
 const std::vector<casadi_int>& output_offset2) {
 return diagsplit(x, output_offset1, output_offset2);
 }
 inline std::vector< Matrix<double> >
 casadi_diagsplit(const Matrix<double>& x, const std::vector<casadi_int>& output_offset) {
 return diagsplit(x, output_offset);
 }
 inline std::vector< Matrix<double> > casadi_diagsplit(const Matrix<double>& x, casadi_int incr=1) {
 return diagsplit(x, incr);
 }
 inline std::vector< Matrix<double> >
 casadi_diagsplit(const Matrix<double>& x, casadi_int incr1, casadi_int incr2) {
 return diagsplit(x, incr1, incr2);
 }
 inline Matrix<double> casadi_veccat(const std::vector< Matrix<double> >& x) {
 return veccat(x);
 }
 inline Matrix<double> casadi_mtimes(const Matrix<double>& x, const Matrix<double>& y) {
 return mtimes(x, y);
 }
 inline Matrix<double> casadi_mtimes(const std::vector< Matrix<double> > &args) {
 return mtimes(args);
 }
 inline Matrix<double> casadi_mac(const Matrix<double>& X, const Matrix<double>& Y, const Matrix<double>& Z) {
 return mac(X, Y, Z);
 }
 inline Matrix<double> casadi_transpose(const Matrix<double>& X) {
 return X.T();
 }
 inline Matrix<double> casadi_vec(const Matrix<double>& a) {
 return vec(a);
 }
 inline Matrix<double> casadi_reshape(const Matrix<double>& a, casadi_int nrow, casadi_int ncol) {
 return reshape(a, nrow, ncol);
 }
 inline Matrix<double> casadi_reshape(const Matrix<double>& a, std::pair<casadi_int, casadi_int> rc) {
 return reshape(a, rc.first, rc.second);
 }
 inline Matrix<double> casadi_reshape(const Matrix<double>& a, const Sparsity& sp) {
 return reshape(a, sp);
 }
 inline casadi_int casadi_sprank(const Matrix<double>& A) {
 return sprank(A);
 }
 inline casadi_int casadi_norm_0_mul(const Matrix<double>& x, const Matrix<double>& y) {
 return norm_0_mul(x, y);
 }
 inline Matrix<double> casadi_triu(const Matrix<double>& a, bool includeDiagonal=true) {
 return triu(a, includeDiagonal);
 }
 inline Matrix<double> casadi_tril(const Matrix<double>& a, bool includeDiagonal=true) {
 return tril(a, includeDiagonal);
 }
 inline Matrix<double> casadi_kron(const Matrix<double>& a, const Matrix<double>& b) {
 return kron(a, b);
 }
 inline Matrix<double> casadi_repmat(const Matrix<double>& A, casadi_int n, casadi_int m=1) {
 return repmat(A, n, m);
 }
 inline Matrix<double> casadi_repmat(const Matrix<double>& A, const std::pair<casadi_int, casadi_int>& rc) {
 return repmat(A, rc.first, rc.second);
 }
 inline Matrix<double> casadi_sum2(const Matrix<double>& x) {
 return sum2(x);
 }
 inline Matrix<double> casadi_sum1(const Matrix<double>& x) {
 return sum1(x);
 }

/*@SWIG@*/
  /*@SWIG@*/
/*@SWIG:swig/casadi.i,3001,SPARSITY_INTERFACE_FUN@*/
    /*@SWIG:swig/casadi.i,2868,SPARSITY_INTERFACE_FUN_BASE@*/


 inline Matrix<SXElem> casadi_horzcat(const std::vector< Matrix<SXElem> > &v) {
  return horzcat(v);
 }
 inline Matrix<SXElem> casadi_vertcat(const std::vector< Matrix<SXElem> > &v) {
 return vertcat(v);
 }
 inline std::vector< Matrix<SXElem> >
 casadi_horzsplit(const Matrix<SXElem>& v, const std::vector<casadi_int>& offset) {
 return horzsplit(v, offset);
 }
 inline std::vector< Matrix<SXElem> > casadi_horzsplit(const Matrix<SXElem>& v, casadi_int incr=1) {
 return horzsplit(v, incr);
 }
 inline std::vector< Matrix<SXElem> >
 casadi_vertsplit(const Matrix<SXElem>& v, const std::vector<casadi_int>& offset) {
 return vertsplit(v, offset);
 }
 inline std::vector<casadi_int >
 casadi_offset(const std::vector< Matrix<SXElem> > &v, bool vert=true) {
 return offset(v, vert);
 }
 inline std::vector< Matrix<SXElem> >
 casadi_vertsplit(const Matrix<SXElem>& v, casadi_int incr=1) {
 return vertsplit(v, incr);
 }
 inline Matrix<SXElem> casadi_blockcat(const Matrix<SXElem>& A, const Matrix<SXElem>& B, const Matrix<SXElem>& C, const Matrix<SXElem>& D) {
 return vertcat(horzcat(A, B), horzcat(C, D));
 }
 inline std::vector< std::vector< Matrix<SXElem> > >
 casadi_blocksplit(const Matrix<SXElem>& x, const std::vector<casadi_int>& vert_offset,
 const std::vector<casadi_int>& horz_offset) {
 return blocksplit(x, vert_offset, horz_offset);
 }
 inline std::vector< std::vector< Matrix<SXElem> > >
 casadi_blocksplit(const Matrix<SXElem>& x, casadi_int vert_incr=1, casadi_int horz_incr=1) {
 return blocksplit(x, vert_incr, horz_incr);
 }
 inline Matrix<SXElem> casadi_diagcat(const std::vector< Matrix<SXElem> > &A) {
 return diagcat(A);
 }
 inline std::vector< Matrix<SXElem> >
 casadi_diagsplit(const Matrix<SXElem>& x, const std::vector<casadi_int>& output_offset1,
 const std::vector<casadi_int>& output_offset2) {
 return diagsplit(x, output_offset1, output_offset2);
 }
 inline std::vector< Matrix<SXElem> >
 casadi_diagsplit(const Matrix<SXElem>& x, const std::vector<casadi_int>& output_offset) {
 return diagsplit(x, output_offset);
 }
 inline std::vector< Matrix<SXElem> > casadi_diagsplit(const Matrix<SXElem>& x, casadi_int incr=1) {
 return diagsplit(x, incr);
 }
 inline std::vector< Matrix<SXElem> >
 casadi_diagsplit(const Matrix<SXElem>& x, casadi_int incr1, casadi_int incr2) {
 return diagsplit(x, incr1, incr2);
 }
 inline Matrix<SXElem> casadi_veccat(const std::vector< Matrix<SXElem> >& x) {
 return veccat(x);
 }
 inline Matrix<SXElem> casadi_mtimes(const Matrix<SXElem>& x, const Matrix<SXElem>& y) {
 return mtimes(x, y);
 }
 inline Matrix<SXElem> casadi_mtimes(const std::vector< Matrix<SXElem> > &args) {
 return mtimes(args);
 }
 inline Matrix<SXElem> casadi_mac(const Matrix<SXElem>& X, const Matrix<SXElem>& Y, const Matrix<SXElem>& Z) {
 return mac(X, Y, Z);
 }
 inline Matrix<SXElem> casadi_transpose(const Matrix<SXElem>& X) {
 return X.T();
 }
 inline Matrix<SXElem> casadi_vec(const Matrix<SXElem>& a) {
 return vec(a);
 }
 inline Matrix<SXElem> casadi_reshape(const Matrix<SXElem>& a, casadi_int nrow, casadi_int ncol) {
 return reshape(a, nrow, ncol);
 }
 inline Matrix<SXElem> casadi_reshape(const Matrix<SXElem>& a, std::pair<casadi_int, casadi_int> rc) {
 return reshape(a, rc.first, rc.second);
 }
 inline Matrix<SXElem> casadi_reshape(const Matrix<SXElem>& a, const Sparsity& sp) {
 return reshape(a, sp);
 }
 inline casadi_int casadi_sprank(const Matrix<SXElem>& A) {
 return sprank(A);
 }
 inline casadi_int casadi_norm_0_mul(const Matrix<SXElem>& x, const Matrix<SXElem>& y) {
 return norm_0_mul(x, y);
 }
 inline Matrix<SXElem> casadi_triu(const Matrix<SXElem>& a, bool includeDiagonal=true) {
 return triu(a, includeDiagonal);
 }
 inline Matrix<SXElem> casadi_tril(const Matrix<SXElem>& a, bool includeDiagonal=true) {
 return tril(a, includeDiagonal);
 }
 inline Matrix<SXElem> casadi_kron(const Matrix<SXElem>& a, const Matrix<SXElem>& b) {
 return kron(a, b);
 }
 inline Matrix<SXElem> casadi_repmat(const Matrix<SXElem>& A, casadi_int n, casadi_int m=1) {
 return repmat(A, n, m);
 }
 inline Matrix<SXElem> casadi_repmat(const Matrix<SXElem>& A, const std::pair<casadi_int, casadi_int>& rc) {
 return repmat(A, rc.first, rc.second);
 }
 inline Matrix<SXElem> casadi_sum2(const Matrix<SXElem>& x) {
 return sum2(x);
 }
 inline Matrix<SXElem> casadi_sum1(const Matrix<SXElem>& x) {
 return sum1(x);
 }

/*@SWIG@*/
  /*@SWIG@*/
/*@SWIG@*/
    /*@SWIG:swig/casadi.i,3357,GENERIC_EXPRESSION_ALL@*/
/*@SWIG:swig/casadi.i,3306,GENERIC_EXPRESSION_FUN@*/

inline MX casadi_plus(const MX& x, const MX& y) { return x+y; }
inline MX casadi_minus(const MX& x, const MX& y) { return x-y; }
inline MX casadi_times(const MX& x, const MX& y) { return x*y; }
inline MX casadi_rdivide(const MX& x, const MX& y) { return x/y; }
inline MX casadi_ldivide(const MX& x, const MX& y) { return y/x; }
inline MX casadi_lt(const MX& x, const MX& y) { return x<y; }
inline MX casadi_le(const MX& x, const MX& y) { return x<=y; }
inline MX casadi_gt(const MX& x, const MX& y) { return x>y; }
inline MX casadi_ge(const MX& x, const MX& y) { return x>=y; }
inline MX casadi_eq(const MX& x, const MX& y) { return x==y; }
inline MX casadi_ne(const MX& x, const MX& y) { return x!=y; }
inline MX casadi_and(const MX& x, const MX& y) { return x&&y; }
inline MX casadi_or(const MX& x, const MX& y) { return x||y; }
inline MX casadi_not(const MX& x) { return !x; }
inline MX casadi_abs(const MX& x) { return fabs(x); }
inline MX casadi_sqrt(const MX& x) { return sqrt(x); }
inline MX casadi_sin(const MX& x) { return sin(x); }
inline MX casadi_cos(const MX& x) { return cos(x); }
inline MX casadi_tan(const MX& x) { return tan(x); }
inline MX casadi_atan(const MX& x) { return atan(x); }
inline MX casadi_asin(const MX& x) { return asin(x); }
inline MX casadi_acos(const MX& x) { return acos(x); }
inline MX casadi_tanh(const MX& x) { return tanh(x); }
inline MX casadi_sinh(const MX& x) { return sinh(x); }
inline MX casadi_cosh(const MX& x) { return cosh(x); }
inline MX casadi_atanh(const MX& x) { return atanh(x); }
inline MX casadi_asinh(const MX& x) { return asinh(x); }
inline MX casadi_acosh(const MX& x) { return acosh(x); }
inline MX casadi_exp(const MX& x) { return exp(x); }
inline MX casadi_log(const MX& x) { return log(x); }
inline MX casadi_log10(const MX& x) { return log10(x); }
inline MX casadi_floor(const MX& x) { return floor(x); }
inline MX casadi_ceil(const MX& x) { return ceil(x); }
inline MX casadi_erf(const MX& x) { return erf(x); }
inline MX casadi_erfinv(const MX& x) { using casadi::erfinv; return erfinv(x); }
inline MX casadi_sign(const MX& x) { using casadi::sign; return sign(x); }
inline MX casadi_power(const MX& x, const MX& n) { return pow(x, n); }
inline MX casadi_mod(const MX& x, const MX& y) { return fmod(x, y); }
inline MX casadi_fmod(const MX& x, const MX& y) { return fmod(x, y); }
inline MX casadi_atan2(const MX& x, const MX& y) { return atan2(x, y); }
inline MX casadi_fmin(const MX& x, const MX& y) { return fmin(x, y); }
inline MX casadi_fmax(const MX& x, const MX& y) { return fmax(x, y); }
inline MX casadi_simplify(const MX& x) { using casadi::simplify; return simplify(x); }
inline bool casadi_is_equal(const MX& x, const MX& y, casadi_int depth=0) { using casadi::is_equal; return is_equal(x, y, depth); }
inline MX casadi_copysign(const MX& x, const MX& y) { return copysign(x, y); }
inline MX casadi_constpow(const MX& x, const MX& y) { using casadi::constpow; return constpow(x, y); }

/*@SWIG@*/
/*@SWIG:swig/casadi.i,3306,GENERIC_EXPRESSION_FUN@*/

inline Matrix<double> casadi_plus(const Matrix<double>& x, const Matrix<double>& y) { return x+y; }
inline Matrix<double> casadi_minus(const Matrix<double>& x, const Matrix<double>& y) { return x-y; }
inline Matrix<double> casadi_times(const Matrix<double>& x, const Matrix<double>& y) { return x*y; }
inline Matrix<double> casadi_rdivide(const Matrix<double>& x, const Matrix<double>& y) { return x/y; }
inline Matrix<double> casadi_ldivide(const Matrix<double>& x, const Matrix<double>& y) { return y/x; }
inline Matrix<double> casadi_lt(const Matrix<double>& x, const Matrix<double>& y) { return x<y; }
inline Matrix<double> casadi_le(const Matrix<double>& x, const Matrix<double>& y) { return x<=y; }
inline Matrix<double> casadi_gt(const Matrix<double>& x, const Matrix<double>& y) { return x>y; }
inline Matrix<double> casadi_ge(const Matrix<double>& x, const Matrix<double>& y) { return x>=y; }
inline Matrix<double> casadi_eq(const Matrix<double>& x, const Matrix<double>& y) { return x==y; }
inline Matrix<double> casadi_ne(const Matrix<double>& x, const Matrix<double>& y) { return x!=y; }
inline Matrix<double> casadi_and(const Matrix<double>& x, const Matrix<double>& y) { return x&&y; }
inline Matrix<double> casadi_or(const Matrix<double>& x, const Matrix<double>& y) { return x||y; }
inline Matrix<double> casadi_not(const Matrix<double>& x) { return !x; }
inline Matrix<double> casadi_abs(const Matrix<double>& x) { return fabs(x); }
inline Matrix<double> casadi_sqrt(const Matrix<double>& x) { return sqrt(x); }
inline Matrix<double> casadi_sin(const Matrix<double>& x) { return sin(x); }
inline Matrix<double> casadi_cos(const Matrix<double>& x) { return cos(x); }
inline Matrix<double> casadi_tan(const Matrix<double>& x) { return tan(x); }
inline Matrix<double> casadi_atan(const Matrix<double>& x) { return atan(x); }
inline Matrix<double> casadi_asin(const Matrix<double>& x) { return asin(x); }
inline Matrix<double> casadi_acos(const Matrix<double>& x) { return acos(x); }
inline Matrix<double> casadi_tanh(const Matrix<double>& x) { return tanh(x); }
inline Matrix<double> casadi_sinh(const Matrix<double>& x) { return sinh(x); }
inline Matrix<double> casadi_cosh(const Matrix<double>& x) { return cosh(x); }
inline Matrix<double> casadi_atanh(const Matrix<double>& x) { return atanh(x); }
inline Matrix<double> casadi_asinh(const Matrix<double>& x) { return asinh(x); }
inline Matrix<double> casadi_acosh(const Matrix<double>& x) { return acosh(x); }
inline Matrix<double> casadi_exp(const Matrix<double>& x) { return exp(x); }
inline Matrix<double> casadi_log(const Matrix<double>& x) { return log(x); }
inline Matrix<double> casadi_log10(const Matrix<double>& x) { return log10(x); }
inline Matrix<double> casadi_floor(const Matrix<double>& x) { return floor(x); }
inline Matrix<double> casadi_ceil(const Matrix<double>& x) { return ceil(x); }
inline Matrix<double> casadi_erf(const Matrix<double>& x) { return erf(x); }
inline Matrix<double> casadi_erfinv(const Matrix<double>& x) { using casadi::erfinv; return erfinv(x); }
inline Matrix<double> casadi_sign(const Matrix<double>& x) { using casadi::sign; return sign(x); }
inline Matrix<double> casadi_power(const Matrix<double>& x, const Matrix<double>& n) { return pow(x, n); }
inline Matrix<double> casadi_mod(const Matrix<double>& x, const Matrix<double>& y) { return fmod(x, y); }
inline Matrix<double> casadi_fmod(const Matrix<double>& x, const Matrix<double>& y) { return fmod(x, y); }
inline Matrix<double> casadi_atan2(const Matrix<double>& x, const Matrix<double>& y) { return atan2(x, y); }
inline Matrix<double> casadi_fmin(const Matrix<double>& x, const Matrix<double>& y) { return fmin(x, y); }
inline Matrix<double> casadi_fmax(const Matrix<double>& x, const Matrix<double>& y) { return fmax(x, y); }
inline Matrix<double> casadi_simplify(const Matrix<double>& x) { using casadi::simplify; return simplify(x); }
inline bool casadi_is_equal(const Matrix<double>& x, const Matrix<double>& y, casadi_int depth=0) { using casadi::is_equal; return is_equal(x, y, depth); }
inline Matrix<double> casadi_copysign(const Matrix<double>& x, const Matrix<double>& y) { return copysign(x, y); }
inline Matrix<double> casadi_constpow(const Matrix<double>& x, const Matrix<double>& y) { using casadi::constpow; return constpow(x, y); }

/*@SWIG@*/
/*@SWIG:swig/casadi.i,3306,GENERIC_EXPRESSION_FUN@*/

inline Matrix<SXElem> casadi_plus(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x+y; }
inline Matrix<SXElem> casadi_minus(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x-y; }
inline Matrix<SXElem> casadi_times(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x*y; }
inline Matrix<SXElem> casadi_rdivide(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x/y; }
inline Matrix<SXElem> casadi_ldivide(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return y/x; }
inline Matrix<SXElem> casadi_lt(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x<y; }
inline Matrix<SXElem> casadi_le(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x<=y; }
inline Matrix<SXElem> casadi_gt(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x>y; }
inline Matrix<SXElem> casadi_ge(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x>=y; }
inline Matrix<SXElem> casadi_eq(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x==y; }
inline Matrix<SXElem> casadi_ne(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x!=y; }
inline Matrix<SXElem> casadi_and(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x&&y; }
inline Matrix<SXElem> casadi_or(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return x||y; }
inline Matrix<SXElem> casadi_not(const Matrix<SXElem>& x) { return !x; }
inline Matrix<SXElem> casadi_abs(const Matrix<SXElem>& x) { return fabs(x); }
inline Matrix<SXElem> casadi_sqrt(const Matrix<SXElem>& x) { return sqrt(x); }
inline Matrix<SXElem> casadi_sin(const Matrix<SXElem>& x) { return sin(x); }
inline Matrix<SXElem> casadi_cos(const Matrix<SXElem>& x) { return cos(x); }
inline Matrix<SXElem> casadi_tan(const Matrix<SXElem>& x) { return tan(x); }
inline Matrix<SXElem> casadi_atan(const Matrix<SXElem>& x) { return atan(x); }
inline Matrix<SXElem> casadi_asin(const Matrix<SXElem>& x) { return asin(x); }
inline Matrix<SXElem> casadi_acos(const Matrix<SXElem>& x) { return acos(x); }
inline Matrix<SXElem> casadi_tanh(const Matrix<SXElem>& x) { return tanh(x); }
inline Matrix<SXElem> casadi_sinh(const Matrix<SXElem>& x) { return sinh(x); }
inline Matrix<SXElem> casadi_cosh(const Matrix<SXElem>& x) { return cosh(x); }
inline Matrix<SXElem> casadi_atanh(const Matrix<SXElem>& x) { return atanh(x); }
inline Matrix<SXElem> casadi_asinh(const Matrix<SXElem>& x) { return asinh(x); }
inline Matrix<SXElem> casadi_acosh(const Matrix<SXElem>& x) { return acosh(x); }
inline Matrix<SXElem> casadi_exp(const Matrix<SXElem>& x) { return exp(x); }
inline Matrix<SXElem> casadi_log(const Matrix<SXElem>& x) { return log(x); }
inline Matrix<SXElem> casadi_log10(const Matrix<SXElem>& x) { return log10(x); }
inline Matrix<SXElem> casadi_floor(const Matrix<SXElem>& x) { return floor(x); }
inline Matrix<SXElem> casadi_ceil(const Matrix<SXElem>& x) { return ceil(x); }
inline Matrix<SXElem> casadi_erf(const Matrix<SXElem>& x) { return erf(x); }
inline Matrix<SXElem> casadi_erfinv(const Matrix<SXElem>& x) { using casadi::erfinv; return erfinv(x); }
inline Matrix<SXElem> casadi_sign(const Matrix<SXElem>& x) { using casadi::sign; return sign(x); }
inline Matrix<SXElem> casadi_power(const Matrix<SXElem>& x, const Matrix<SXElem>& n) { return pow(x, n); }
inline Matrix<SXElem> casadi_mod(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return fmod(x, y); }
inline Matrix<SXElem> casadi_fmod(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return fmod(x, y); }
inline Matrix<SXElem> casadi_atan2(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return atan2(x, y); }
inline Matrix<SXElem> casadi_fmin(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return fmin(x, y); }
inline Matrix<SXElem> casadi_fmax(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return fmax(x, y); }
inline Matrix<SXElem> casadi_simplify(const Matrix<SXElem>& x) { using casadi::simplify; return simplify(x); }
inline bool casadi_is_equal(const Matrix<SXElem>& x, const Matrix<SXElem>& y, casadi_int depth=0) { using casadi::is_equal; return is_equal(x, y, depth); }
inline Matrix<SXElem> casadi_copysign(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { return copysign(x, y); }
inline Matrix<SXElem> casadi_constpow(const Matrix<SXElem>& x, const Matrix<SXElem>& y) { using casadi::constpow; return constpow(x, y); }

/*@SWIG@*/
/*@SWIG:swig/casadi.i,3306,GENERIC_EXPRESSION_FUN@*/

inline double casadi_plus(const double& x, const double& y) { return x+y; }
inline double casadi_minus(const double& x, const double& y) { return x-y; }
inline double casadi_times(const double& x, const double& y) { return x*y; }
inline double casadi_rdivide(const double& x, const double& y) { return x/y; }
inline double casadi_ldivide(const double& x, const double& y) { return y/x; }
inline double casadi_lt(const double& x, const double& y) { return x<y; }
inline double casadi_le(const double& x, const double& y) { return x<=y; }
inline double casadi_gt(const double& x, const double& y) { return x>y; }
inline double casadi_ge(const double& x, const double& y) { return x>=y; }
inline double casadi_eq(const double& x, const double& y) { return x==y; }
inline double casadi_ne(const double& x, const double& y) { return x!=y; }
inline double casadi_and(const double& x, const double& y) { return x&&y; }
inline double casadi_or(const double& x, const double& y) { return x||y; }
inline double casadi_not(const double& x) { return !x; }
inline double casadi_abs(const double& x) { return fabs(x); }
inline double casadi_sqrt(const double& x) { return sqrt(x); }
inline double casadi_sin(const double& x) { return sin(x); }
inline double casadi_cos(const double& x) { return cos(x); }
inline double casadi_tan(const double& x) { return tan(x); }
inline double casadi_atan(const double& x) { return atan(x); }
inline double casadi_asin(const double& x) { return asin(x); }
inline double casadi_acos(const double& x) { return acos(x); }
inline double casadi_tanh(const double& x) { return tanh(x); }
inline double casadi_sinh(const double& x) { return sinh(x); }
inline double casadi_cosh(const double& x) { return cosh(x); }
inline double casadi_atanh(const double& x) { return atanh(x); }
inline double casadi_asinh(const double& x) { return asinh(x); }
inline double casadi_acosh(const double& x) { return acosh(x); }
inline double casadi_exp(const double& x) { return exp(x); }
inline double casadi_log(const double& x) { return log(x); }
inline double casadi_log10(const double& x) { return log10(x); }
inline double casadi_floor(const double& x) { return floor(x); }
inline double casadi_ceil(const double& x) { return ceil(x); }
inline double casadi_erf(const double& x) { return erf(x); }
inline double casadi_erfinv(const double& x) { using casadi::erfinv; return erfinv(x); }
inline double casadi_sign(const double& x) { using casadi::sign; return sign(x); }
inline double casadi_power(const double& x, const double& n) { return pow(x, n); }
inline double casadi_mod(const double& x, const double& y) { return fmod(x, y); }
inline double casadi_fmod(const double& x, const double& y) { return fmod(x, y); }
inline double casadi_atan2(const double& x, const double& y) { return atan2(x, y); }
inline double casadi_fmin(const double& x, const double& y) { return fmin(x, y); }
inline double casadi_fmax(const double& x, const double& y) { return fmax(x, y); }
inline double casadi_simplify(const double& x) { using casadi::simplify; return simplify(x); }
inline bool casadi_is_equal(const double& x, const double& y, casadi_int depth=0) { using casadi::is_equal; return is_equal(x, y, depth); }
inline double casadi_copysign(const double& x, const double& y) { return copysign(x, y); }
inline double casadi_constpow(const double& x, const double& y) { using casadi::constpow; return constpow(x, y); }

/*@SWIG@*/
/*@SWIG@*/
    /*@SWIG:swig/casadi.i,3300,GENERIC_MATRIX_ALL@*/
/*@SWIG:swig/casadi.i,3006,GENERIC_MATRIX_FUN@*/

inline MX casadi_mpower(const MX& x, const MX& n) {
  return mpower(x, n);
}

inline MX casadi_mrdivide(const MX& x, const MX& y) {
  return mrdivide(x, y);
}

inline MX casadi_mldivide(const MX& x, const MX& y) {
  return mldivide(x, y);
}

inline std::vector< MX > casadi_symvar(const MX& x) {
  return symvar(x);
}

inline MX casadi_bilin(const MX& A, const MX& x, const MX& y) {
  return bilin(A, x, y);
}

inline MX casadi_rank1(const MX& A, const MX& alpha, const MX& x, const MX& y) {
  return rank1(A, alpha, x, y);
}

inline MX casadi_sumsqr(const MX& X) {
  return sumsqr(X);
}

inline MX casadi_linspace(const MX& a, const MX& b, casadi_int nsteps) {
  return linspace(a, b, nsteps);
}

inline MX casadi_interp1d(const std::vector<double>& x, const MX&v,
        const std::vector<double>& xq, const std::string& mode="linear", bool equidistant=false) {
  return interp1d(x, v, xq, mode, equidistant);
}

inline MX casadi_soc(const MX& x, const MX& y) {
  return soc(x, y);
}

inline MX casadi_cross(const MX& a, const MX& b, casadi_int dim = -1) {
  return cross(a, b, dim);
}

inline MX casadi_skew(const MX& a) {
  return skew(a);
}

inline MX casadi_inv_skew(const MX& a) {
  return inv_skew(a);
}

inline MX casadi_det(const MX& A) {
  return det(A);
}

inline MX casadi_inv_minor(const MX& A) {
  return inv_minor(A);
}

inline MX casadi_inv(const MX& A) {
  return inv(A);
}

inline MX casadi_inv(const MX& A, const std::string& lsolver,
                      const casadi::Dict& opts = casadi::Dict()) {
  return inv(A, lsolver, opts);
}

inline MX casadi_trace(const MX& a) {
  return trace(a);
}

inline MX casadi_tril2symm(const MX& a) {
  return tril2symm(a);
}

inline MX casadi_triu2symm(const MX& a) {
  return triu2symm(a);
}

inline MX casadi_norm_fro(const MX& x) {
  return norm_fro(x);
}

inline MX casadi_norm_2(const MX& x) {
  return norm_2(x);
}

inline MX casadi_norm_1(const MX& x) {
  return norm_1(x);
}

inline MX casadi_norm_inf(const MX& x) {
  return norm_inf(x);
}

inline MX casadi_dot(const MX& x, const MX& y) {
  return dot(x, y);
}

inline MX casadi_nullspace(const MX& A) {
  return nullspace(A);
}

inline MX casadi_polyval(const MX& p, const MX& x) {
  return polyval(p, x);
}

inline MX casadi_diag(const MX& A) {
  return diag(A);
}

inline MX casadi_unite(const MX& A, const MX& B) {
  return unite(A, B);
}

inline MX casadi_densify(const MX& x) {
  return densify(x);
}

inline MX casadi_project(const MX& A, const Sparsity& sp, bool intersect=false) {
  return project(A, sp, intersect);
}

inline MX casadi_if_else(const MX& cond, const MX& if_true,
                    const MX& if_false, bool short_circuit=false) {
  return if_else(cond, if_true, if_false, short_circuit);
}

inline MX casadi_conditional(const MX& ind, const std::vector< MX > &x,
                        const MX& x_default, bool short_circuit=false) {
  return conditional(ind, x, x_default, short_circuit);
}

inline bool casadi_depends_on(const MX& f, const MX& arg) {
  return depends_on(f, arg);
}

inline MX casadi_solve(const MX& A, const MX& b) {
  return solve(A, b);
}

inline MX casadi_solve(const MX& A, const MX& b,
                       const std::string& lsolver,
                       const casadi::Dict& opts = casadi::Dict()) {
  return solve(A, b, lsolver, opts);
}

inline MX casadi_pinv(const MX& A) {
  return pinv(A);
}

inline MX casadi_pinv(const MX& A, const std::string& lsolver,
                      const casadi::Dict& opts = casadi::Dict()) {
  return pinv(A, lsolver, opts);
}

inline MX casadi_expm_const(const MX& A, const MX& t) {
  return expm_const(A, t);
}

inline MX casadi_expm(const MX& A) {
  return expm(A);
}

inline MX casadi_jacobian(const MX &ex, const MX &arg, const Dict& opts=Dict()) {
  return jacobian(ex, arg, opts);
}

inline MX casadi_jtimes(const MX& ex, const MX& arg, const MX& v, bool tr=false) {
  return jtimes(ex, arg, v, tr);
}

inline MX casadi_linearize(const MX& f, const MX& x, const MX& x0) {
  return linearize(f, x, x0);
}

inline std::vector<bool> casadi_which_depends(const MX& expr, const MX& var,
                                            casadi_int order=1, bool tr=false) {
  return which_depends(expr, var, order, tr);
}

inline bool casadi_is_linear(const MX& expr, const MX& var) {
  return is_linear(expr, var);
}

inline bool casadi_is_quadratic(const MX& expr, const MX& var) {
  return is_quadratic(expr, var);
}

inline MX casadi_gradient(const MX &ex, const MX &arg) {
  return gradient(ex, arg);
}

inline MX casadi_tangent(const MX &ex, const MX &arg) {
  return tangent(ex, arg);
}

inline MX casadi_hessian(const MX& ex, const MX& arg, MX& OUTPUT1) {
  return hessian(ex, arg, OUTPUT1);
}

inline void casadi_quadratic_coeff(const MX& ex, const MX& arg, MX& OUTPUT1, MX& OUTPUT2, MX& OUTPUT3, bool check=true) {
  quadratic_coeff(ex, arg, OUTPUT1, OUTPUT2, OUTPUT3, check);
}

inline void casadi_linear_coeff(const MX& ex, const MX& arg, MX& OUTPUT1, MX& OUTPUT2, bool check=true) {
  linear_coeff(ex, arg, OUTPUT1, OUTPUT2, check);
}

inline casadi_int casadi_n_nodes(const MX& A) {
  return n_nodes(A);
}

inline std::string casadi_print_operator(const MX& xb,
                                                  const std::vector<std::string>& args) {
  return print_operator(xb, args);
}
inline MX casadi_repsum(const MX& A, casadi_int n, casadi_int m=1) {
  return repsum(A, n, m);
}
inline MX casadi_diff(const MX& A, casadi_int n=1, casadi_index axis=-1) {
  return diff(A, n, axis);
}
inline MX casadi_cumsum(const MX& A, casadi_index axis=-1) {
  return cumsum(A, axis);
}
inline MX casadi_einstein(const MX& A, const MX& B, const MX& C,
  const std::vector<casadi_int>& dim_a, const std::vector<casadi_int>& dim_b, const std::vector<casadi_int>& dim_c,
  const std::vector<casadi_int>& a, const std::vector<casadi_int>& b, const std::vector<casadi_int>& c) {
  return einstein(A, B, C, dim_a, dim_b, dim_c, a, b, c);
}
inline MX casadi_einstein(const MX& A, const MX& B,
  const std::vector<casadi_int>& dim_a, const std::vector<casadi_int>& dim_b, const std::vector<casadi_int>& dim_c,
  const std::vector<casadi_int>& a, const std::vector<casadi_int>& b, const std::vector<casadi_int>& c) {
  return einstein(A, B, dim_a, dim_b, dim_c, a, b, c);
}
inline MX casadi_mmin(const MX& x) { return mmin(x); }
inline MX casadi_mmax(const MX& x) { return mmax(x); }
inline casadi::DM casadi_evalf(const MX& x) {
  return evalf(x);
}



inline std::vector<std::vector< MX > >
casadi_forward(const std::vector< MX > &ex, const std::vector< MX > &arg,
               const std::vector<std::vector< MX > > &v,
               const Dict& opts = Dict()) {
  return forward(ex, arg, v, opts);
}

inline std::vector<std::vector< MX > >
casadi_reverse(const std::vector< MX > &ex, const std::vector< MX > &arg,
               const std::vector<std::vector< MX > > &v,
               const Dict& opts = Dict()) {
  return reverse(ex, arg, v, opts);
}

inline MX casadi_substitute(const MX& ex, const MX& v, const MX& vdef) {
  return substitute(ex, v, vdef);
}

inline std::vector< MX > casadi_substitute(const std::vector< MX >& ex,
                                         const std::vector< MX >& v,
                                         const std::vector< MX >& vdef) {
  return substitute(ex, v, vdef);
}

inline void casadi_substitute_inplace(const std::vector< MX >& v,
                                      std::vector< MX >& INOUT1,
                                      std::vector< MX >& INOUT2,
                                      bool reverse=false) {
  return substitute_inplace(v, INOUT1, INOUT2, reverse);
}

inline void casadi_shared(const std::vector< MX >& ex,
                               std::vector< MX >& OUTPUT1,
                               std::vector< MX >& OUTPUT2,
                               std::vector< MX >& OUTPUT3,
                               const std::string& v_prefix="v_",
                               const std::string& v_suffix="") {
  shared(ex, OUTPUT1, OUTPUT2, OUTPUT3, v_prefix, v_suffix);
}
inline MX casadi_blockcat(const std::vector< std::vector< MX > > &v) {
 return blockcat(v);
}

/*@SWIG@*/
/*@SWIG:swig/casadi.i,3006,GENERIC_MATRIX_FUN@*/

inline Matrix<double> casadi_mpower(const Matrix<double>& x, const Matrix<double>& n) {
  return mpower(x, n);
}

inline Matrix<double> casadi_mrdivide(const Matrix<double>& x, const Matrix<double>& y) {
  return mrdivide(x, y);
}

inline Matrix<double> casadi_mldivide(const Matrix<double>& x, const Matrix<double>& y) {
  return mldivide(x, y);
}

inline std::vector< Matrix<double> > casadi_symvar(const Matrix<double>& x) {
  return symvar(x);
}

inline Matrix<double> casadi_bilin(const Matrix<double>& A, const Matrix<double>& x, const Matrix<double>& y) {
  return bilin(A, x, y);
}

inline Matrix<double> casadi_rank1(const Matrix<double>& A, const Matrix<double>& alpha, const Matrix<double>& x, const Matrix<double>& y) {
  return rank1(A, alpha, x, y);
}

inline Matrix<double> casadi_sumsqr(const Matrix<double>& X) {
  return sumsqr(X);
}

inline Matrix<double> casadi_linspace(const Matrix<double>& a, const Matrix<double>& b, casadi_int nsteps) {
  return linspace(a, b, nsteps);
}

inline Matrix<double> casadi_interp1d(const std::vector<double>& x, const Matrix<double>&v,
        const std::vector<double>& xq, const std::string& mode="linear", bool equidistant=false) {
  return interp1d(x, v, xq, mode, equidistant);
}

inline Matrix<double> casadi_soc(const Matrix<double>& x, const Matrix<double>& y) {
  return soc(x, y);
}

inline Matrix<double> casadi_cross(const Matrix<double>& a, const Matrix<double>& b, casadi_int dim = -1) {
  return cross(a, b, dim);
}

inline Matrix<double> casadi_skew(const Matrix<double>& a) {
  return skew(a);
}

inline Matrix<double> casadi_inv_skew(const Matrix<double>& a) {
  return inv_skew(a);
}

inline Matrix<double> casadi_det(const Matrix<double>& A) {
  return det(A);
}

inline Matrix<double> casadi_inv_minor(const Matrix<double>& A) {
  return inv_minor(A);
}

inline Matrix<double> casadi_inv(const Matrix<double>& A) {
  return inv(A);
}

inline Matrix<double> casadi_inv(const Matrix<double>& A, const std::string& lsolver,
                      const casadi::Dict& opts = casadi::Dict()) {
  return inv(A, lsolver, opts);
}

inline Matrix<double> casadi_trace(const Matrix<double>& a) {
  return trace(a);
}

inline Matrix<double> casadi_tril2symm(const Matrix<double>& a) {
  return tril2symm(a);
}

inline Matrix<double> casadi_triu2symm(const Matrix<double>& a) {
  return triu2symm(a);
}

inline Matrix<double> casadi_norm_fro(const Matrix<double>& x) {
  return norm_fro(x);
}

inline Matrix<double> casadi_norm_2(const Matrix<double>& x) {
  return norm_2(x);
}

inline Matrix<double> casadi_norm_1(const Matrix<double>& x) {
  return norm_1(x);
}

inline Matrix<double> casadi_norm_inf(const Matrix<double>& x) {
  return norm_inf(x);
}

inline Matrix<double> casadi_dot(const Matrix<double>& x, const Matrix<double>& y) {
  return dot(x, y);
}

inline Matrix<double> casadi_nullspace(const Matrix<double>& A) {
  return nullspace(A);
}

inline Matrix<double> casadi_polyval(const Matrix<double>& p, const Matrix<double>& x) {
  return polyval(p, x);
}

inline Matrix<double> casadi_diag(const Matrix<double>& A) {
  return diag(A);
}

inline Matrix<double> casadi_unite(const Matrix<double>& A, const Matrix<double>& B) {
  return unite(A, B);
}

inline Matrix<double> casadi_densify(const Matrix<double>& x) {
  return densify(x);
}

inline Matrix<double> casadi_project(const Matrix<double>& A, const Sparsity& sp, bool intersect=false) {
  return project(A, sp, intersect);
}

inline Matrix<double> casadi_if_else(const Matrix<double>& cond, const Matrix<double>& if_true,
                    const Matrix<double>& if_false, bool short_circuit=false) {
  return if_else(cond, if_true, if_false, short_circuit);
}

inline Matrix<double> casadi_conditional(const Matrix<double>& ind, const std::vector< Matrix<double> > &x,
                        const Matrix<double>& x_default, bool short_circuit=false) {
  return conditional(ind, x, x_default, short_circuit);
}

inline bool casadi_depends_on(const Matrix<double>& f, const Matrix<double>& arg) {
  return depends_on(f, arg);
}

inline Matrix<double> casadi_solve(const Matrix<double>& A, const Matrix<double>& b) {
  return solve(A, b);
}

inline Matrix<double> casadi_solve(const Matrix<double>& A, const Matrix<double>& b,
                       const std::string& lsolver,
                       const casadi::Dict& opts = casadi::Dict()) {
  return solve(A, b, lsolver, opts);
}

inline Matrix<double> casadi_pinv(const Matrix<double>& A) {
  return pinv(A);
}

inline Matrix<double> casadi_pinv(const Matrix<double>& A, const std::string& lsolver,
                      const casadi::Dict& opts = casadi::Dict()) {
  return pinv(A, lsolver, opts);
}

inline Matrix<double> casadi_expm_const(const Matrix<double>& A, const Matrix<double>& t) {
  return expm_const(A, t);
}

inline Matrix<double> casadi_expm(const Matrix<double>& A) {
  return expm(A);
}

inline Matrix<double> casadi_jacobian(const Matrix<double> &ex, const Matrix<double> &arg, const Dict& opts=Dict()) {
  return jacobian(ex, arg, opts);
}

inline Matrix<double> casadi_jtimes(const Matrix<double>& ex, const Matrix<double>& arg, const Matrix<double>& v, bool tr=false) {
  return jtimes(ex, arg, v, tr);
}

inline Matrix<double> casadi_linearize(const Matrix<double>& f, const Matrix<double>& x, const Matrix<double>& x0) {
  return linearize(f, x, x0);
}

inline std::vector<bool> casadi_which_depends(const Matrix<double>& expr, const Matrix<double>& var,
                                            casadi_int order=1, bool tr=false) {
  return which_depends(expr, var, order, tr);
}

inline bool casadi_is_linear(const Matrix<double>& expr, const Matrix<double>& var) {
  return is_linear(expr, var);
}

inline bool casadi_is_quadratic(const Matrix<double>& expr, const Matrix<double>& var) {
  return is_quadratic(expr, var);
}

inline Matrix<double> casadi_gradient(const Matrix<double> &ex, const Matrix<double> &arg) {
  return gradient(ex, arg);
}

inline Matrix<double> casadi_tangent(const Matrix<double> &ex, const Matrix<double> &arg) {
  return tangent(ex, arg);
}

inline Matrix<double> casadi_hessian(const Matrix<double>& ex, const Matrix<double>& arg, Matrix<double>& OUTPUT1) {
  return hessian(ex, arg, OUTPUT1);
}

inline void casadi_quadratic_coeff(const Matrix<double>& ex, const Matrix<double>& arg, Matrix<double>& OUTPUT1, Matrix<double>& OUTPUT2, Matrix<double>& OUTPUT3, bool check=true) {
  quadratic_coeff(ex, arg, OUTPUT1, OUTPUT2, OUTPUT3, check);
}

inline void casadi_linear_coeff(const Matrix<double>& ex, const Matrix<double>& arg, Matrix<double>& OUTPUT1, Matrix<double>& OUTPUT2, bool check=true) {
  linear_coeff(ex, arg, OUTPUT1, OUTPUT2, check);
}

inline casadi_int casadi_n_nodes(const Matrix<double>& A) {
  return n_nodes(A);
}

inline std::string casadi_print_operator(const Matrix<double>& xb,
                                                  const std::vector<std::string>& args) {
  return print_operator(xb, args);
}
inline Matrix<double> casadi_repsum(const Matrix<double>& A, casadi_int n, casadi_int m=1) {
  return repsum(A, n, m);
}
inline Matrix<double> casadi_diff(const Matrix<double>& A, casadi_int n=1, casadi_index axis=-1) {
  return diff(A, n, axis);
}
inline Matrix<double> casadi_cumsum(const Matrix<double>& A, casadi_index axis=-1) {
  return cumsum(A, axis);
}
inline Matrix<double> casadi_einstein(const Matrix<double>& A, const Matrix<double>& B, const Matrix<double>& C,
  const std::vector<casadi_int>& dim_a, const std::vector<casadi_int>& dim_b, const std::vector<casadi_int>& dim_c,
  const std::vector<casadi_int>& a, const std::vector<casadi_int>& b, const std::vector<casadi_int>& c) {
  return einstein(A, B, C, dim_a, dim_b, dim_c, a, b, c);
}
inline Matrix<double> casadi_einstein(const Matrix<double>& A, const Matrix<double>& B,
  const std::vector<casadi_int>& dim_a, const std::vector<casadi_int>& dim_b, const std::vector<casadi_int>& dim_c,
  const std::vector<casadi_int>& a, const std::vector<casadi_int>& b, const std::vector<casadi_int>& c) {
  return einstein(A, B, dim_a, dim_b, dim_c, a, b, c);
}
inline Matrix<double> casadi_mmin(const Matrix<double>& x) { return mmin(x); }
inline Matrix<double> casadi_mmax(const Matrix<double>& x) { return mmax(x); }
inline casadi::DM casadi_evalf(const Matrix<double>& x) {
  return evalf(x);
}



inline std::vector<std::vector< Matrix<double> > >
casadi_forward(const std::vector< Matrix<double> > &ex, const std::vector< Matrix<double> > &arg,
               const std::vector<std::vector< Matrix<double> > > &v,
               const Dict& opts = Dict()) {
  return forward(ex, arg, v, opts);
}

inline std::vector<std::vector< Matrix<double> > >
casadi_reverse(const std::vector< Matrix<double> > &ex, const std::vector< Matrix<double> > &arg,
               const std::vector<std::vector< Matrix<double> > > &v,
               const Dict& opts = Dict()) {
  return reverse(ex, arg, v, opts);
}

inline Matrix<double> casadi_substitute(const Matrix<double>& ex, const Matrix<double>& v, const Matrix<double>& vdef) {
  return substitute(ex, v, vdef);
}

inline std::vector< Matrix<double> > casadi_substitute(const std::vector< Matrix<double> >& ex,
                                         const std::vector< Matrix<double> >& v,
                                         const std::vector< Matrix<double> >& vdef) {
  return substitute(ex, v, vdef);
}

inline void casadi_substitute_inplace(const std::vector< Matrix<double> >& v,
                                      std::vector< Matrix<double> >& INOUT1,
                                      std::vector< Matrix<double> >& INOUT2,
                                      bool reverse=false) {
  return substitute_inplace(v, INOUT1, INOUT2, reverse);
}

inline void casadi_shared(const std::vector< Matrix<double> >& ex,
                               std::vector< Matrix<double> >& OUTPUT1,
                               std::vector< Matrix<double> >& OUTPUT2,
                               std::vector< Matrix<double> >& OUTPUT3,
                               const std::string& v_prefix="v_",
                               const std::string& v_suffix="") {
  shared(ex, OUTPUT1, OUTPUT2, OUTPUT3, v_prefix, v_suffix);
}
inline Matrix<double> casadi_blockcat(const std::vector< std::vector< Matrix<double> > > &v) {
 return blockcat(v);
}

/*@SWIG@*/
/*@SWIG:swig/casadi.i,3006,GENERIC_MATRIX_FUN@*/

inline Matrix<SXElem> casadi_mpower(const Matrix<SXElem>& x, const Matrix<SXElem>& n) {
  return mpower(x, n);
}

inline Matrix<SXElem> casadi_mrdivide(const Matrix<SXElem>& x, const Matrix<SXElem>& y) {
  return mrdivide(x, y);
}

inline Matrix<SXElem> casadi_mldivide(const Matrix<SXElem>& x, const Matrix<SXElem>& y) {
  return mldivide(x, y);
}

inline std::vector< Matrix<SXElem> > casadi_symvar(const Matrix<SXElem>& x) {
  return symvar(x);
}

inline Matrix<SXElem> casadi_bilin(const Matrix<SXElem>& A, const Matrix<SXElem>& x, const Matrix<SXElem>& y) {
  return bilin(A, x, y);
}

inline Matrix<SXElem> casadi_rank1(const Matrix<SXElem>& A, const Matrix<SXElem>& alpha, const Matrix<SXElem>& x, const Matrix<SXElem>& y) {
  return rank1(A, alpha, x, y);
}

inline Matrix<SXElem> casadi_sumsqr(const Matrix<SXElem>& X) {
  return sumsqr(X);
}

inline Matrix<SXElem> casadi_linspace(const Matrix<SXElem>& a, const Matrix<SXElem>& b, casadi_int nsteps) {
  return linspace(a, b, nsteps);
}

inline Matrix<SXElem> casadi_interp1d(const std::vector<double>& x, const Matrix<SXElem>&v,
        const std::vector<double>& xq, const std::string& mode="linear", bool equidistant=false) {
  return interp1d(x, v, xq, mode, equidistant);
}

inline Matrix<SXElem> casadi_soc(const Matrix<SXElem>& x, const Matrix<SXElem>& y) {
  return soc(x, y);
}

inline Matrix<SXElem> casadi_cross(const Matrix<SXElem>& a, const Matrix<SXElem>& b, casadi_int dim = -1) {
  return cross(a, b, dim);
}

inline Matrix<SXElem> casadi_skew(const Matrix<SXElem>& a) {
  return skew(a);
}

inline Matrix<SXElem> casadi_inv_skew(const Matrix<SXElem>& a) {
  return inv_skew(a);
}

inline Matrix<SXElem> casadi_det(const Matrix<SXElem>& A) {
  return det(A);
}

inline Matrix<SXElem> casadi_inv_minor(const Matrix<SXElem>& A) {
  return inv_minor(A);
}

inline Matrix<SXElem> casadi_inv(const Matrix<SXElem>& A) {
  return inv(A);
}

inline Matrix<SXElem> casadi_inv(const Matrix<SXElem>& A, const std::string& lsolver,
                      const casadi::Dict& opts = casadi::Dict()) {
  return inv(A, lsolver, opts);
}

inline Matrix<SXElem> casadi_trace(const Matrix<SXElem>& a) {
  return trace(a);
}

inline Matrix<SXElem> casadi_tril2symm(const Matrix<SXElem>& a) {
  return tril2symm(a);
}

inline Matrix<SXElem> casadi_triu2symm(const Matrix<SXElem>& a) {
  return triu2symm(a);
}

inline Matrix<SXElem> casadi_norm_fro(const Matrix<SXElem>& x) {
  return norm_fro(x);
}

inline Matrix<SXElem> casadi_norm_2(const Matrix<SXElem>& x) {
  return norm_2(x);
}

inline Matrix<SXElem> casadi_norm_1(const Matrix<SXElem>& x) {
  return norm_1(x);
}

inline Matrix<SXElem> casadi_norm_inf(const Matrix<SXElem>& x) {
  return norm_inf(x);
}

inline Matrix<SXElem> casadi_dot(const Matrix<SXElem>& x, const Matrix<SXElem>& y) {
  return dot(x, y);
}

inline Matrix<SXElem> casadi_nullspace(const Matrix<SXElem>& A) {
  return nullspace(A);
}

inline Matrix<SXElem> casadi_polyval(const Matrix<SXElem>& p, const Matrix<SXElem>& x) {
  return polyval(p, x);
}

inline Matrix<SXElem> casadi_diag(const Matrix<SXElem>& A) {
  return diag(A);
}

inline Matrix<SXElem> casadi_unite(const Matrix<SXElem>& A, const Matrix<SXElem>& B) {
  return unite(A, B);
}

inline Matrix<SXElem> casadi_densify(const Matrix<SXElem>& x) {
  return densify(x);
}

inline Matrix<SXElem> casadi_project(const Matrix<SXElem>& A, const Sparsity& sp, bool intersect=false) {
  return project(A, sp, intersect);
}

inline Matrix<SXElem> casadi_if_else(const Matrix<SXElem>& cond, const Matrix<SXElem>& if_true,
                    const Matrix<SXElem>& if_false, bool short_circuit=false) {
  return if_else(cond, if_true, if_false, short_circuit);
}

inline Matrix<SXElem> casadi_conditional(const Matrix<SXElem>& ind, const std::vector< Matrix<SXElem> > &x,
                        const Matrix<SXElem>& x_default, bool short_circuit=false) {
  return conditional(ind, x, x_default, short_circuit);
}

inline bool casadi_depends_on(const Matrix<SXElem>& f, const Matrix<SXElem>& arg) {
  return depends_on(f, arg);
}

inline Matrix<SXElem> casadi_solve(const Matrix<SXElem>& A, const Matrix<SXElem>& b) {
  return solve(A, b);
}

inline Matrix<SXElem> casadi_solve(const Matrix<SXElem>& A, const Matrix<SXElem>& b,
                       const std::string& lsolver,
                       const casadi::Dict& opts = casadi::Dict()) {
  return solve(A, b, lsolver, opts);
}

inline Matrix<SXElem> casadi_pinv(const Matrix<SXElem>& A) {
  return pinv(A);
}

inline Matrix<SXElem> casadi_pinv(const Matrix<SXElem>& A, const std::string& lsolver,
                      const casadi::Dict& opts = casadi::Dict()) {
  return pinv(A, lsolver, opts);
}

inline Matrix<SXElem> casadi_expm_const(const Matrix<SXElem>& A, const Matrix<SXElem>& t) {
  return expm_const(A, t);
}

inline Matrix<SXElem> casadi_expm(const Matrix<SXElem>& A) {
  return expm(A);
}

inline Matrix<SXElem> casadi_jacobian(const Matrix<SXElem> &ex, const Matrix<SXElem> &arg, const Dict& opts=Dict()) {
  return jacobian(ex, arg, opts);
}

inline Matrix<SXElem> casadi_jtimes(const Matrix<SXElem>& ex, const Matrix<SXElem>& arg, const Matrix<SXElem>& v, bool tr=false) {
  return jtimes(ex, arg, v, tr);
}

inline Matrix<SXElem> casadi_linearize(const Matrix<SXElem>& f, const Matrix<SXElem>& x, const Matrix<SXElem>& x0) {
  return linearize(f, x, x0);
}

inline std::vector<bool> casadi_which_depends(const Matrix<SXElem>& expr, const Matrix<SXElem>& var,
                                            casadi_int order=1, bool tr=false) {
  return which_depends(expr, var, order, tr);
}

inline bool casadi_is_linear(const Matrix<SXElem>& expr, const Matrix<SXElem>& var) {
  return is_linear(expr, var);
}

inline bool casadi_is_quadratic(const Matrix<SXElem>& expr, const Matrix<SXElem>& var) {
  return is_quadratic(expr, var);
}

inline Matrix<SXElem> casadi_gradient(const Matrix<SXElem> &ex, const Matrix<SXElem> &arg) {
  return gradient(ex, arg);
}

inline Matrix<SXElem> casadi_tangent(const Matrix<SXElem> &ex, const Matrix<SXElem> &arg) {
  return tangent(ex, arg);
}

inline Matrix<SXElem> casadi_hessian(const Matrix<SXElem>& ex, const Matrix<SXElem>& arg, Matrix<SXElem>& OUTPUT1) {
  return hessian(ex, arg, OUTPUT1);
}

inline void casadi_quadratic_coeff(const Matrix<SXElem>& ex, const Matrix<SXElem>& arg, Matrix<SXElem>& OUTPUT1, Matrix<SXElem>& OUTPUT2, Matrix<SXElem>& OUTPUT3, bool check=true) {
  quadratic_coeff(ex, arg, OUTPUT1, OUTPUT2, OUTPUT3, check);
}

inline void casadi_linear_coeff(const Matrix<SXElem>& ex, const Matrix<SXElem>& arg, Matrix<SXElem>& OUTPUT1, Matrix<SXElem>& OUTPUT2, bool check=true) {
  linear_coeff(ex, arg, OUTPUT1, OUTPUT2, check);
}

inline casadi_int casadi_n_nodes(const Matrix<SXElem>& A) {
  return n_nodes(A);
}

inline std::string casadi_print_operator(const Matrix<SXElem>& xb,
                                                  const std::vector<std::string>& args) {
  return print_operator(xb, args);
}
inline Matrix<SXElem> casadi_repsum(const Matrix<SXElem>& A, casadi_int n, casadi_int m=1) {
  return repsum(A, n, m);
}
inline Matrix<SXElem> casadi_diff(const Matrix<SXElem>& A, casadi_int n=1, casadi_index axis=-1) {
  return diff(A, n, axis);
}
inline Matrix<SXElem> casadi_cumsum(const Matrix<SXElem>& A, casadi_index axis=-1) {
  return cumsum(A, axis);
}
inline Matrix<SXElem> casadi_einstein(const Matrix<SXElem>& A, const Matrix<SXElem>& B, const Matrix<SXElem>& C,
  const std::vector<casadi_int>& dim_a, const std::vector<casadi_int>& dim_b, const std::vector<casadi_int>& dim_c,
  const std::vector<casadi_int>& a, const std::vector<casadi_int>& b, const std::vector<casadi_int>& c) {
  return einstein(A, B, C, dim_a, dim_b, dim_c, a, b, c);
}
inline Matrix<SXElem> casadi_einstein(const Matrix<SXElem>& A, const Matrix<SXElem>& B,
  const std::vector<casadi_int>& dim_a, const std::vector<casadi_int>& dim_b, const std::vector<casadi_int>& dim_c,
  const std::vector<casadi_int>& a, const std::vector<casadi_int>& b, const std::vector<casadi_int>& c) {
  return einstein(A, B, dim_a, dim_b, dim_c, a, b, c);
}
inline Matrix<SXElem> casadi_mmin(const Matrix<SXElem>& x) { return mmin(x); }
inline Matrix<SXElem> casadi_mmax(const Matrix<SXElem>& x) { return mmax(x); }
inline casadi::DM casadi_evalf(const Matrix<SXElem>& x) {
  return evalf(x);
}



inline std::vector<std::vector< Matrix<SXElem> > >
casadi_forward(const std::vector< Matrix<SXElem> > &ex, const std::vector< Matrix<SXElem> > &arg,
               const std::vector<std::vector< Matrix<SXElem> > > &v,
               const Dict& opts = Dict()) {
  return forward(ex, arg, v, opts);
}

inline std::vector<std::vector< Matrix<SXElem> > >
casadi_reverse(const std::vector< Matrix<SXElem> > &ex, const std::vector< Matrix<SXElem> > &arg,
               const std::vector<std::vector< Matrix<SXElem> > > &v,
               const Dict& opts = Dict()) {
  return reverse(ex, arg, v, opts);
}

inline Matrix<SXElem> casadi_substitute(const Matrix<SXElem>& ex, const Matrix<SXElem>& v, const Matrix<SXElem>& vdef) {
  return substitute(ex, v, vdef);
}

inline std::vector< Matrix<SXElem> > casadi_substitute(const std::vector< Matrix<SXElem> >& ex,
                                         const std::vector< Matrix<SXElem> >& v,
                                         const std::vector< Matrix<SXElem> >& vdef) {
  return substitute(ex, v, vdef);
}

inline void casadi_substitute_inplace(const std::vector< Matrix<SXElem> >& v,
                                      std::vector< Matrix<SXElem> >& INOUT1,
                                      std::vector< Matrix<SXElem> >& INOUT2,
                                      bool reverse=false) {
  return substitute_inplace(v, INOUT1, INOUT2, reverse);
}

inline void casadi_shared(const std::vector< Matrix<SXElem> >& ex,
                               std::vector< Matrix<SXElem> >& OUTPUT1,
                               std::vector< Matrix<SXElem> >& OUTPUT2,
                               std::vector< Matrix<SXElem> >& OUTPUT3,
                               const std::string& v_prefix="v_",
                               const std::string& v_suffix="") {
  shared(ex, OUTPUT1, OUTPUT2, OUTPUT3, v_prefix, v_suffix);
}
inline Matrix<SXElem> casadi_blockcat(const std::vector< std::vector< Matrix<SXElem> > > &v) {
 return blockcat(v);
}

/*@SWIG@*/
/*@SWIG@*/
    /*@SWIG:swig/casadi.i,3490,MATRIX_ALL@*/
/*@SWIG:swig/casadi.i,3364,MATRIX_FUN@*/

inline Matrix<double> casadi_all(const Matrix<double>& x) {
  return all(x);
}

inline Matrix<double> casadi_any(const Matrix<double>& x) {
  return any(x);
}

inline Matrix<double> casadi_adj(const Matrix<double>& A) {
  return adj(A);
}

inline Matrix<double> casadi_minor(const Matrix<double>& x, casadi_int i, casadi_int j) {
  return minor(x, i, j);
}

inline Matrix<double> casadi_cofactor(const Matrix<double>& x, casadi_int i, casadi_int j) {
  return cofactor(x, i, j);
}

inline void casadi_qr(const Matrix<double>& A, Matrix<double>& OUTPUT1, Matrix<double>& OUTPUT2) {
  return qr(A, OUTPUT1, OUTPUT2);
}

inline void casadi_qr_sparse(const Matrix<double>& A, Matrix<double>& OUTPUT1, Matrix<double>& OUTPUT2, Matrix<double>& OUTPUT3,
          std::vector<casadi_int>& OUTPUT4, std::vector<casadi_int>& OUTPUT5, bool amd=true) {
  return qr_sparse(A, OUTPUT1, OUTPUT2, OUTPUT3, OUTPUT4, OUTPUT5, amd);
}

inline Matrix<double> casadi_qr_solve(const Matrix<double>& b, const Matrix<double>& v, const Matrix<double>& r, const Matrix<double>& beta,
                       const std::vector<casadi_int>& prinv,
                       const std::vector<casadi_int>& pc, bool tr=false) {
  return qr_solve(b, v, r, beta, prinv, pc, tr);
}

inline void casadi_ldl(const Matrix<double>& A, Matrix<double>& OUTPUT1, Matrix<double>& OUTPUT2, std::vector<casadi_int>& OUTPUT3, bool amd=true) {
  return ldl(A, OUTPUT1, OUTPUT2, OUTPUT3, amd);
}

inline Matrix<double> casadi_ldl_solve(const Matrix<double>& b, const Matrix<double>& D, const Matrix<double>& LT, const std::vector<casadi_int>& p) {
  return ldl_solve(b, D, LT, p);
}

inline Matrix<double> casadi_chol(const Matrix<double>& A) {
  return chol(A);
}

inline Matrix<double> casadi_norm_inf_mul(const Matrix<double>& x, const Matrix<double>& y) {
  return norm_inf_mul(x, y);
}

inline Matrix<double> casadi_sparsify(const Matrix<double>& A, double tol=0) {
  return sparsify(A, tol);
}

inline void casadi_expand(const Matrix<double>& ex, Matrix<double>& OUTPUT1, Matrix<double>& OUTPUT2) {
  expand(ex, OUTPUT1, OUTPUT2);
}

inline Matrix<double> casadi_pw_const(const Matrix<double> &t, const Matrix<double>& tval, const Matrix<double>& val) {
  return pw_const(t, tval, val);
}

inline Matrix<double> casadi_pw_lin(const Matrix<double>& t, const Matrix<double>& tval, const Matrix<double>& val) {
  return pw_lin(t, tval, val);
}

inline Matrix<double> casadi_heaviside(const Matrix<double>& x) {
  return heaviside(x);
}

inline Matrix<double> casadi_rectangle(const Matrix<double>& x) {
  return rectangle(x);
}

inline Matrix<double> casadi_triangle(const Matrix<double>& x) {
  return triangle(x);
}

inline Matrix<double> casadi_ramp(const Matrix<double>& x) {
  return ramp(x);
}

inline Matrix<double> casadi_gauss_quadrature(const Matrix<double>& f, const Matrix<double>& x,
                               const Matrix<double>& a, const Matrix<double>& b,
                               casadi_int order=5) {
  return gauss_quadrature(f, x, a, b, order);
}

inline Matrix<double> casadi_gauss_quadrature(const Matrix<double>& f, const Matrix<double>& x,
                               const Matrix<double>& a, const Matrix<double>& b,
                               casadi_int order, const Matrix<double>& w) {
  return gauss_quadrature(f, x, a, b, order, w);
}

inline Matrix<double> casadi_taylor(const Matrix<double>& ex, const Matrix<double>& x, const Matrix<double>& a=0, casadi_int order=1) {
  return taylor(ex, x, a, order);
}

inline Matrix<double> casadi_mtaylor(const Matrix<double>& ex, const Matrix<double>& x, const Matrix<double>& a, casadi_int order=1) {
  return mtaylor(ex, x, a, order);
}

inline Matrix<double> casadi_mtaylor(const Matrix<double>& ex, const Matrix<double>& x, const Matrix<double>& a, casadi_int order,
                      const std::vector<casadi_int>& order_contributions) {
  return mtaylor(ex, x, a, order, order_contributions);
}

inline Matrix<double> casadi_poly_coeff(const Matrix<double>& ex,
                         const Matrix<double>&x) {
  return poly_coeff(ex, x);
}

inline Matrix<double> casadi_poly_roots(const Matrix<double>& p) {
  return poly_roots(p);
}

inline Matrix<double> casadi_eig_symbolic(const Matrix<double>& m) {
  return eig_symbolic(m);
}


/*@SWIG@*/
/*@SWIG:swig/casadi.i,3364,MATRIX_FUN@*/

inline Matrix<SXElem> casadi_all(const Matrix<SXElem>& x) {
  return all(x);
}

inline Matrix<SXElem> casadi_any(const Matrix<SXElem>& x) {
  return any(x);
}

inline Matrix<SXElem> casadi_adj(const Matrix<SXElem>& A) {
  return adj(A);
}

inline Matrix<SXElem> casadi_minor(const Matrix<SXElem>& x, casadi_int i, casadi_int j) {
  return minor(x, i, j);
}

inline Matrix<SXElem> casadi_cofactor(const Matrix<SXElem>& x, casadi_int i, casadi_int j) {
  return cofactor(x, i, j);
}

inline void casadi_qr(const Matrix<SXElem>& A, Matrix<SXElem>& OUTPUT1, Matrix<SXElem>& OUTPUT2) {
  return qr(A, OUTPUT1, OUTPUT2);
}

inline void casadi_qr_sparse(const Matrix<SXElem>& A, Matrix<SXElem>& OUTPUT1, Matrix<SXElem>& OUTPUT2, Matrix<SXElem>& OUTPUT3,
          std::vector<casadi_int>& OUTPUT4, std::vector<casadi_int>& OUTPUT5, bool amd=true) {
  return qr_sparse(A, OUTPUT1, OUTPUT2, OUTPUT3, OUTPUT4, OUTPUT5, amd);
}

inline Matrix<SXElem> casadi_qr_solve(const Matrix<SXElem>& b, const Matrix<SXElem>& v, const Matrix<SXElem>& r, const Matrix<SXElem>& beta,
                       const std::vector<casadi_int>& prinv,
                       const std::vector<casadi_int>& pc, bool tr=false) {
  return qr_solve(b, v, r, beta, prinv, pc, tr);
}

inline void casadi_ldl(const Matrix<SXElem>& A, Matrix<SXElem>& OUTPUT1, Matrix<SXElem>& OUTPUT2, std::vector<casadi_int>& OUTPUT3, bool amd=true) {
  return ldl(A, OUTPUT1, OUTPUT2, OUTPUT3, amd);
}

inline Matrix<SXElem> casadi_ldl_solve(const Matrix<SXElem>& b, const Matrix<SXElem>& D, const Matrix<SXElem>& LT, const std::vector<casadi_int>& p) {
  return ldl_solve(b, D, LT, p);
}

inline Matrix<SXElem> casadi_chol(const Matrix<SXElem>& A) {
  return chol(A);
}

inline Matrix<SXElem> casadi_norm_inf_mul(const Matrix<SXElem>& x, const Matrix<SXElem>& y) {
  return norm_inf_mul(x, y);
}

inline Matrix<SXElem> casadi_sparsify(const Matrix<SXElem>& A, double tol=0) {
  return sparsify(A, tol);
}

inline void casadi_expand(const Matrix<SXElem>& ex, Matrix<SXElem>& OUTPUT1, Matrix<SXElem>& OUTPUT2) {
  expand(ex, OUTPUT1, OUTPUT2);
}

inline Matrix<SXElem> casadi_pw_const(const Matrix<SXElem> &t, const Matrix<SXElem>& tval, const Matrix<SXElem>& val) {
  return pw_const(t, tval, val);
}

inline Matrix<SXElem> casadi_pw_lin(const Matrix<SXElem>& t, const Matrix<SXElem>& tval, const Matrix<SXElem>& val) {
  return pw_lin(t, tval, val);
}

inline Matrix<SXElem> casadi_heaviside(const Matrix<SXElem>& x) {
  return heaviside(x);
}

inline Matrix<SXElem> casadi_rectangle(const Matrix<SXElem>& x) {
  return rectangle(x);
}

inline Matrix<SXElem> casadi_triangle(const Matrix<SXElem>& x) {
  return triangle(x);
}

inline Matrix<SXElem> casadi_ramp(const Matrix<SXElem>& x) {
  return ramp(x);
}

inline Matrix<SXElem> casadi_gauss_quadrature(const Matrix<SXElem>& f, const Matrix<SXElem>& x,
                               const Matrix<SXElem>& a, const Matrix<SXElem>& b,
                               casadi_int order=5) {
  return gauss_quadrature(f, x, a, b, order);
}

inline Matrix<SXElem> casadi_gauss_quadrature(const Matrix<SXElem>& f, const Matrix<SXElem>& x,
                               const Matrix<SXElem>& a, const Matrix<SXElem>& b,
                               casadi_int order, const Matrix<SXElem>& w) {
  return gauss_quadrature(f, x, a, b, order, w);
}

inline Matrix<SXElem> casadi_taylor(const Matrix<SXElem>& ex, const Matrix<SXElem>& x, const Matrix<SXElem>& a=0, casadi_int order=1) {
  return taylor(ex, x, a, order);
}

inline Matrix<SXElem> casadi_mtaylor(const Matrix<SXElem>& ex, const Matrix<SXElem>& x, const Matrix<SXElem>& a, casadi_int order=1) {
  return mtaylor(ex, x, a, order);
}

inline Matrix<SXElem> casadi_mtaylor(const Matrix<SXElem>& ex, const Matrix<SXElem>& x, const Matrix<SXElem>& a, casadi_int order,
                      const std::vector<casadi_int>& order_contributions) {
  return mtaylor(ex, x, a, order, order_contributions);
}

inline Matrix<SXElem> casadi_poly_coeff(const Matrix<SXElem>& ex,
                         const Matrix<SXElem>&x) {
  return poly_coeff(ex, x);
}

inline Matrix<SXElem> casadi_poly_roots(const Matrix<SXElem>& p) {
  return poly_roots(p);
}

inline Matrix<SXElem> casadi_eig_symbolic(const Matrix<SXElem>& m) {
  return eig_symbolic(m);
}


/*@SWIG@*/
/*@SWIG@*/
    /*@SWIG:swig/casadi.i,3557,MX_ALL@*/
/*@SWIG:swig/casadi.i,3495,MX_FUN@*/

inline MX casadi_find(const MX& x) {
  return find(x);
}
inline MX casadi_low(const MX& v, const MX& p, const Dict& options = Dict()) {
  return low(v, p, options);
}
inline MX casadi_inv_node(const MX& x) {
  return inv_node(x);
}



inline std::vector< MX >
casadi_matrix_expand(const std::vector< MX >& e,
                     const std::vector< MX > &boundary = std::vector< MX >(),
                     const Dict& options = Dict()) {
  return matrix_expand(e, boundary, options);
}

inline MX casadi_matrix_expand(const MX& e,
                            const std::vector< MX > &boundary = std::vector< MX >(),
                            const Dict& options = Dict()) {
  return matrix_expand(e, boundary, options);
}

inline MX casadi_graph_substitute(const MX& ex, const std::vector< MX >& v,
                         const std::vector< MX > &vdef) {
  return graph_substitute(ex, v, vdef);
}

inline std::vector< MX >
casadi_graph_substitute(const std::vector< MX > &ex,
                 const std::vector< MX > &v,
                 const std::vector< MX > &vdef) {
  return graph_substitute(ex, v, vdef);
}
inline MX casadi_bspline(const MX& x,
        const DM& coeffs,
        const std::vector< std::vector<double> >& knots,
        const std::vector<casadi_int>& degree,
        casadi_int m,
        const Dict& opts = Dict()) {
  return bspline(x, coeffs, knots, degree, m, opts);
}
inline MX casadi_bspline(const MX& x,
        const MX& coeffs,
        const std::vector< std::vector<double> >& knots,
        const std::vector<casadi_int>& degree,
        casadi_int m,
        const Dict& opts = Dict()) {
  return bspline(x, coeffs, knots, degree, m, opts);
}
inline MX casadi_convexify(const MX& H,
        const Dict& opts = Dict()) {
  return convexify(H, opts);
}


/*@SWIG@*/
/*@SWIG@*/
  }



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "casadi_wrap.h"

SwigDirector_Callback::SwigDirector_Callback(PyObject *self): casadi::Callback(), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((casadi::Callback *)this, this); 
}




SwigDirector_Callback::SwigDirector_Callback(PyObject *self, casadi::Callback const &obj): casadi::Callback(obj), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((casadi::Callback *)this, this); 
}




SwigDirector_Callback::~SwigDirector_Callback() {
}

void SwigDirector_Callback::init() {
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 0;
  const char *const swig_method_name = "init";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("init");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
}


void SwigDirector_Callback::finalize() {
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 1;
  const char *const swig_method_name = "finalize";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("finalize");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
}


std::vector< casadi::DM, std::allocator< casadi::DM > > SwigDirector_Callback::eval(std::vector< casadi::DM, std::allocator< casadi::DM > > const &arg) const {
  std::vector< casadi::DM,std::allocator< casadi::DM > > c_result;
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ptr(&arg))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "[" "DM" "]" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 2;
  const char *const swig_method_name = "eval";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("eval");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""std::vector< casadi::DM,std::allocator< casadi::DM > >""'");
  }
  return (std::vector< casadi::DM,std::allocator< casadi::DM > >) c_result;
}


int SwigDirector_Callback::eval_buffer(double const **arg, std::vector< casadi_int, std::allocator< casadi_int > > const &sizes_arg, double **res, std::vector< casadi_int, std::allocator< casadi_int > > const &sizes_res) const {
  int c_result = SwigValueInit< int >() ;
  PyObject *my_tuple1 ;
  
  swig::SwigVar_PyObject obj0;
  PyObject * arg_tuple = PyTuple_New((&sizes_arg)->size());
  for (casadi_int i=0;i<(&sizes_arg)->size();++i) {
    PyObject* buf = arg[i] ? PyBuffer_FromMemory(const_cast<double*>(arg[i]), sizes_arg[i]*sizeof(double)) : SWIG_Py_Void();
    
    PyTuple_SET_ITEM(arg_tuple, i, buf);
  }
  obj0 = arg_tuple;
  swig::SwigVar_PyObject obj1;
  PyObject* res_tuple = PyTuple_New((&sizes_res)->size());
  for (casadi_int i=0;i<(&sizes_res)->size();++i) {
    PyObject* buf = res[i] ? PyBuffer_FromReadWriteMemory(res[i], sizes_res[i]*sizeof(double)) : SWIG_Py_Void();
    
    PyTuple_SET_ITEM(res_tuple, i, buf);
  }
  obj1 = res_tuple;
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 3;
  const char *const swig_method_name = "eval_buffer";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0,(PyObject *)obj1, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("eval_buffer");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0,(PyObject *)obj1, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  int swig_val;
  int swig_res = SWIG_AsVal_int(result, &swig_val);
  if (!SWIG_IsOK(swig_res)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(swig_res)), "in output value of type '""int""'");
  }
  c_result = static_cast< int >(swig_val);
  return (int) c_result;
}


bool SwigDirector_Callback::has_eval_buffer() const {
  bool c_result = SwigValueInit< bool >() ;
  
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 4;
  const char *const swig_method_name = "has_eval_buffer";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("has_eval_buffer");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""bool""'");
  }
  return (bool) c_result;
}


casadi_int SwigDirector_Callback::get_n_in() {
  casadi_int c_result = SwigValueInit< casadi_int >() ;
  
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 5;
  const char *const swig_method_name = "get_n_in";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_n_in");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""casadi_int""'");
  }
  return (casadi_int) c_result;
}


casadi_int SwigDirector_Callback::get_n_out() {
  casadi_int c_result = SwigValueInit< casadi_int >() ;
  
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 6;
  const char *const swig_method_name = "get_n_out";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_n_out");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""casadi_int""'");
  }
  return (casadi_int) c_result;
}


casadi::Sparsity SwigDirector_Callback::get_sparsity_in(casadi_int i) {
  casadi::Sparsity c_result;
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ref(i))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "int" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 7;
  const char *const swig_method_name = "get_sparsity_in";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_sparsity_in");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""casadi::Sparsity""'");
  }
  return (casadi::Sparsity) c_result;
}


casadi::Sparsity SwigDirector_Callback::get_sparsity_out(casadi_int i) {
  casadi::Sparsity c_result;
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ref(i))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "int" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 8;
  const char *const swig_method_name = "get_sparsity_out";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_sparsity_out");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""casadi::Sparsity""'");
  }
  return (casadi::Sparsity) c_result;
}


std::string SwigDirector_Callback::get_name_in(casadi_int i) {
  std::string c_result;
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ref(i))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "int" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 9;
  const char *const swig_method_name = "get_name_in";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_name_in");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""std::string""'");
  }
  return (std::string) c_result;
}


std::string SwigDirector_Callback::get_name_out(casadi_int i) {
  std::string c_result;
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ref(i))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "int" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 10;
  const char *const swig_method_name = "get_name_out";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_name_out");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""std::string""'");
  }
  return (std::string) c_result;
}


bool SwigDirector_Callback::uses_output() const {
  bool c_result = SwigValueInit< bool >() ;
  
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 11;
  const char *const swig_method_name = "uses_output";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("uses_output");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""bool""'");
  }
  return (bool) c_result;
}


bool SwigDirector_Callback::has_jacobian() const {
  bool c_result = SwigValueInit< bool >() ;
  
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 12;
  const char *const swig_method_name = "has_jacobian";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("has_jacobian");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""bool""'");
  }
  return (bool) c_result;
}


casadi::Function SwigDirector_Callback::get_jacobian(std::string const &name, std::vector< std::string, std::allocator< std::string > > const &inames, std::vector< std::string, std::allocator< std::string > > const &onames, casadi::Dict const &opts) const {
  casadi::Function c_result;
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ptr(&name))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "str" ".""'");
  swig::SwigVar_PyObject obj1;
  if(!(obj1 = casadi::from_ptr(&inames))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "[" "str" "]" ".""'");
  swig::SwigVar_PyObject obj2;
  if(!(obj2 = casadi::from_ptr(&onames))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "[" "str" "]" ".""'");
  swig::SwigVar_PyObject obj3;
  if(!(obj3 = casadi::from_ptr(&opts))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "dict" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 13;
  const char *const swig_method_name = "get_jacobian";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0,(PyObject *)obj1,(PyObject *)obj2,(PyObject *)obj3, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_jacobian");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0,(PyObject *)obj1,(PyObject *)obj2,(PyObject *)obj3, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""casadi::Function""'");
  }
  return (casadi::Function) c_result;
}


bool SwigDirector_Callback::has_forward(casadi_int nfwd) const {
  bool c_result = SwigValueInit< bool >() ;
  
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ref(nfwd))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "int" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 14;
  const char *const swig_method_name = "has_forward";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("has_forward");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""bool""'");
  }
  return (bool) c_result;
}


casadi::Function SwigDirector_Callback::get_forward(casadi_int nfwd, std::string const &name, std::vector< std::string, std::allocator< std::string > > const &inames, std::vector< std::string, std::allocator< std::string > > const &onames, casadi::Dict const &opts) const {
  casadi::Function c_result;
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ref(nfwd))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "int" ".""'");
  swig::SwigVar_PyObject obj1;
  if(!(obj1 = casadi::from_ptr(&name))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "str" ".""'");
  swig::SwigVar_PyObject obj2;
  if(!(obj2 = casadi::from_ptr(&inames))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "[" "str" "]" ".""'");
  swig::SwigVar_PyObject obj3;
  if(!(obj3 = casadi::from_ptr(&onames))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "[" "str" "]" ".""'");
  swig::SwigVar_PyObject obj4;
  if(!(obj4 = casadi::from_ptr(&opts))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "dict" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 15;
  const char *const swig_method_name = "get_forward";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0,(PyObject *)obj1,(PyObject *)obj2,(PyObject *)obj3,(PyObject *)obj4, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_forward");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0,(PyObject *)obj1,(PyObject *)obj2,(PyObject *)obj3,(PyObject *)obj4, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""casadi::Function""'");
  }
  return (casadi::Function) c_result;
}


bool SwigDirector_Callback::has_reverse(casadi_int nadj) const {
  bool c_result = SwigValueInit< bool >() ;
  
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ref(nadj))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "int" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 16;
  const char *const swig_method_name = "has_reverse";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("has_reverse");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""bool""'");
  }
  return (bool) c_result;
}


casadi::Function SwigDirector_Callback::get_reverse(casadi_int nadj, std::string const &name, std::vector< std::string, std::allocator< std::string > > const &inames, std::vector< std::string, std::allocator< std::string > > const &onames, casadi::Dict const &opts) const {
  casadi::Function c_result;
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ref(nadj))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "int" ".""'");
  swig::SwigVar_PyObject obj1;
  if(!(obj1 = casadi::from_ptr(&name))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "str" ".""'");
  swig::SwigVar_PyObject obj2;
  if(!(obj2 = casadi::from_ptr(&inames))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "[" "str" "]" ".""'");
  swig::SwigVar_PyObject obj3;
  if(!(obj3 = casadi::from_ptr(&onames))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "[" "str" "]" ".""'");
  swig::SwigVar_PyObject obj4;
  if(!(obj4 = casadi::from_ptr(&opts))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "dict" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 17;
  const char *const swig_method_name = "get_reverse";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0,(PyObject *)obj1,(PyObject *)obj2,(PyObject *)obj3,(PyObject *)obj4, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_reverse");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0,(PyObject *)obj1,(PyObject *)obj2,(PyObject *)obj3,(PyObject *)obj4, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""casadi::Function""'");
  }
  return (casadi::Function) c_result;
}


bool SwigDirector_Callback::has_jacobian_sparsity() const {
  bool c_result = SwigValueInit< bool >() ;
  
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 18;
  const char *const swig_method_name = "has_jacobian_sparsity";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("has_jacobian_sparsity");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""bool""'");
  }
  return (bool) c_result;
}


casadi::Sparsity SwigDirector_Callback::get_jacobian_sparsity() const {
  casadi::Sparsity c_result;
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call Callback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 19;
  const char *const swig_method_name = "get_jacobian_sparsity";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject args = PyTuple_New(0);
  swig::SwigVar_PyObject result = PyObject_Call(method, (PyObject *) args, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("get_jacobian_sparsity");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
  if (!casadi::to_val(result, &c_result)) {
    Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""casadi::Sparsity""'");
  }
  return (casadi::Sparsity) c_result;
}


SwigDirector_OptiCallback::SwigDirector_OptiCallback(PyObject *self): casadi::OptiCallback(), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((casadi::OptiCallback *)this, this); 
}




SwigDirector_OptiCallback::SwigDirector_OptiCallback(PyObject *self, casadi::OptiCallback const &obj): casadi::OptiCallback(obj), Swig::Director(self) {
  SWIG_DIRECTOR_RGTR((casadi::OptiCallback *)this, this); 
}




void SwigDirector_OptiCallback::call(casadi_int i) {
  swig::SwigVar_PyObject obj0;
  if(!(obj0 = casadi::from_ref(i))) Swig::DirectorTypeMismatchException::raise(SWIG_ErrorType(SWIG_ArgError(SWIG_TypeError)), "in output value of type '""For director inputs, failed to convert input to " "int" ".""'");
  if (!swig_get_self()) {
    Swig::DirectorException::raise("'self' uninitialized, maybe you forgot to call OptiCallback.__init__.");
  }
#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
  const size_t swig_method_index = 0;
  const char *const swig_method_name = "call";
  PyObject *method = swig_get_method(swig_method_index, swig_method_name);
  swig::SwigVar_PyObject result = PyObject_CallFunctionObjArgs(method ,(PyObject *)obj0, NULL);
#else
  swig::SwigVar_PyObject swig_method_name = SWIG_Python_str_FromChar("call");
  swig::SwigVar_PyObject result = PyObject_CallMethodObjArgs(swig_get_self(), (PyObject *) swig_method_name ,(PyObject *)obj0, NULL);
#endif
  if (!result) {
    PyObject *error = PyErr_Occurred();
    {
      if (error != NULL) casadi::handle_director_exception();
    }
  }
}


SwigDirector_OptiCallback::~SwigDirector_OptiCallback() {
}

#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN PyObject *_wrap_delete_SwigPyIterator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SwigPyIterator" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_value(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_value" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)((swig::SwigPyIterator const *)arg1)->value();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_incr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  size_t arg2 = (size_t) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator_incr", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_incr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_incr" "', argument " "2"" of type '" "size_t""'");
    } 
    arg2 = static_cast< size_t >(val2);
  }
  try {
    result = (swig::SwigPyIterator *)(arg1)->incr(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_decr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  size_t arg2 = (size_t) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator_decr", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_decr" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_size_t(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_decr" "', argument " "2"" of type '" "size_t""'");
    } 
    arg2 = static_cast< size_t >(val2);
  }
  try {
    result = (swig::SwigPyIterator *)(arg1)->decr(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_distance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ptrdiff_t result;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator_distance", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_distance" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_distance" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  try {
    result = ((swig::SwigPyIterator const *)arg1)->distance((swig::SwigPyIterator const &)*arg2);
  } catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_equal(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator_equal", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_equal" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator_equal" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  try {
    result = (bool)((swig::SwigPyIterator const *)arg1)->equal((swig::SwigPyIterator const &)*arg2);
  } catch(std::invalid_argument &_e) {
    SWIG_Python_Raise(SWIG_NewPointerObj((new std::invalid_argument(static_cast< const std::invalid_argument& >(_e))),SWIGTYPE_p_std__invalid_argument,SWIG_POINTER_OWN), "std::invalid_argument", SWIGTYPE_p_std__invalid_argument); SWIG_fail;
  }
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_copy" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->copy();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_next(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_next" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->next();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___next__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___next__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->__next__();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_previous(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_previous" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  try {
    result = (PyObject *)(arg1)->previous();
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator_advance(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator_advance", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator_advance" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator_advance" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)(arg1)->advance(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator___eq__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___eq__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___eq__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = (bool)((swig::SwigPyIterator const *)arg1)->operator ==((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator___ne__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___ne__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___ne__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = (bool)((swig::SwigPyIterator const *)arg1)->operator !=((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___iadd__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator___iadd__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___iadd__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___iadd__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *) &(arg1)->operator +=(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___isub__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator___isub__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___isub__" "', argument " "1"" of type '" "swig::SwigPyIterator *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___isub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *) &(arg1)->operator -=(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  swig::SwigPyIterator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "SwigPyIterator___add__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___add__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___add__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator +(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  ptrdiff_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ptrdiff_t val2 ;
  int ecode2 = 0 ;
  swig::SwigPyIterator *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  ecode2 = SWIG_AsVal_ptrdiff_t(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "ptrdiff_t""'");
  } 
  arg2 = static_cast< ptrdiff_t >(val2);
  try {
    result = (swig::SwigPyIterator *)((swig::SwigPyIterator const *)arg1)->operator -(arg2);
  } catch(swig::stop_iteration &_e) {
    {
      (void)_e;
      SWIG_SetErrorObj(PyExc_StopIteration, SWIG_Py_Void());
      SWIG_fail;
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub____SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  swig::SwigPyIterator *arg1 = (swig::SwigPyIterator *) 0 ;
  swig::SwigPyIterator *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  ptrdiff_t result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_swig__SwigPyIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SwigPyIterator___sub__" "', argument " "1"" of type '" "swig::SwigPyIterator const *""'"); 
  }
  arg1 = reinterpret_cast< swig::SwigPyIterator * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_swig__SwigPyIterator,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SwigPyIterator___sub__" "', argument " "2"" of type '" "swig::SwigPyIterator const &""'"); 
  }
  arg2 = reinterpret_cast< swig::SwigPyIterator * >(argp2);
  result = ((swig::SwigPyIterator const *)arg1)->operator -((swig::SwigPyIterator const &)*arg2);
  resultobj = SWIG_From_ptrdiff_t(static_cast< ptrdiff_t >(result));
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SwigPyIterator___sub__(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SwigPyIterator___sub__", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_swig__SwigPyIterator, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SwigPyIterator___sub____SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_swig__SwigPyIterator, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      {
        int res = SWIG_AsVal_ptrdiff_t(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        return _wrap_SwigPyIterator___sub____SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *SwigPyIterator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_swig__SwigPyIterator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_PrintableCommon__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::PrintableCommon *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::PrintableCommon *)new casadi::PrintableCommon();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__PrintableCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_PrintableCommon__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::PrintableCommon *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::PrintableCommon *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__PrintableCommon,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_PrintableCommon" "', argument " "1"" of type '" "casadi::PrintableCommon const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_PrintableCommon" "', argument " "1"" of type '" "casadi::PrintableCommon const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::PrintableCommon * >(argp1);
  {
    result = (casadi::PrintableCommon *)new casadi::PrintableCommon((casadi::PrintableCommon const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__PrintableCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_PrintableCommon(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_PrintableCommon", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_PrintableCommon__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__PrintableCommon, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_PrintableCommon__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_PrintableCommon'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::PrintableCommon::PrintableCommon()\n"
    "    casadi::PrintableCommon::PrintableCommon(casadi::PrintableCommon const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_PrintableCommon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::PrintableCommon *arg1 = (casadi::PrintableCommon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__PrintableCommon, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PrintableCommon" "', argument " "1"" of type '" "casadi::PrintableCommon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::PrintableCommon * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *PrintableCommon_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__PrintableCommon, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *PrintableCommon_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_SharedObject_class_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObject *arg1 = (casadi::SharedObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SharedObject_class_name" "', argument " "1"" of type '" "casadi::SharedObject const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObject * >(argp1);
  {
    try {
      result = ((casadi::SharedObject const *)arg1)->class_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SharedObject_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObject *arg1 = (casadi::SharedObject *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "SharedObject_disp", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SharedObject_disp" "', argument " "1"" of type '" "casadi::SharedObject const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObject * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::SharedObject const *)arg1)->disp(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SharedObject_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObject *arg1 = (casadi::SharedObject *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "SharedObject_str", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SharedObject_str" "', argument " "1"" of type '" "casadi::SharedObject const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObject * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::SharedObject const *)arg1)->get_str(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SharedObject_print_ptr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObject *arg1 = (casadi::SharedObject *) 0 ;
  std::ostream &arg2_defvalue = casadi::uout() ;
  std::ostream *arg2 = (std::ostream *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &casadi::uout();
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SharedObject_print_ptr" "', argument " "1"" of type '" "casadi::SharedObject const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObject * >(argp1);
  {
    try {
      ((casadi::SharedObject const *)arg1)->print_ptr(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SharedObject_is_null(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObject *arg1 = (casadi::SharedObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SharedObject_is_null" "', argument " "1"" of type '" "casadi::SharedObject const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObject * >(argp1);
  {
    try {
      result = (bool)((casadi::SharedObject const *)arg1)->is_null();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SharedObject___hash__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObject *arg1 = (casadi::SharedObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObject, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SharedObject___hash__" "', argument " "1"" of type '" "casadi::SharedObject const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObject * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::SharedObject const *)arg1)->__hash__();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SharedObject__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::SharedObject *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::SharedObject *)new casadi::SharedObject();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__SharedObject, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SharedObject__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SharedObject *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::SharedObject *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__SharedObject,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SharedObject" "', argument " "1"" of type '" "casadi::SharedObject const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SharedObject" "', argument " "1"" of type '" "casadi::SharedObject const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObject * >(argp1);
  {
    result = (casadi::SharedObject *)new casadi::SharedObject((casadi::SharedObject const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__SharedObject, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SharedObject(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_SharedObject", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_SharedObject__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__SharedObject, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SharedObject__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_SharedObject'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::SharedObject::SharedObject()\n"
    "    casadi::SharedObject::SharedObject(casadi::SharedObject const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_SharedObject(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObject *arg1 = (casadi::SharedObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObject, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SharedObject" "', argument " "1"" of type '" "casadi::SharedObject *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObject * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SharedObject_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__SharedObject, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SharedObject_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_WeakRef__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  int arg1 = (int) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  casadi::WeakRef *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 1)) SWIG_fail;
  if (swig_obj[0]) {
    ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
    if (!SWIG_IsOK(ecode1)) {
      SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_WeakRef" "', argument " "1"" of type '" "int""'");
    } 
    arg1 = static_cast< int >(val1);
  }
  {
    try {
      result = (casadi::WeakRef *)new casadi::WeakRef(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__WeakRef, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_WeakRef__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SharedObject arg1 ;
  void *argp1 ;
  int res1 = 0 ;
  casadi::WeakRef *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__SharedObject,  0  | 0);
    if (!SWIG_IsOK(res1)) {
      SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WeakRef" "', argument " "1"" of type '" "casadi::SharedObject""'"); 
    }  
    if (!argp1) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WeakRef" "', argument " "1"" of type '" "casadi::SharedObject""'");
    } else {
      casadi::SharedObject * temp = reinterpret_cast< casadi::SharedObject * >(argp1);
      arg1 = *temp;
      if (SWIG_IsNewObj(res1)) delete temp;
    }
  }
  {
    try {
      result = (casadi::WeakRef *)new casadi::WeakRef(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__WeakRef, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_WeakRef_shared(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::WeakRef *arg1 = (casadi::WeakRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::SharedObject result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__WeakRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WeakRef_shared" "', argument " "1"" of type '" "casadi::WeakRef *""'"); 
  }
  arg1 = reinterpret_cast< casadi::WeakRef * >(argp1);
  {
    try {
      result = (arg1)->shared();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::SharedObject(static_cast< const casadi::SharedObject& >(result))), SWIGTYPE_p_casadi__SharedObject, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_WeakRef_alive(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::WeakRef *arg1 = (casadi::WeakRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__WeakRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "WeakRef_alive" "', argument " "1"" of type '" "casadi::WeakRef const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::WeakRef * >(argp1);
  {
    try {
      result = (bool)((casadi::WeakRef const *)arg1)->alive();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_WeakRef__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::WeakRef *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::WeakRef *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__WeakRef,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_WeakRef" "', argument " "1"" of type '" "casadi::WeakRef const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_WeakRef" "', argument " "1"" of type '" "casadi::WeakRef const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::WeakRef * >(argp1);
  {
    result = (casadi::WeakRef *)new casadi::WeakRef((casadi::WeakRef const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__WeakRef, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_WeakRef(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_WeakRef", 0, 1, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 1)) {
    int _v;
    if (argc <= 0) {
      return _wrap_new_WeakRef__SWIG_0(self, argc, argv);
    }
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_WeakRef__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__WeakRef, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_WeakRef__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__SharedObject, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_WeakRef__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_WeakRef'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::WeakRef::WeakRef(int)\n"
    "    casadi::WeakRef::WeakRef(casadi::SharedObject)\n"
    "    casadi::WeakRef::WeakRef(casadi::WeakRef const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_WeakRef(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::WeakRef *arg1 = (casadi::WeakRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__WeakRef, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_WeakRef" "', argument " "1"" of type '" "casadi::WeakRef *""'"); 
  }
  arg1 = reinterpret_cast< casadi::WeakRef * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *WeakRef_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__WeakRef, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *WeakRef_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_complement(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  casadi_int arg2 ;
  std::vector< casadi_int > m1 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "complement", 2, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = casadi::complement((std::vector< long long,std::allocator< long long > > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lookupvector__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  casadi_int arg2 ;
  std::vector< casadi_int > m1 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = casadi::lookupvector((std::vector< long long,std::allocator< long long > > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lookupvector__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int > m1 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::lookupvector((std::vector< long long,std::allocator< long long > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lookupvector(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "lookupvector", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi_int> **>(0));
    if (_v) {
      return _wrap_lookupvector__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi_int> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_lookupvector__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'lookupvector'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::lookupvector(std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi_int)\n"
    "    casadi::lookupvector(std::vector< casadi_int,std::allocator< casadi_int > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_temporary_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "temporary_file", 2, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = casadi::temporary_file((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_normalized_setup__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::istream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "normalized_setup" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "normalized_setup" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  {
    try {
      casadi::normalized_setup(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_normalized_setup__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  
  arg1 = &casadi::uout();
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      casadi::normalized_setup(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_normalized_setup(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "normalized_setup", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_normalized_setup__SWIG_1(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_normalized_setup__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'normalized_setup'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::normalized_setup(std::istream &)\n"
    "    casadi::normalized_setup(std::ostream &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_normalized_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::ostream *arg1 = 0 ;
  double arg2 ;
  PyObject *swig_obj[1] ;
  
  arg1 = &casadi::uout();
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      casadi::normalized_out(*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_normalized_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::istream *arg1 = 0 ;
  double *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "normalized_in", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "normalized_in" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "normalized_in" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_double,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "normalized_in" "', argument " "2"" of type '" "double &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "normalized_in" "', argument " "2"" of type '" "double &""'"); 
  }
  arg2 = reinterpret_cast< double * >(argp2);
  {
    try {
      result = (int)casadi::normalized_in(*arg1,*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenericType_serialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericType *arg1 = (casadi::GenericType *) 0 ;
  casadi::SerializingStream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "GenericType_serialize", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericType, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenericType_serialize" "', argument " "1"" of type '" "casadi::GenericType const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericType * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__SerializingStream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "GenericType_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenericType_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  arg2 = reinterpret_cast< casadi::SerializingStream * >(argp2);
  {
    try {
      ((casadi::GenericType const *)arg1)->serialize(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenericType_deserialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializingStream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::GenericType result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__DeserializingStream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenericType_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "GenericType_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializingStream * >(argp1);
  {
    try {
      result = casadi::GenericType::deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "GenericType" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenericType__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::GenericType *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::GenericType *)new casadi::GenericType();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenericType__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericType *arg1 = 0 ;
  casadi::GenericType m1 ;
  casadi::GenericType *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "GenericType" "'.");
  {
    result = (casadi::GenericType *)new casadi::GenericType((casadi::GenericType const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericType, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenericType(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_GenericType", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_GenericType__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::GenericType **>(0));
    if (_v) {
      return _wrap_new_GenericType__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_GenericType'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericType::GenericType()\n"
    "    casadi::GenericType::GenericType(casadi::GenericType const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_GenericType(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericType *arg1 = (casadi::GenericType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericType, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GenericType" "', argument " "1"" of type '" "casadi::GenericType *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericType * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GenericType_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__GenericType, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GenericType_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SparsityInterfaceCommon__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::SparsityInterfaceCommon *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::SparsityInterfaceCommon *)new casadi::SparsityInterfaceCommon();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__SparsityInterfaceCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SparsityInterfaceCommon__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SparsityInterfaceCommon *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::SparsityInterfaceCommon *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__SparsityInterfaceCommon,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_SparsityInterfaceCommon" "', argument " "1"" of type '" "casadi::SparsityInterfaceCommon const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_SparsityInterfaceCommon" "', argument " "1"" of type '" "casadi::SparsityInterfaceCommon const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::SparsityInterfaceCommon * >(argp1);
  {
    result = (casadi::SparsityInterfaceCommon *)new casadi::SparsityInterfaceCommon((casadi::SparsityInterfaceCommon const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__SparsityInterfaceCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SparsityInterfaceCommon(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_SparsityInterfaceCommon", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_SparsityInterfaceCommon__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__SparsityInterfaceCommon, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_SparsityInterfaceCommon__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_SparsityInterfaceCommon'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::SparsityInterfaceCommon::SparsityInterfaceCommon()\n"
    "    casadi::SparsityInterfaceCommon::SparsityInterfaceCommon(casadi::SparsityInterfaceCommon const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_SparsityInterfaceCommon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SparsityInterfaceCommon *arg1 = (casadi::SparsityInterfaceCommon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SparsityInterfaceCommon, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SparsityInterfaceCommon" "', argument " "1"" of type '" "casadi::SparsityInterfaceCommon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SparsityInterfaceCommon * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SparsityInterfaceCommon_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__SparsityInterfaceCommon, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SparsityInterfaceCommon_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Sparsity__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 0 ;
  casadi::Sparsity *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 1)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  {
    try {
      result = (casadi::Sparsity *)new casadi::Sparsity(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Sparsity, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Sparsity__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  casadi::Sparsity *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi::Sparsity *)new casadi::Sparsity(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Sparsity, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Sparsity__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  bool arg5 = (bool) false ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  casadi::Sparsity *result = 0 ;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = (casadi::Sparsity *)new casadi::Sparsity(arg1,arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Sparsity, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Sparsity__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Sparsity *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = (casadi::Sparsity *)new casadi::Sparsity((std::pair< casadi_int,casadi_int > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Sparsity, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool arg1 = (bool) true ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_scalar", 0, 1, swig_obj)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::Sparsity::scalar(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_dense__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::Sparsity::dense(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_dense__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Sparsity::dense((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_dense(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_dense", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_Sparsity_dense__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Sparsity_dense__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_Sparsity_dense__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_dense'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::dense(casadi_int,casadi_int)\n"
    "    casadi::Sparsity::dense(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_unit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_unit", 2, 2, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = casadi::Sparsity::unit(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_upper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::Sparsity::upper(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_lower(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::Sparsity::lower(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_diag__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::Sparsity::diag(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_diag__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  casadi::Sparsity result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = casadi::Sparsity::diag(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_diag__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Sparsity::diag((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_diag(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_diag", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_Sparsity_diag__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_Sparsity_diag__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Sparsity_diag__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_diag'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::diag(casadi_int)\n"
    "    casadi::Sparsity::diag(casadi_int,casadi_int)\n"
    "    casadi::Sparsity::diag(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_band(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_band", 2, 2, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = casadi::Sparsity::band(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_banded(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_banded", 2, 2, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = casadi::Sparsity::banded(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_rowcol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  std::vector< casadi_int > m1 ;
  std::vector< casadi_int > m2 ;
  PyObject *swig_obj[4] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_rowcol", 4, 4, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      result = casadi::Sparsity::rowcol((std::vector< long long,std::allocator< long long > > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_triplet__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  bool arg6 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  casadi::Sparsity result;
  
  arg5 = &m5;
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  if (!casadi::to_val(swig_obj[4], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "bool" "'.");
  {
    try {
      result = casadi::Sparsity::triplet(arg1,arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,*arg5,arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg5));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_triplet__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  casadi::Sparsity result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::Sparsity::triplet(arg1,arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_triplet(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_triplet", 0, 5, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            return _wrap_Sparsity_triplet__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< bool **>(0));
            if (_v) {
              return _wrap_Sparsity_triplet__SWIG_0(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_triplet'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::triplet(casadi_int,casadi_int,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > &,bool)\n"
    "    casadi::Sparsity::triplet(casadi_int,casadi_int,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_nonzeros(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  std::vector< casadi_int > m3 ;
  PyObject *swig_obj[4] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_nonzeros", 3, 4, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::Sparsity::nonzeros(arg1,arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_compressed(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  bool arg2 = (bool) false ;
  std::vector< casadi_int > m1 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_compressed", 1, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::Sparsity::compressed((std::vector< long long,std::allocator< long long > > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_diag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  arg2 = &m2;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_diag" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->get_diag(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_compress(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_compress" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->compress();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_equal__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_equal" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_equal((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_equal__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  bool result;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_equal" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_equal(arg2,arg3,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg4,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_equal(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_is_equal", 0, 5, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_Sparsity_is_equal__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              return _wrap_Sparsity_is_equal__SWIG_1(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_is_equal'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::is_equal(casadi::Sparsity const &) const\n"
    "    casadi::Sparsity::is_equal(casadi_int,casadi_int,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity___eq__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity___eq__" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->operator ==((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_Sparsity___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity___ne__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity___ne__" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->operator !=((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_stacked(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[3] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_is_stacked", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_stacked" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_stacked((casadi::Sparsity const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_size1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_size1" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->size1();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_rows(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_rows" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->rows();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_size2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_size2" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->size2();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_columns(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_columns" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->columns();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_numel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_numel" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->numel();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_density(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_density" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (double)((casadi::Sparsity const *)arg1)->density();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_is_empty", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_empty" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_empty(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_nnz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_nnz" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->nnz();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_nnz_upper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_nnz_upper", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_nnz_upper" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->nnz_upper(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_nnz_lower(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_nnz_lower", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_nnz_lower" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->nnz_lower(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_nnz_diag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_nnz_diag" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->nnz_diag();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_bw_upper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_bw_upper" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->bw_upper();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_bw_lower(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_bw_lower" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->bw_lower();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_size__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::pair< casadi_int,casadi_int > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_size" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->size();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "(" "int" "," "int" ")" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_size__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_size" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->size(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_size(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_size", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Sparsity_size__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Sparsity_size__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_size'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::size() const\n"
    "    casadi::Sparsity::size(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_info" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->info();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_to_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::string *arg2 = 0 ;
  std::string const &arg3_defvalue = "" ;
  std::string *arg3 = (std::string *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_to_file", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_to_file" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  }
  {
    try {
      ((casadi::Sparsity const *)arg1)->to_file((std::string const &)*arg2,(std::string const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string const &arg2_defvalue = "" ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_from_file", 1, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  {
    try {
      result = casadi::Sparsity::from_file((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_serialize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_serialize" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->serialize();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_deserialize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::istream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_deserialize" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Sparsity_deserialize" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  {
    try {
      result = casadi::Sparsity::deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_deserialize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::Sparsity::deserialize((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_serialize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::SerializingStream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_serialize" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__SerializingStream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Sparsity_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Sparsity_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  arg2 = reinterpret_cast< casadi::SerializingStream * >(argp2);
  {
    try {
      ((casadi::Sparsity const *)arg1)->serialize(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_serialize(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_serialize", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Sparsity_serialize__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_casadi__SerializingStream, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Sparsity_serialize__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_serialize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::serialize() const\n"
    "    casadi::Sparsity::serialize(casadi::SerializingStream &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_deserialize__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DeserializingStream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__DeserializingStream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Sparsity_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializingStream * >(argp1);
  {
    try {
      result = casadi::Sparsity::deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_deserialize(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_deserialize", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Sparsity_deserialize__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DeserializingStream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Sparsity_deserialize__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      return _wrap_Sparsity_deserialize__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_deserialize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::deserialize(std::istream &)\n"
    "    casadi::Sparsity::deserialize(std::string const &)\n"
    "    casadi::Sparsity::deserialize(casadi::DeserializingStream &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_row__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_row" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->get_row();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_colind__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_colind" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->get_colind();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_colind__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_colind" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->colind(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_colind(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_colind", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Sparsity_colind__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Sparsity_colind__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_colind'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::get_colind() const\n"
    "    casadi::Sparsity::colind(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_row__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_row" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->row(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_row(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_row", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Sparsity_row__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Sparsity_row__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_row'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::get_row() const\n"
    "    casadi::Sparsity::row(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_col(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_col" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->get_col();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_resize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_resize", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_resize" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      (arg1)->resize(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_add_nz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_add_nz", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_add_nz" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)(arg1)->add_nz(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_nz__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_nz" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->get_nz(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_has_nz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_has_nz", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_has_nz" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->has_nz(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_nz__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_nz" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->get_nz((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_nz__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_nz" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "int" "]" "'.");
  {
    try {
      ((casadi::Sparsity const *)arg1)->get_nz(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_nz(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_get_nz", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_Sparsity_get_nz__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_Sparsity_get_nz__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          return _wrap_Sparsity_get_nz__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_get_nz'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::get_nz(casadi_int,casadi_int) const\n"
    "    casadi::Sparsity::get_nz(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &) const\n"
    "    casadi::Sparsity::get_nz(std::vector< casadi_int,std::allocator< casadi_int > > &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_lower(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_lower" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->get_lower();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_upper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_upper" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->get_upper();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_ccs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &m2;
  arg3 = &m3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_ccs" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      ((casadi::Sparsity const *)arg1)->get_ccs(*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_crs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &m2;
  arg3 = &m3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_crs" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      ((casadi::Sparsity const *)arg1)->get_crs(*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_get_triplet(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &m2;
  arg3 = &m3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_get_triplet" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      ((casadi::Sparsity const *)arg1)->get_triplet(*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_sub__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  casadi::Sparsity result;
  
  arg4 = &m4;
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_sub" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->sub((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_sub__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Sparsity *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  casadi::Sparsity m3 ;
  std::vector< casadi_int > m4 ;
  casadi::Sparsity result;
  
  arg4 = &m4;
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_sub" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "Sparsity" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->sub((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,(casadi::Sparsity const &)*arg3,*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_sub(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_sub", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Sparsity **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Sparsity_sub__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Sparsity_sub__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Sparsity_sub__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Sparsity_sub__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_sub'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::sub(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > &,bool) const\n"
    "    casadi::Sparsity::sub(std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi::Sparsity const &,std::vector< casadi_int,std::allocator< casadi_int > > &,bool) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_transpose(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  arg2 = &m2;
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_transpose", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_transpose" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->transpose(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_transpose(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_is_transpose", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_transpose" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_transpose((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_reshape(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_is_reshape", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_reshape" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_reshape((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_combine(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[4] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_combine", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_combine" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->combine((casadi::Sparsity const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_unite(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_unite", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_unite" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->unite((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity___add__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity___add__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity___add__" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->operator +((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_Sparsity_intersect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_intersect", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_intersect" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->intersect((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity___mul__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity___mul__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity___mul__" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->operator *((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_subset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_is_subset", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_subset" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_subset((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_pattern_inverse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_pattern_inverse" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->pattern_inverse();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_enlarge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  bool arg6 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_enlarge", 5, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_enlarge" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  if (swig_obj[5]) {
    if (!casadi::to_val(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->enlarge(arg2,arg3,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg4,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg5,arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_enlargeRows(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m3 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_enlargeRows", 3, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_enlargeRows" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->enlargeRows(arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_enlargeColumns(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m3 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_enlargeColumns", 3, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_enlargeColumns" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->enlargeColumns(arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_makeDense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  arg2 = &m2;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_makeDense" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->makeDense(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_erase" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = (arg1)->erase((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_erase" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = (arg1)->erase((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_erase(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Sparsity_erase", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Sparsity_erase__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_Sparsity_erase__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Sparsity, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Sparsity_erase__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Sparsity_erase__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Sparsity_erase'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::erase(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n"
    "    casadi::Sparsity::erase(std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Sparsity_append(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_append", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_append" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      (arg1)->append((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_appendColumns(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_appendColumns", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_appendColumns" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      (arg1)->appendColumns((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_is_scalar", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_scalar" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_scalar(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_dense" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_dense();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_row" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_row();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_column" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_column();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_vector" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_diag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_diag" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_diag();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_square(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_square" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_square();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_symmetric(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_symmetric" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_symmetric();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_triu(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_triu" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_triu();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_tril(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_tril" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_tril();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_is_singular(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_is_singular" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->is_singular();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_rowsSequential(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  bool arg2 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_rowsSequential", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_rowsSequential" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::Sparsity const *)arg1)->rowsSequential(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_removeDuplicates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_removeDuplicates", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_removeDuplicates" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "int" "]" "'.");
  {
    try {
      (arg1)->removeDuplicates(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_etree(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_etree", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_etree" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->etree(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_ldl(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  PyObject *swig_obj[2] ;
  casadi::Sparsity result;
  
  arg2 = &m2;
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_ldl", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_ldl" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->ldl(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_qr_sparse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::Sparsity *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  bool arg6 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  casadi::Sparsity m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  arg5 = &m5;
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_qr_sparse", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_qr_sparse" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Sparsity const *)arg1)->qr_sparse(*arg2,*arg3,*arg4,*arg5,arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg5));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_dfs(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< bool,std::allocator< bool > > *arg7 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< bool > m7 ;
  PyObject *swig_obj[7] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_dfs", 7, 7, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_dfs" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  arg7 = &m7;
  if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "bool" "]" "'.");
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->dfs(arg2,arg3,*arg4,*arg5,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg6,*arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg5));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg7));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_scc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  arg2 = &m2;
  arg3 = &m3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_scc" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->scc(*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_btf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg7 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< casadi_int > m7 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  arg5 = &m5;
  arg6 = &m6;
  arg7 = &m7;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_btf" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Sparsity const *)arg1)->btf(*arg2,*arg3,*arg4,*arg5,*arg6,*arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg5));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg6));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg7));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_amd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_amd" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->amd();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_find(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_find", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_find" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->find(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_uni_coloring(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi::Sparsity const &arg2_defvalue = casadi::Sparsity() ;
  casadi::Sparsity *arg2 = (casadi::Sparsity *) &arg2_defvalue ;
  casadi_int arg3 = (casadi_int) std::numeric_limits< casadi_int >::max() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[3] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_uni_coloring", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_uni_coloring" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->uni_coloring((casadi::Sparsity const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_star_coloring(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) std::numeric_limits< casadi_int >::max() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_star_coloring", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_star_coloring" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->star_coloring(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_star_coloring2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) std::numeric_limits< casadi_int >::max() ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_star_coloring2", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_star_coloring2" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->star_coloring2(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_largest_first(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_largest_first" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->largest_first();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_pmult(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  bool arg3 = (bool) true ;
  bool arg4 = (bool) true ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  PyObject *swig_obj[5] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_pmult", 2, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_pmult" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->pmult((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_dim(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_dim", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_dim" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->dim(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_postfix_dim(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_postfix_dim" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->postfix_dim();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_repr_el(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_repr_el", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_repr_el" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->repr_el(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_spy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::ostream &arg2_defvalue = casadi::uout() ;
  std::ostream *arg2 = (std::ostream *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &casadi::uout();
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_spy" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      ((casadi::Sparsity const *)arg1)->spy(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_spy_matlab(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_spy_matlab", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_spy_matlab" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      ((casadi::Sparsity const *)arg1)->spy_matlab((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_export_code(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  std::string *arg2 = 0 ;
  std::ostream &arg3_defvalue = casadi::uout() ;
  std::ostream *arg3 = (std::ostream *) &arg3_defvalue ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[3] ;
  
  arg3 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_export_code", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_export_code" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      ((casadi::Sparsity const *)arg1)->export_code((std::string const &)*arg2,*arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_type_name", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::Sparsity::type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_hash(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_hash" "', argument " "1"" of type '" "casadi::Sparsity const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    try {
      result = ((casadi::Sparsity const *)arg1)->hash();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_test_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObjectInternal *arg1 = (casadi::SharedObjectInternal *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObjectInternal, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Sparsity_test_cast" "', argument " "1"" of type '" "casadi::SharedObjectInternal const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObjectInternal * >(argp1);
  {
    try {
      result = (bool)casadi::Sparsity::test_cast((casadi::SharedObjectInternal const *)arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Sparsity_kkt(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  bool arg3 = (bool) true ;
  bool arg4 = (bool) true ;
  casadi::Sparsity m1 ;
  casadi::Sparsity m2 ;
  PyObject *swig_obj[4] ;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Sparsity_kkt", 2, 4, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::Sparsity::kkt((casadi::Sparsity const &)*arg1,(casadi::Sparsity const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Sparsity__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    result = (casadi::Sparsity *)new casadi::Sparsity((casadi::Sparsity const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Sparsity, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Sparsity(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Sparsity", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 1)) {
    int _v;
    if (argc <= 0) {
      return _wrap_new_Sparsity__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_new_Sparsity__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_new_Sparsity__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_new_Sparsity__SWIG_4(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_new_Sparsity__SWIG_1(self, argc, argv);
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_new_Sparsity__SWIG_2(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< bool **>(0));
            if (_v) {
              return _wrap_new_Sparsity__SWIG_2(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Sparsity'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Sparsity::Sparsity(casadi_int)\n"
    "    casadi::Sparsity::Sparsity(casadi_int,casadi_int)\n"
    "    casadi::Sparsity::Sparsity(casadi_int,casadi_int,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n"
    "    casadi::Sparsity::Sparsity(std::pair< casadi_int,casadi_int > const &)\n"
    "    casadi::Sparsity::Sparsity(casadi::Sparsity const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = (casadi::Sparsity *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Sparsity, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Sparsity" "', argument " "1"" of type '" "casadi::Sparsity *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Sparsity * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Sparsity_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__Sparsity, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Sparsity_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_hash_combine__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::size_t *arg1 = 0 ;
  casadi_int *arg2 = (casadi_int *) 0 ;
  std::size_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  size_t val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_std__size_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "hash_combine" "', argument " "1"" of type '" "std::size_t &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "hash_combine" "', argument " "1"" of type '" "std::size_t &""'"); 
  }
  arg1 = reinterpret_cast< std::size_t * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "hash_combine" "', argument " "2"" of type '" "casadi_int const *""'"); 
  }
  arg2 = reinterpret_cast< casadi_int * >(argp2);
  ecode3 = SWIG_AsVal_size_t(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "hash_combine" "', argument " "3"" of type '" "std::size_t""'");
  } 
  arg3 = static_cast< std::size_t >(val3);
  {
    try {
      casadi::hash_combine(*arg1,(long long const *)arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_hash_combine__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::size_t *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_std__size_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "hash_combine" "', argument " "1"" of type '" "std::size_t &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "hash_combine" "', argument " "1"" of type '" "std::size_t &""'"); 
  }
  arg1 = reinterpret_cast< std::size_t * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      casadi::hash_combine(*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_hash_combine(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "hash_combine", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__size_t, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_hash_combine__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__size_t, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_long_long, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        {
          int res = SWIG_AsVal_size_t(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_hash_combine__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'hash_combine'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::hash_combine(std::size_t &,casadi_int const *,std::size_t)\n"
    "    casadi::hash_combine(std::size_t &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_hash_sparsity__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  std::size_t result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::hash_sparsity(arg1,arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_hash_sparsity__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  casadi_int *arg3 = (casadi_int *) 0 ;
  casadi_int *arg4 = (casadi_int *) 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  std::size_t result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "hash_sparsity" "', argument " "3"" of type '" "casadi_int const *""'"); 
  }
  arg3 = reinterpret_cast< casadi_int * >(argp3);
  res4 = SWIG_ConvertPtr(swig_obj[3], &argp4,SWIGTYPE_p_long_long, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "hash_sparsity" "', argument " "4"" of type '" "casadi_int const *""'"); 
  }
  arg4 = reinterpret_cast< casadi_int * >(argp4);
  {
    try {
      result = casadi::hash_sparsity(arg1,arg2,(long long const *)arg3,(long long const *)arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_hash_sparsity(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "hash_sparsity", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        void *vptr = 0;
        int res = SWIG_ConvertPtr(argv[2], &vptr, SWIGTYPE_p_long_long, 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          void *vptr = 0;
          int res = SWIG_ConvertPtr(argv[3], &vptr, SWIGTYPE_p_long_long, 0);
          _v = SWIG_CheckState(res);
          if (_v) {
            return _wrap_hash_sparsity__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            return _wrap_hash_sparsity__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'hash_sparsity'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::hash_sparsity(casadi_int,casadi_int,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::hash_sparsity(casadi_int,casadi_int,casadi_int const *,casadi_int const *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Slice_start_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_start_get" "', argument " "1"" of type '" "casadi::Slice *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  result = (casadi_int) ((arg1)->start);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_stop_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_stop_get" "', argument " "1"" of type '" "casadi::Slice *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  result = (casadi_int) ((arg1)->stop);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_step_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_step_get" "', argument " "1"" of type '" "casadi::Slice *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  result = (casadi_int) ((arg1)->step);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Slice__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::Slice *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::Slice *)new casadi::Slice();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Slice, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Slice__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  bool arg2 = (bool) false ;
  casadi::Slice *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (casadi::Slice *)new casadi::Slice(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Slice, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Slice__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::Slice *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (casadi::Slice *)new casadi::Slice(arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Slice, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Slice__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  int arg1 ;
  int arg2 ;
  int arg3 = (int) 1 ;
  int val1 ;
  int ecode1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  casadi::Slice *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Slice" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Slice" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Slice" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  {
    try {
      result = (casadi::Slice *)new casadi::Slice(arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Slice, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Slice__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  int arg1 ;
  casadi_int arg2 ;
  int arg3 = (int) 1 ;
  int val1 ;
  int ecode1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  casadi::Slice *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_Slice" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Slice" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  {
    try {
      result = (casadi::Slice *)new casadi::Slice(arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Slice, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Slice__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  int arg2 ;
  int arg3 = (int) 1 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  casadi::Slice *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "new_Slice" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (swig_obj[2]) {
    ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "new_Slice" "', argument " "3"" of type '" "int""'");
    } 
    arg3 = static_cast< int >(val3);
  }
  {
    try {
      result = (casadi::Slice *)new casadi::Slice(arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Slice, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_all__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_all" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  {
    try {
      result = ((casadi::Slice const *)arg1)->all();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_all__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi_int arg2 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_all" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Slice const *)arg1)->all(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_all__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi::Slice *arg2 = 0 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Slice m2 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_all" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Slice" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Slice const *)arg1)->all((casadi::Slice const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_all(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Slice_all", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Slice, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Slice_all__SWIG_0(self, argc, argv);
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Slice, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Slice_all__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_Slice_all__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Slice, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Slice **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_Slice_all__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Slice_all'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Slice::all() const\n"
    "    casadi::Slice::all(casadi_int,bool) const\n"
    "    casadi::Slice::all(casadi::Slice const &,casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Slice_size(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_size" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  {
    try {
      result = ((casadi::Slice const *)arg1)->size();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_is_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_is_empty" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  {
    try {
      result = (bool)((casadi::Slice const *)arg1)->is_empty();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_is_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Slice_is_scalar", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_is_scalar" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::Slice const *)arg1)->is_scalar(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Slice_scalar", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_scalar" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Slice const *)arg1)->scalar(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice___eq__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi::Slice *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Slice m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Slice___eq__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice___eq__" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Slice" "'.");
  {
    try {
      result = (bool)((casadi::Slice const *)arg1)->operator ==((casadi::Slice const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_Slice___ne__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi::Slice *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Slice m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Slice___ne__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice___ne__" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Slice" "'.");
  {
    try {
      result = (bool)((casadi::Slice const *)arg1)->operator !=((casadi::Slice const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_Slice_apply(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi_int arg2 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  casadi::Slice result;
  
  if (!SWIG_Python_UnpackTuple(args, "Slice_apply", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_apply" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Slice const *)arg1)->apply(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Slice" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice___sub__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::Slice result;
  
  if (!SWIG_Python_UnpackTuple(args, "Slice___sub__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice___sub__" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Slice const *)arg1)->operator -(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Slice" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_Slice___mul__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::Slice result;
  
  if (!SWIG_Python_UnpackTuple(args, "Slice___mul__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice___mul__" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Slice const *)arg1)->operator *(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Slice" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_Slice_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_type_name" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  {
    try {
      result = ((casadi::Slice const *)arg1)->type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "Slice_disp", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_disp" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Slice const *)arg1)->disp(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Slice_str", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_str" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Slice const *)arg1)->get_str(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_info" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  {
    try {
      result = ((casadi::Slice const *)arg1)->info();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_serialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  casadi::SerializingStream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Slice_serialize", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_serialize" "', argument " "1"" of type '" "casadi::Slice const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__SerializingStream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Slice_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Slice_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  arg2 = reinterpret_cast< casadi::SerializingStream * >(argp2);
  {
    try {
      ((casadi::Slice const *)arg1)->serialize(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Slice_deserialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializingStream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Slice result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__DeserializingStream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Slice_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Slice_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializingStream * >(argp1);
  {
    try {
      result = casadi::Slice::deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Slice" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Slice__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = 0 ;
  casadi::Slice m1 ;
  casadi::Slice *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Slice" "'.");
  {
    result = (casadi::Slice *)new casadi::Slice((casadi::Slice const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Slice, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Slice(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Slice", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_Slice__SWIG_0(self, argc, argv);
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_new_Slice__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_new_Slice__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Slice **>(0));
    if (_v) {
      return _wrap_new_Slice__SWIG_6(self, argc, argv);
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        if (argc <= 2) {
          return _wrap_new_Slice__SWIG_3(self, argc, argv);
        }
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Slice__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    {
      int res = SWIG_AsVal_int(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_new_Slice__SWIG_4(self, argc, argv);
        }
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Slice__SWIG_4(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      {
        int res = SWIG_AsVal_int(argv[1], NULL);
        _v = SWIG_CheckState(res);
      }
      if (_v) {
        if (argc <= 2) {
          return _wrap_new_Slice__SWIG_5(self, argc, argv);
        }
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_new_Slice__SWIG_5(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_new_Slice__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_new_Slice__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Slice'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Slice::Slice()\n"
    "    casadi::Slice::Slice(casadi_int,bool)\n"
    "    casadi::Slice::Slice(casadi_int,casadi_int,casadi_int)\n"
    "    casadi::Slice::Slice(int,int,int)\n"
    "    casadi::Slice::Slice(int,casadi_int,int)\n"
    "    casadi::Slice::Slice(casadi_int,int,int)\n"
    "    casadi::Slice::Slice(casadi::Slice const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Slice(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Slice *arg1 = (casadi::Slice *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Slice, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Slice" "', argument " "1"" of type '" "casadi::Slice *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Slice * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Slice_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__Slice, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Slice_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_to_slice(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  bool arg2 = (bool) false ;
  std::vector< casadi_int > m1 ;
  PyObject *swig_obj[2] ;
  casadi::Slice result;
  
  if (!SWIG_Python_UnpackTuple(args, "to_slice", 1, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::to_slice((std::vector< long long,std::allocator< long long > > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Slice" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_to_slice2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int > m1 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< std::pair< casadi::Slice,casadi::Slice > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::to_slice2((std::vector< long long,std::allocator< long long > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new std::pair< casadi::Slice,casadi::Slice >(static_cast< const std::pair< casadi::Slice,casadi::Slice >& >(result))), SWIGTYPE_p_std__pairT_casadi__Slice_casadi__Slice_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_slice(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  bool arg2 = (bool) false ;
  std::vector< casadi_int > m1 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "is_slice", 1, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)casadi::is_slice((std::vector< long long,std::allocator< long long > > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_slice2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int > m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  {
    try {
      result = (bool)casadi::is_slice2((std::vector< long long,std::allocator< long long > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenericMatrixCommon__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::GenericMatrixCommon *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::GenericMatrixCommon *)new casadi::GenericMatrixCommon();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericMatrixCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenericMatrixCommon__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrixCommon *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::GenericMatrixCommon *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__GenericMatrixCommon,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GenericMatrixCommon" "', argument " "1"" of type '" "casadi::GenericMatrixCommon const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenericMatrixCommon" "', argument " "1"" of type '" "casadi::GenericMatrixCommon const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrixCommon * >(argp1);
  {
    result = (casadi::GenericMatrixCommon *)new casadi::GenericMatrixCommon((casadi::GenericMatrixCommon const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericMatrixCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenericMatrixCommon(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_GenericMatrixCommon", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_GenericMatrixCommon__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__GenericMatrixCommon, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_GenericMatrixCommon__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_GenericMatrixCommon'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrixCommon::GenericMatrixCommon()\n"
    "    casadi::GenericMatrixCommon::GenericMatrixCommon(casadi::GenericMatrixCommon const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_GenericMatrixCommon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrixCommon *arg1 = (casadi::GenericMatrixCommon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixCommon, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GenericMatrixCommon" "', argument " "1"" of type '" "casadi::GenericMatrixCommon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrixCommon * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GenericMatrixCommon_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__GenericMatrixCommon, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GenericMatrixCommon_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_index_interp1d(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< double,std::allocator< double > > *arg1 = 0 ;
  double arg2 ;
  bool arg3 = (bool) false ;
  std::vector< double > m1 ;
  PyObject *swig_obj[3] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "index_interp1d", 2, 3, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "float" "]" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = (double)casadi::index_interp1d((std::vector< double,std::allocator< double > > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_nnz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_nnz" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->nnz();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_nnz_lower(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_nnz_lower" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->nnz_lower();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_nnz_upper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_nnz_upper" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->nnz_upper();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_nnz_diag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_nnz_diag" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->nnz_diag();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_numel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_numel" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->numel();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_size1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_size1" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->size1();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_rows(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_rows" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->rows();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_size2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_size2" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->size2();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_columns(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_columns" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->columns();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_dim(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "GenDM_dim", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_dim" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->dim(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_size__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::pair< casadi_int,casadi_int > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_size" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->size();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "(" "int" "," "int" ")" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_size__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_size" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->size(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_size(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenDM_size", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_GenDM_size__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenDM_size__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenDM_size'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::size() const\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::size(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenDM_is_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "GenDM_is_empty", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_is_empty" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->is_empty(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_is_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_is_dense" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->is_dense();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_is_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "GenDM_is_scalar", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_is_scalar" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->is_scalar(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_is_square(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_is_square" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->is_square();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_is_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_is_vector" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->is_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_is_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_is_row" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->is_row();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_is_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_is_column" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->is_column();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_is_triu(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_is_triu" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->is_triu();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_is_tril(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_is_tril" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->is_tril();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_row__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_row" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->get_row();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_colind__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_colind" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->get_colind();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_row__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_row" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->row(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_row(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenDM_row", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_GenDM_row__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenDM_row__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenDM_row'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::get_row() const\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::row(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenDM_colind__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_colind" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->colind(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_colind(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenDM_colind", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_GenDM_colind__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenDM_colind__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenDM_colind'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::get_colind() const\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::colind(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenDM_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenDM_sparsity" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< double > > const *)arg1)->sparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_sym__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) 1 ;
  std::string m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_sym__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > *arg2 = 0 ;
  std::string m1 ;
  std::pair< casadi_int,casadi_int > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(std::pair< long long,long long > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_sym__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_sym__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi_int arg3 ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(casadi::Sparsity const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_sym__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  std::string m1 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_sym__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(casadi::Sparsity const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "DM" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_sym__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  casadi_int arg5 ;
  std::string m1 ;
  std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > result;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,arg2,arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "DM" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_sym(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenDM_sym", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_GenDM_sym__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_GenDM_sym__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_GenDM_sym__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_GenDM_sym__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_GenDM_sym__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_GenDM_sym__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_GenDM_sym__SWIG_4(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_GenDM_sym__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              return _wrap_GenDM_sym__SWIG_6(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenDM_sym'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::sym(std::string const &,casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::sym(std::string const &,std::pair< casadi_int,casadi_int > const &)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::sym(std::string const &,casadi::Sparsity const &)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::sym(std::string const &,casadi::Sparsity const &,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::sym(std::string const &,casadi_int,casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::sym(std::string const &,casadi::Sparsity const &,casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::sym(std::string const &,casadi_int,casadi_int,casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenDM_zeros__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR zeros(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_zeros__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR zeros((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_zeros__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR zeros((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_zeros(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenDM_zeros", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_GenDM_zeros__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_GenDM_zeros__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenDM_zeros__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_GenDM_zeros__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_GenDM_zeros__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenDM_zeros'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::zeros(casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::zeros(casadi::Sparsity const &)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::zeros(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenDM_ones__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR ones(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_ones__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR ones((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_ones__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< double > >::SWIGTEMPLATEDISAMBIGUATOR ones((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenDM_ones(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenDM_ones", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_GenDM_ones__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_GenDM_ones__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenDM_ones__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_GenDM_ones__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_GenDM_ones__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenDM_ones'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::ones(casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::ones(casadi::Sparsity const &)\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::ones(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_new_GenDM__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::GenericMatrix< casadi::Matrix< double > > *)new casadi::GenericMatrix< casadi::Matrix< double > >();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenDM__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::GenericMatrix< casadi::Matrix< double > > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GenDM" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenDM" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    result = (casadi::GenericMatrix< casadi::Matrix< double > > *)new casadi::GenericMatrix< casadi::Matrix< double > >((casadi::GenericMatrix< casadi::Matrix< double > > const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenDM(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_GenDM", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_GenDM__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_GenDM__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_GenDM'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::GenericMatrix()\n"
    "    casadi::GenericMatrix< casadi::Matrix< double > >::GenericMatrix(casadi::GenericMatrix< casadi::Matrix< double > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_GenDM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< double > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< double > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GenDM" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< double > > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< double > > * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GenDM_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GenDM_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_GenSX_nnz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_nnz" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->nnz();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_nnz_lower(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_nnz_lower" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->nnz_lower();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_nnz_upper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_nnz_upper" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->nnz_upper();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_nnz_diag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_nnz_diag" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->nnz_diag();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_numel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_numel" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->numel();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_size1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_size1" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->size1();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_rows(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_rows" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->rows();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_size2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_size2" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->size2();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_columns(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_columns" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->columns();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_dim(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "GenSX_dim", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_dim" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->dim(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_size__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::pair< casadi_int,casadi_int > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_size" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->size();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "(" "int" "," "int" ")" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_size__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_size" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->size(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_size(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenSX_size", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_GenSX_size__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenSX_size__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenSX_size'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::size() const\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::size(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenSX_is_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "GenSX_is_empty", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_is_empty" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->is_empty(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_is_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_is_dense" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->is_dense();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_is_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "GenSX_is_scalar", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_is_scalar" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->is_scalar(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_is_square(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_is_square" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->is_square();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_is_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_is_vector" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->is_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_is_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_is_row" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->is_row();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_is_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_is_column" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->is_column();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_is_triu(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_is_triu" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->is_triu();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_is_tril(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_is_tril" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->is_tril();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_row__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_row" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->get_row();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_colind__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_colind" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->get_colind();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_row__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_row" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->row(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_row(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenSX_row", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_GenSX_row__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenSX_row__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenSX_row'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::get_row() const\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::row(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenSX_colind__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_colind" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->colind(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_colind(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenSX_colind", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_GenSX_colind__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenSX_colind__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenSX_colind'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::get_colind() const\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::colind(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenSX_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenSX_sparsity" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const *)arg1)->sparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_sym__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) 1 ;
  std::string m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_sym__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > *arg2 = 0 ;
  std::string m1 ;
  std::pair< casadi_int,casadi_int > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(std::pair< long long,long long > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_sym__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_sym__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi_int arg3 ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(casadi::Sparsity const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_sym__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  std::string m1 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_sym__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(casadi::Sparsity const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "SX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_sym__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  casadi_int arg5 ;
  std::string m1 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > result;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,arg2,arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "SX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_sym(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenSX_sym", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_GenSX_sym__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_GenSX_sym__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_GenSX_sym__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_GenSX_sym__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_GenSX_sym__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_GenSX_sym__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_GenSX_sym__SWIG_4(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_GenSX_sym__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              return _wrap_GenSX_sym__SWIG_6(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenSX_sym'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::sym(std::string const &,casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::sym(std::string const &,std::pair< casadi_int,casadi_int > const &)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::sym(std::string const &,casadi::Sparsity const &)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::sym(std::string const &,casadi::Sparsity const &,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::sym(std::string const &,casadi_int,casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::sym(std::string const &,casadi::Sparsity const &,casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::sym(std::string const &,casadi_int,casadi_int,casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenSX_zeros__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR zeros(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_zeros__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR zeros((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_zeros__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR zeros((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_zeros(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenSX_zeros", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_GenSX_zeros__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_GenSX_zeros__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenSX_zeros__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_GenSX_zeros__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_GenSX_zeros__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenSX_zeros'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::zeros(casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::zeros(casadi::Sparsity const &)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::zeros(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenSX_ones__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR ones(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_ones__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR ones((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_ones__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::SWIGTEMPLATEDISAMBIGUATOR ones((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenSX_ones(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenSX_ones", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_GenSX_ones__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_GenSX_ones__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenSX_ones__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_GenSX_ones__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_GenSX_ones__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenSX_ones'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::ones(casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::ones(casadi::Sparsity const &)\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::ones(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_new_GenSX__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *)new casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenSX__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GenSX" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenSX" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    result = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *)new casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenSX(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_GenSX", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_GenSX__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_GenSX__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_GenSX'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::GenericMatrix()\n"
    "    casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > >::GenericMatrix(casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_GenSX(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *arg1 = (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GenSX" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GenSX_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GenSX_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_GenMX_nnz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_nnz" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->nnz();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_nnz_lower(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_nnz_lower" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->nnz_lower();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_nnz_upper(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_nnz_upper" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->nnz_upper();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_nnz_diag(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_nnz_diag" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->nnz_diag();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_numel(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_numel" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->numel();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_size1(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_size1" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->size1();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_rows(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_rows" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->rows();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_size2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_size2" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->size2();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_columns(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_columns" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->columns();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_dim(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "GenMX_dim", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_dim" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::GenericMatrix< casadi::MX > const *)arg1)->dim(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_size__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::pair< casadi_int,casadi_int > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_size" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::MX > const *)arg1)->size();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "(" "int" "," "int" ")" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_size__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_size" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->size(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_size(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenMX_size", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_GenMX_size__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenMX_size__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenMX_size'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::MX >::size() const\n"
    "    casadi::GenericMatrix< casadi::MX >::size(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenMX_is_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "GenMX_is_empty", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_is_empty" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::MX > const *)arg1)->is_empty(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_is_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_is_dense" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::MX > const *)arg1)->is_dense();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_is_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "GenMX_is_scalar", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_is_scalar" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::MX > const *)arg1)->is_scalar(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_is_square(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_is_square" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::MX > const *)arg1)->is_square();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_is_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_is_vector" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::MX > const *)arg1)->is_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_is_row(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_is_row" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::MX > const *)arg1)->is_row();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_is_column(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_is_column" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::MX > const *)arg1)->is_column();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_is_triu(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_is_triu" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::MX > const *)arg1)->is_triu();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_is_tril(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_is_tril" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = (bool)((casadi::GenericMatrix< casadi::MX > const *)arg1)->is_tril();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_row__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_row" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::MX > const *)arg1)->get_row();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_colind__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_colind" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::MX > const *)arg1)->get_colind();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_row__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_row" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->row(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_row(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenMX_row", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_GenMX_row__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenMX_row__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenMX_row'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::MX >::get_row() const\n"
    "    casadi::GenericMatrix< casadi::MX >::row(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenMX_colind__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_colind" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::GenericMatrix< casadi::MX > const *)arg1)->colind(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_colind(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenMX_colind", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_GenMX_colind__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenMX_colind__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenMX_colind'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::MX >::get_colind() const\n"
    "    casadi::GenericMatrix< casadi::MX >::colind(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenMX_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "GenMX_sparsity" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    try {
      result = ((casadi::GenericMatrix< casadi::MX > const *)arg1)->sparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_sym__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) 1 ;
  std::string m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_sym__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > *arg2 = 0 ;
  std::string m1 ;
  std::pair< casadi_int,casadi_int > m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(std::pair< long long,long long > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_sym__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_sym__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi_int arg3 ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(casadi::Sparsity const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_sym__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  std::string m1 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_sym__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,(casadi::Sparsity const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "MX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_sym__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  casadi_int arg5 ;
  std::string m1 ;
  std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > result;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR sym((std::string const &)*arg1,arg2,arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "MX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_sym(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenMX_sym", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_GenMX_sym__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_GenMX_sym__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_GenMX_sym__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_GenMX_sym__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_GenMX_sym__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_GenMX_sym__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_GenMX_sym__SWIG_4(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_GenMX_sym__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              return _wrap_GenMX_sym__SWIG_6(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenMX_sym'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::MX >::sym(std::string const &,casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::MX >::sym(std::string const &,std::pair< casadi_int,casadi_int > const &)\n"
    "    casadi::GenericMatrix< casadi::MX >::sym(std::string const &,casadi::Sparsity const &)\n"
    "    casadi::GenericMatrix< casadi::MX >::sym(std::string const &,casadi::Sparsity const &,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::MX >::sym(std::string const &,casadi_int,casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::MX >::sym(std::string const &,casadi::Sparsity const &,casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::MX >::sym(std::string const &,casadi_int,casadi_int,casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenMX_zeros__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::MX result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR zeros(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_zeros__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR zeros((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_zeros__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR zeros((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_zeros(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenMX_zeros", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_GenMX_zeros__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_GenMX_zeros__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenMX_zeros__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_GenMX_zeros__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_GenMX_zeros__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenMX_zeros'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::MX >::zeros(casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::MX >::zeros(casadi::Sparsity const &)\n"
    "    casadi::GenericMatrix< casadi::MX >::zeros(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_GenMX_ones__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::MX result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR ones(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_ones__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR ones((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_ones__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::GenericMatrix< casadi::MX >::SWIGTEMPLATEDISAMBIGUATOR ones((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GenMX_ones(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "GenMX_ones", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_GenMX_ones__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_GenMX_ones__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_GenMX_ones__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_GenMX_ones__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_GenMX_ones__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'GenMX_ones'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::MX >::ones(casadi_int,casadi_int)\n"
    "    casadi::GenericMatrix< casadi::MX >::ones(casadi::Sparsity const &)\n"
    "    casadi::GenericMatrix< casadi::MX >::ones(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_new_GenMX__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::GenericMatrix< casadi::MX > *)new casadi::GenericMatrix< casadi::MX >();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenMX__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::GenericMatrix< casadi::MX > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GenMX" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenMX" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    result = (casadi::GenericMatrix< casadi::MX > *)new casadi::GenericMatrix< casadi::MX >((casadi::GenericMatrix< casadi::MX > const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenMX(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_GenMX", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_GenMX__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_GenMX__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_GenMX'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericMatrix< casadi::MX >::GenericMatrix()\n"
    "    casadi::GenericMatrix< casadi::MX >::GenericMatrix(casadi::GenericMatrix< casadi::MX > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_GenMX(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericMatrix< casadi::MX > *arg1 = (casadi::GenericMatrix< casadi::MX > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GenMX" "', argument " "1"" of type '" "casadi::GenericMatrix< casadi::MX > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericMatrix< casadi::MX > * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GenMX_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__GenericMatrixT_casadi__MX_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GenMX_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_GenericExpressionCommon__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::GenericExpressionCommon *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::GenericExpressionCommon *)new casadi::GenericExpressionCommon();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericExpressionCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenericExpressionCommon__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::GenericExpressionCommon *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::GenericExpressionCommon *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__GenericExpressionCommon,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GenericExpressionCommon" "', argument " "1"" of type '" "casadi::GenericExpressionCommon const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GenericExpressionCommon" "', argument " "1"" of type '" "casadi::GenericExpressionCommon const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericExpressionCommon * >(argp1);
  {
    result = (casadi::GenericExpressionCommon *)new casadi::GenericExpressionCommon((casadi::GenericExpressionCommon const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GenericExpressionCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GenericExpressionCommon(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_GenericExpressionCommon", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_GenericExpressionCommon__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__GenericExpressionCommon, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_GenericExpressionCommon__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_GenericExpressionCommon'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::GenericExpressionCommon::GenericExpressionCommon()\n"
    "    casadi::GenericExpressionCommon::GenericExpressionCommon(casadi::GenericExpressionCommon const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_GenericExpressionCommon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GenericExpressionCommon *arg1 = (casadi::GenericExpressionCommon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GenericExpressionCommon, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GenericExpressionCommon" "', argument " "1"" of type '" "casadi::GenericExpressionCommon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GenericExpressionCommon * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GenericExpressionCommon_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__GenericExpressionCommon, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GenericExpressionCommon_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MatrixCommon__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::MatrixCommon *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::MatrixCommon *)new casadi::MatrixCommon();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MatrixCommon__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MatrixCommon *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MatrixCommon *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__MatrixCommon,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MatrixCommon" "', argument " "1"" of type '" "casadi::MatrixCommon const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MatrixCommon" "', argument " "1"" of type '" "casadi::MatrixCommon const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::MatrixCommon * >(argp1);
  {
    result = (casadi::MatrixCommon *)new casadi::MatrixCommon((casadi::MatrixCommon const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixCommon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MatrixCommon(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_MatrixCommon", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_MatrixCommon__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__MatrixCommon, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MatrixCommon__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_MatrixCommon'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MatrixCommon::MatrixCommon()\n"
    "    casadi::MatrixCommon::MatrixCommon(casadi::MatrixCommon const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_MatrixCommon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MatrixCommon *arg1 = (casadi::MatrixCommon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixCommon, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MatrixCommon" "', argument " "1"" of type '" "casadi::MatrixCommon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MatrixCommon * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MatrixCommon_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__MatrixCommon, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MatrixCommon_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_DM__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::Matrix< double > *)new casadi::Matrix< double >();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DM__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = (casadi::Matrix< double > *)new casadi::Matrix< double >((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DM__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  casadi::Matrix< double > *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi::Matrix< double > *)new casadi::Matrix< double >(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DM__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< double > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = (casadi::Matrix< double > *)new casadi::Matrix< double >((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DM__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = (casadi::Matrix< double > *)new casadi::Matrix< double >((casadi::Sparsity const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DM__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double arg1 ;
  casadi::Matrix< double > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (casadi::Matrix< double > *)new casadi::Matrix< double >(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DM__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *arg1 = 0 ;
  std::vector< std::vector< double > > m1 ;
  casadi::Matrix< double > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "[" "float" "]" "]" "'.");
  {
    try {
      result = (casadi::Matrix< double > *)new casadi::Matrix< double >((std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_has_nz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_has_nz", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_has_nz" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->has_nz(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM___nonzero__" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->__nonzero__();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Slice m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_get" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_get" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->get(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Sparsity *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Sparsity m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_get" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Sparsity" "'.");
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->get(*arg2,arg3,(casadi::Sparsity const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Slice m4 ;
  casadi::Slice m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_get" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Slice m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_get" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Slice m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_get" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->get(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_get" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->get(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_get", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Sparsity **>(0));
        if (_v) {
          return _wrap_DM_get__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          return _wrap_DM_get__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          return _wrap_DM_get__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_DM_get__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_DM_get__SWIG_4(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_DM_get__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_DM_get__SWIG_6(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::get(casadi::Matrix< double > &,bool,casadi::Slice const &) const\n"
    "    casadi::Matrix< double >::get(casadi::Matrix< double > &,bool,casadi::Matrix< casadi_int > const &) const\n"
    "    casadi::Matrix< double >::get(casadi::Matrix< double > &,bool,casadi::Sparsity const &) const\n"
    "    casadi::Matrix< double >::get(casadi::Matrix< double > &,bool,casadi::Slice const &,casadi::Slice const &) const\n"
    "    casadi::Matrix< double >::get(casadi::Matrix< double > &,bool,casadi::Slice const &,casadi::Matrix< casadi_int > const &) const\n"
    "    casadi::Matrix< double >::get(casadi::Matrix< double > &,bool,casadi::Matrix< casadi_int > const &,casadi::Slice const &) const\n"
    "    casadi::Matrix< double >::get(casadi::Matrix< double > &,bool,casadi::Matrix< casadi_int > const &,casadi::Matrix< casadi_int > const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_set__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Slice m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_set" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< double > const &)*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_set" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< double > const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Sparsity *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Sparsity m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_set" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Sparsity" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< double > const &)*arg2,arg3,(casadi::Sparsity const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Slice m4 ;
  casadi::Slice m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_set" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< double > const &)*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Slice m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_set" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< double > const &)*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Slice m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_set" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< double > const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_set" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< double > const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_set", 0, 5, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Sparsity **>(0));
          if (_v) {
            return _wrap_DM_set__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_DM_set__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_DM_set__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Slice **>(0));
            if (_v) {
              return _wrap_DM_set__SWIG_3(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Matrix<casadi_int> **>(0));
            if (_v) {
              return _wrap_DM_set__SWIG_4(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Slice **>(0));
            if (_v) {
              return _wrap_DM_set__SWIG_5(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Matrix<casadi_int> **>(0));
            if (_v) {
              return _wrap_DM_set__SWIG_6(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_set'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::set(casadi::Matrix< double > const &,bool,casadi::Slice const &)\n"
    "    casadi::Matrix< double >::set(casadi::Matrix< double > const &,bool,casadi::Matrix< casadi_int > const &)\n"
    "    casadi::Matrix< double >::set(casadi::Matrix< double > const &,bool,casadi::Sparsity const &)\n"
    "    casadi::Matrix< double >::set(casadi::Matrix< double > const &,bool,casadi::Slice const &,casadi::Slice const &)\n"
    "    casadi::Matrix< double >::set(casadi::Matrix< double > const &,bool,casadi::Slice const &,casadi::Matrix< casadi_int > const &)\n"
    "    casadi::Matrix< double >::set(casadi::Matrix< double > const &,bool,casadi::Matrix< casadi_int > const &,casadi::Slice const &)\n"
    "    casadi::Matrix< double >::set(casadi::Matrix< double > const &,bool,casadi::Matrix< casadi_int > const &,casadi::Matrix< casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_get_nz__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Slice m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_get_nz" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->get_nz(*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get_nz__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_get_nz" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->get_nz(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get_nz(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_get_nz", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          return _wrap_DM_get_nz__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          return _wrap_DM_get_nz__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_get_nz'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::get_nz(casadi::Matrix< double > &,bool,casadi::Slice const &) const\n"
    "    casadi::Matrix< double >::get_nz(casadi::Matrix< double > &,bool,casadi::Matrix< casadi_int > const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_set_nz__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Slice m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_set_nz" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set_nz((casadi::Matrix< double > const &)*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set_nz__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_set_nz" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      (arg1)->set_nz((casadi::Matrix< double > const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set_nz(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_set_nz", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_DM_set_nz__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_DM_set_nz__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_set_nz'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::set_nz(casadi::Matrix< double > const &,bool,casadi::Slice const &)\n"
    "    casadi::Matrix< double >::set_nz(casadi::Matrix< double > const &,bool,casadi::Matrix< casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM___pos__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< double > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM___pos__" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->operator +();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DM___neg__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< double > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM___neg__" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->operator -();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_DM_binary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Matrix< double > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_binary", 3, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR binary(arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_unary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m2 ;
  PyObject *swig_obj[2] ;
  casadi::Matrix< double > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_unary", 2, 2, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR unary(arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_scalar_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Matrix< double > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_scalar_matrix", 3, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR scalar_matrix(arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_matrix_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Matrix< double > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_matrix_scalar", 3, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR matrix_scalar(arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_matrix_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Matrix< double > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_matrix_matrix", 3, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR matrix_matrix(arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_printme(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  PyObject *swig_obj[2] ;
  casadi::Matrix< double > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_printme", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_printme" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->printme((casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set_max_depth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_set_max_depth", 0, 1, swig_obj)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  {
    try {
      casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR set_max_depth(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get_max_depth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_get_max_depth", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR get_max_depth();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  casadi::Function m1 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR get_input((casadi::Function const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_get_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  casadi::Function m1 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR get_free((casadi::Function const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_type_name", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_print_split(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< std::string > m2 ;
  std::vector< std::string > m3 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &m2;
  arg3 = &m3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_print_split" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->print_split(*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "DM_disp", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_disp" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->disp(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_str", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_str" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->get_str(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_print_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &casadi::uout();
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_print_scalar" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->print_scalar(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_print_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "DM_print_vector", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_print_vector" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->print_vector(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_print_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "DM_print_dense", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_print_dense" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->print_dense(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_print_sparse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "DM_print_sparse", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_print_sparse" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->print_sparse(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_clear" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_resize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_resize", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_resize" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      (arg1)->resize(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_reserve__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_reserve" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      (arg1)->reserve(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_reserve__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_reserve" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      (arg1)->reserve(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_reserve(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_reserve", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_DM_reserve__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_DM_reserve__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_reserve'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::reserve(casadi_int)\n"
    "    casadi::Matrix< double >::reserve(casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_erase" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->erase((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_erase" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->erase((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_erase(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_erase", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DM_erase__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DM_erase__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DM_erase__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DM_erase__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_erase'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::erase(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n"
    "    casadi::Matrix< double >::erase(std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_remove", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_remove" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      (arg1)->remove((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_enlarge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  bool arg6 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_enlarge", 5, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_enlarge" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  if (swig_obj[5]) {
    if (!casadi::to_val(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->enlarge(arg2,arg3,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg4,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg5,arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_sparsity" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->get_sparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_triplet__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  std::vector< casadi_int > m1 ;
  std::vector< casadi_int > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR triplet((std::vector< long long,std::allocator< long long > > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_triplet__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi_int arg4 ;
  casadi_int arg5 ;
  std::vector< casadi_int > m1 ;
  std::vector< casadi_int > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR triplet((std::vector< long long,std::allocator< long long > > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(casadi::Matrix< double > const &)*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_triplet__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  std::pair< casadi_int,casadi_int > *arg4 = 0 ;
  std::vector< casadi_int > m1 ;
  std::vector< casadi_int > m2 ;
  casadi::Matrix< double > m3 ;
  std::pair< casadi_int,casadi_int > m4 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR triplet((std::vector< long long,std::allocator< long long > > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(casadi::Matrix< double > const &)*arg3,(std::pair< long long,long long > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_triplet(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_triplet", 0, 5, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi_int> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          return _wrap_DM_triplet__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi_int> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::pair<casadi_int,casadi_int> **>(0));
          if (_v) {
            return _wrap_DM_triplet__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi_int> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              return _wrap_DM_triplet__SWIG_1(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_triplet'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::triplet(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi::Matrix< double > const &)\n"
    "    casadi::Matrix< double >::triplet(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi::Matrix< double > const &,casadi_int,casadi_int)\n"
    "    casadi::Matrix< double >::triplet(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi::Matrix< double > const &,std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_inf__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR inf((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_inf__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR inf(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_inf__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR inf((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_inf(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_inf", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_DM_inf__SWIG_1(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_DM_inf__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_DM_inf__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_DM_inf__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_DM_inf__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_inf'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::inf(casadi::Sparsity const &)\n"
    "    casadi::Matrix< double >::inf(casadi_int,casadi_int)\n"
    "    casadi::Matrix< double >::inf(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_nan__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR nan((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_nan__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR nan(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_nan__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR nan((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_nan(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_nan", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_DM_nan__SWIG_1(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_DM_nan__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_DM_nan__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_DM_nan__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_DM_nan__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_nan'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::nan(casadi::Sparsity const &)\n"
    "    casadi::Matrix< double >::nan(casadi_int,casadi_int)\n"
    "    casadi::Matrix< double >::nan(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_eye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< double > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR eye(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_element_hash(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_element_hash" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Matrix< double > const *)arg1)->element_hash();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_regular(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_regular" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_regular();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_smooth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_smooth" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_smooth();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_leaf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_leaf" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_leaf();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_commutative(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_commutative" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_commutative();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_symbolic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_symbolic" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_symbolic();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_valid_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_valid_input" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_valid_input();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_has_duplicates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_has_duplicates" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->has_duplicates();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_reset_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_reset_input" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->reset_input();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_constant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_constant" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_constant();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_integer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_integer" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_integer();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_zero(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_zero" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_zero();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_one(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_one" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_one();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_minus_one(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_minus_one" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_minus_one();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_eye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_eye" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_eye();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_op(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_op" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Matrix< double > const *)arg1)->op();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_is_op(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_is_op", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_is_op" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->is_op(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_has_zeros(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_has_zeros" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< double > const *)arg1)->has_zeros();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_nonzeros(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_nonzeros" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->get_nonzeros();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_elements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_elements" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->get_elements();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM___float__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM___float__" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (double)((casadi::Matrix< double > const *)arg1)->operator double();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM___int__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM___int__" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Matrix< double > const *)arg1)->operator casadi_int();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_name" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_dep(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi_int arg2 = (casadi_int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::Matrix< double > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_dep", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_dep" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->dep(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_n_dep(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_n_dep" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Matrix< double > const *)arg1)->n_dep();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set_precision(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR set_precision(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set_width(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR set_width(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_set_scientific(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "bool" "'.");
  {
    try {
      casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR set_scientific(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_rng(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR rng(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_rand__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR rand(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_rand__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR rand((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_rand__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR rand((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_rand(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_rand", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_DM_rand__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_DM_rand__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_DM_rand__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_DM_rand__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_DM_rand__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_rand'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::rand(casadi_int,casadi_int)\n"
    "    casadi::Matrix< double >::rand(casadi::Sparsity const &)\n"
    "    casadi::Matrix< double >::rand(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_export_code(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::string *arg2 = 0 ;
  std::ostream &arg3_defvalue = casadi::uout() ;
  std::ostream *arg3 = (std::ostream *) &arg3_defvalue ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[3] ;
  
  arg3 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "DM_export_code", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_export_code" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->export_code((std::string const &)*arg2,*arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_info" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->info();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_serialize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_serialize" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< double > const *)arg1)->serialize();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_deserialize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::istream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_deserialize" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DM_deserialize" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_deserialize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR deserialize((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_serialize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::SerializingStream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_serialize" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__SerializingStream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DM_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DM_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  arg2 = reinterpret_cast< casadi::SerializingStream * >(argp2);
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->serialize(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_serialize(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_serialize", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_DM_serialize__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_double_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_casadi__SerializingStream, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_DM_serialize__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_serialize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::serialize() const\n"
    "    casadi::Matrix< double >::serialize(casadi::SerializingStream &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_deserialize__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DeserializingStream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__DeserializingStream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DM_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializingStream * >(argp1);
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_deserialize(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DM_deserialize", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_DM_deserialize__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DeserializingStream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_DM_deserialize__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      return _wrap_DM_deserialize__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DM_deserialize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::deserialize(std::istream &)\n"
    "    casadi::Matrix< double >::deserialize(std::string const &)\n"
    "    casadi::Matrix< double >::deserialize(casadi::DeserializingStream &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_to_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  std::string *arg2 = 0 ;
  std::string const &arg3_defvalue = "" ;
  std::string *arg3 = (std::string *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_to_file", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_to_file" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  }
  {
    try {
      ((casadi::Matrix< double > const *)arg1)->to_file((std::string const &)*arg2,(std::string const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string const &arg2_defvalue = "" ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  casadi::Matrix< double > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_from_file", 1, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  {
    try {
      result = casadi::Matrix< double >::SWIGTEMPLATEDISAMBIGUATOR from_file((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DM__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::SXElem,std::allocator< casadi::SXElem > > *arg1 = 0 ;
  std::vector< casadi::SXElem > m1 ;
  casadi::Matrix< double > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SXElem" "]" "'.");
  {
    try {
      result = (casadi::Matrix< double > *)new casadi::Matrix< double >((std::vector< casadi::SXElem,std::allocator< casadi::SXElem > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DM__SWIG_8(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< double > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = (casadi::Matrix< double > *)new casadi::Matrix< double >((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DM(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_DM", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_DM__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_new_DM__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_new_DM__SWIG_5(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<std::vector<double> > **>(0));
    if (_v) {
      return _wrap_new_DM__SWIG_6(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_new_DM__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_new_DM__SWIG_7(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_new_DM__SWIG_8(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_new_DM__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_new_DM__SWIG_4(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_DM'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< double >::Matrix()\n"
    "    casadi::Matrix< double >::Matrix(casadi::Matrix< double > const &)\n"
    "    casadi::Matrix< double >::Matrix(casadi_int,casadi_int)\n"
    "    casadi::Matrix< double >::Matrix(casadi::Sparsity const &)\n"
    "    casadi::Matrix< double >::Matrix(casadi::Sparsity const &,casadi::Matrix< double > const &)\n"
    "    casadi::Matrix< double >::Matrix(double)\n"
    "    casadi::Matrix< double >::Matrix(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)\n"
    "    casadi::Matrix< double >::Matrix(std::vector< casadi::SXElem,std::allocator< casadi::SXElem > > const &)\n"
    "    casadi::Matrix< double >::Matrix(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DM_assign(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DM_assign", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_assign" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      casadi_Matrix_Sl_double_Sg__assign(arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_full(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_full" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (PyObject *)casadi_Matrix_Sl_double_Sg__full((casadi::Matrix< double > const *)arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DM_sparse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DM_sparse" "', argument " "1"" of type '" "casadi::Matrix< double > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    try {
      result = (PyObject *)casadi_Matrix_Sl_double_Sg__sparse((casadi::Matrix< double > const *)arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = result;
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_DM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = (casadi::Matrix< double > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DM" "', argument " "1"" of type '" "casadi::Matrix< double > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< double > * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DM_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__MatrixT_double_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *DM_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SXElem__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::SXElem *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::SXElem *)new casadi::SXElem();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__SXElem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SXElem__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SXElem *arg1 = 0 ;
  casadi::SXElem m1 ;
  casadi::SXElem *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SXElem" "'.");
  {
    result = (casadi::SXElem *)new casadi::SXElem((casadi::SXElem const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__SXElem, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SXElem(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_SXElem", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_SXElem__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::SXElem **>(0));
    if (_v) {
      return _wrap_new_SXElem__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_SXElem'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::SXElem::SXElem()\n"
    "    casadi::SXElem::SXElem(casadi::SXElem const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_SXElem(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SXElem *arg1 = (casadi::SXElem *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SXElem, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SXElem" "', argument " "1"" of type '" "casadi::SXElem *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SXElem * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SXElem_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__SXElem, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SXElem_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_SX__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::Matrix< casadi::SXElem > *)new casadi::Matrix< casadi::SXElem >();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SX__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = (casadi::Matrix< casadi::SXElem > *)new casadi::Matrix< casadi::SXElem >((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SX__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  casadi::Matrix< casadi::SXElem > *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi::Matrix< casadi::SXElem > *)new casadi::Matrix< casadi::SXElem >(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SX__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< casadi::SXElem > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = (casadi::Matrix< casadi::SXElem > *)new casadi::Matrix< casadi::SXElem >((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SX__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = (casadi::Matrix< casadi::SXElem > *)new casadi::Matrix< casadi::SXElem >((casadi::Sparsity const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SX__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double arg1 ;
  casadi::Matrix< casadi::SXElem > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (casadi::Matrix< casadi::SXElem > *)new casadi::Matrix< casadi::SXElem >(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SX__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *arg1 = 0 ;
  std::vector< std::vector< double > > m1 ;
  casadi::Matrix< casadi::SXElem > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "[" "float" "]" "]" "'.");
  {
    try {
      result = (casadi::Matrix< casadi::SXElem > *)new casadi::Matrix< casadi::SXElem >((std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_has_nz(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_has_nz", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_has_nz" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->has_nz(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX___nonzero__" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->__nonzero__();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Slice m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_get" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_get" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->get(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Sparsity *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Sparsity m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_get" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Sparsity" "'.");
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->get(*arg2,arg3,(casadi::Sparsity const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Slice m4 ;
  casadi::Slice m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_get" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Slice m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_get" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Slice m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_get" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->get(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_get" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->get(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_get", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Sparsity **>(0));
        if (_v) {
          return _wrap_SX_get__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          return _wrap_SX_get__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          return _wrap_SX_get__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_SX_get__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_SX_get__SWIG_4(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_SX_get__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_SX_get__SWIG_6(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::get(casadi::Matrix< casadi::SXElem > &,bool,casadi::Slice const &) const\n"
    "    casadi::Matrix< casadi::SXElem >::get(casadi::Matrix< casadi::SXElem > &,bool,casadi::Matrix< casadi_int > const &) const\n"
    "    casadi::Matrix< casadi::SXElem >::get(casadi::Matrix< casadi::SXElem > &,bool,casadi::Sparsity const &) const\n"
    "    casadi::Matrix< casadi::SXElem >::get(casadi::Matrix< casadi::SXElem > &,bool,casadi::Slice const &,casadi::Slice const &) const\n"
    "    casadi::Matrix< casadi::SXElem >::get(casadi::Matrix< casadi::SXElem > &,bool,casadi::Slice const &,casadi::Matrix< casadi_int > const &) const\n"
    "    casadi::Matrix< casadi::SXElem >::get(casadi::Matrix< casadi::SXElem > &,bool,casadi::Matrix< casadi_int > const &,casadi::Slice const &) const\n"
    "    casadi::Matrix< casadi::SXElem >::get(casadi::Matrix< casadi::SXElem > &,bool,casadi::Matrix< casadi_int > const &,casadi::Matrix< casadi_int > const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_set__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Slice m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_set" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_set" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Sparsity *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Sparsity m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_set" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Sparsity" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,(casadi::Sparsity const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Slice m4 ;
  casadi::Slice m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_set" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Slice m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_set" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Slice m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_set" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_set" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      (arg1)->set((casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_set", 0, 5, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Sparsity **>(0));
          if (_v) {
            return _wrap_SX_set__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_SX_set__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_SX_set__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Slice **>(0));
            if (_v) {
              return _wrap_SX_set__SWIG_3(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Matrix<casadi_int> **>(0));
            if (_v) {
              return _wrap_SX_set__SWIG_4(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Slice **>(0));
            if (_v) {
              return _wrap_SX_set__SWIG_5(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Matrix<casadi_int> **>(0));
            if (_v) {
              return _wrap_SX_set__SWIG_6(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_set'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::set(casadi::Matrix< casadi::SXElem > const &,bool,casadi::Slice const &)\n"
    "    casadi::Matrix< casadi::SXElem >::set(casadi::Matrix< casadi::SXElem > const &,bool,casadi::Matrix< casadi_int > const &)\n"
    "    casadi::Matrix< casadi::SXElem >::set(casadi::Matrix< casadi::SXElem > const &,bool,casadi::Sparsity const &)\n"
    "    casadi::Matrix< casadi::SXElem >::set(casadi::Matrix< casadi::SXElem > const &,bool,casadi::Slice const &,casadi::Slice const &)\n"
    "    casadi::Matrix< casadi::SXElem >::set(casadi::Matrix< casadi::SXElem > const &,bool,casadi::Slice const &,casadi::Matrix< casadi_int > const &)\n"
    "    casadi::Matrix< casadi::SXElem >::set(casadi::Matrix< casadi::SXElem > const &,bool,casadi::Matrix< casadi_int > const &,casadi::Slice const &)\n"
    "    casadi::Matrix< casadi::SXElem >::set(casadi::Matrix< casadi::SXElem > const &,bool,casadi::Matrix< casadi_int > const &,casadi::Matrix< casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_get_nz__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Slice m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_get_nz" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->get_nz(*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get_nz__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_get_nz" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->get_nz(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get_nz(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_get_nz", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          return _wrap_SX_get_nz__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          return _wrap_SX_get_nz__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_get_nz'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::get_nz(casadi::Matrix< casadi::SXElem > &,bool,casadi::Slice const &) const\n"
    "    casadi::Matrix< casadi::SXElem >::get_nz(casadi::Matrix< casadi::SXElem > &,bool,casadi::Matrix< casadi_int > const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_set_nz__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Slice m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_set_nz" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set_nz((casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set_nz__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_set_nz" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      (arg1)->set_nz((casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set_nz(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_set_nz", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_SX_set_nz__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_SX_set_nz__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_set_nz'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::set_nz(casadi::Matrix< casadi::SXElem > const &,bool,casadi::Slice const &)\n"
    "    casadi::Matrix< casadi::SXElem >::set_nz(casadi::Matrix< casadi::SXElem > const &,bool,casadi::Matrix< casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX___pos__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX___pos__" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->operator +();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SX___neg__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX___neg__" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->operator -();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_SX_binary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_binary", 3, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR binary(arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_unary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  PyObject *swig_obj[2] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_unary", 2, 2, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR unary(arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_scalar_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_scalar_matrix", 3, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR scalar_matrix(arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_matrix_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_matrix_scalar", 3, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR matrix_scalar(arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_matrix_matrix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_matrix_matrix", 3, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR matrix_matrix(arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_printme(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  PyObject *swig_obj[2] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_printme", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_printme" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->printme((casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set_max_depth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_set_max_depth", 0, 1, swig_obj)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  {
    try {
      casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR set_max_depth(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get_max_depth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_get_max_depth", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR get_max_depth();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  casadi::Function m1 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR get_input((casadi::Function const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_get_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  casadi::Function m1 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR get_free((casadi::Function const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_type_name", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_print_split(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< std::string > m2 ;
  std::vector< std::string > m3 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &m2;
  arg3 = &m3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_print_split" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->print_split(*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "SX_disp", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_disp" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->disp(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_str", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_str" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->get_str(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_print_scalar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::ostream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &casadi::uout();
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_print_scalar" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->print_scalar(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_print_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "SX_print_vector", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_print_vector" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->print_vector(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_print_dense(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "SX_print_dense", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_print_dense" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->print_dense(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_print_sparse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "SX_print_sparse", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_print_sparse" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->print_sparse(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_clear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_clear" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      (arg1)->clear();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_resize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_resize", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_resize" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      (arg1)->resize(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_reserve__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_reserve" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      (arg1)->reserve(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_reserve__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_reserve" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      (arg1)->reserve(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_reserve(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_reserve", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_SX_reserve__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_SX_reserve__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_reserve'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::reserve(casadi_int)\n"
    "    casadi::Matrix< casadi::SXElem >::reserve(casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_erase" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->erase((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_erase" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->erase((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_erase(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_erase", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_SX_erase__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_SX_erase__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_SX_erase__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_SX_erase__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_erase'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::erase(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n"
    "    casadi::Matrix< casadi::SXElem >::erase(std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_remove(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_remove", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_remove" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      (arg1)->remove((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_enlarge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  bool arg6 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_enlarge", 5, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_enlarge" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  if (swig_obj[5]) {
    if (!casadi::to_val(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->enlarge(arg2,arg3,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg4,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg5,arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_sparsity" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->get_sparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_triplet__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  std::vector< casadi_int > m1 ;
  std::vector< casadi_int > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR triplet((std::vector< long long,std::allocator< long long > > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_triplet__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi_int arg4 ;
  casadi_int arg5 ;
  std::vector< casadi_int > m1 ;
  std::vector< casadi_int > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR triplet((std::vector< long long,std::allocator< long long > > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_triplet__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  std::pair< casadi_int,casadi_int > *arg4 = 0 ;
  std::vector< casadi_int > m1 ;
  std::vector< casadi_int > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  std::pair< casadi_int,casadi_int > m4 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "int" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR triplet((std::vector< long long,std::allocator< long long > > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,(std::pair< long long,long long > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_triplet(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_triplet", 0, 5, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi_int> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          return _wrap_SX_triplet__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi_int> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::pair<casadi_int,casadi_int> **>(0));
          if (_v) {
            return _wrap_SX_triplet__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi_int> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              return _wrap_SX_triplet__SWIG_1(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_triplet'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::triplet(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::Matrix< casadi::SXElem >::triplet(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi_int)\n"
    "    casadi::Matrix< casadi::SXElem >::triplet(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi::Matrix< casadi::SXElem > const &,std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_inf__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR inf((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_inf__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR inf(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_inf__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR inf((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_inf(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_inf", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_SX_inf__SWIG_1(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_SX_inf__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_SX_inf__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_SX_inf__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_SX_inf__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_inf'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::inf(casadi::Sparsity const &)\n"
    "    casadi::Matrix< casadi::SXElem >::inf(casadi_int,casadi_int)\n"
    "    casadi::Matrix< casadi::SXElem >::inf(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_nan__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR nan((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_nan__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR nan(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_nan__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR nan((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_nan(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_nan", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_SX_nan__SWIG_1(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_SX_nan__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_SX_nan__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_SX_nan__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_SX_nan__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_nan'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::nan(casadi::Sparsity const &)\n"
    "    casadi::Matrix< casadi::SXElem >::nan(casadi_int,casadi_int)\n"
    "    casadi::Matrix< casadi::SXElem >::nan(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_eye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR eye(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_element_hash(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_element_hash" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Matrix< casadi::SXElem > const *)arg1)->element_hash();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_regular(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_regular" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_regular();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_smooth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_smooth" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_smooth();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_leaf(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_leaf" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_leaf();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_commutative(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_commutative" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_commutative();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_symbolic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_symbolic" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_symbolic();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_valid_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_valid_input" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_valid_input();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_has_duplicates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_has_duplicates" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->has_duplicates();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_reset_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_reset_input" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->reset_input();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_constant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_constant" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_constant();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_integer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_integer" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_integer();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_zero(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_zero" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_zero();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_one(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_one" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_one();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_minus_one(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_minus_one" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_minus_one();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_eye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_eye" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_eye();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_op(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_op" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Matrix< casadi::SXElem > const *)arg1)->op();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_is_op(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_is_op", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_is_op" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->is_op(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_has_zeros(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_has_zeros" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (bool)((casadi::Matrix< casadi::SXElem > const *)arg1)->has_zeros();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_nonzeros(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::SXElem,std::allocator< casadi::SXElem > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_nonzeros" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->get_nonzeros();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SXElem" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_elements(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::SXElem,std::allocator< casadi::SXElem > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_elements" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->get_elements();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SXElem" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX___float__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX___float__" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (double)((casadi::Matrix< casadi::SXElem > const *)arg1)->operator double();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX___int__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX___int__" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Matrix< casadi::SXElem > const *)arg1)->operator casadi_int();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_name" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_dep(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi_int arg2 = (casadi_int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_dep", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_dep" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->dep(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_n_dep(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_n_dep" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Matrix< casadi::SXElem > const *)arg1)->n_dep();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set_precision(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR set_precision(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set_width(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR set_width(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_set_scientific(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "bool" "'.");
  {
    try {
      casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR set_scientific(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_rng(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR rng(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_rand__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR rand(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_rand__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR rand((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_rand__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR rand((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_rand(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_rand", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_SX_rand__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_SX_rand__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_SX_rand__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_SX_rand__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_SX_rand__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_rand'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::rand(casadi_int,casadi_int)\n"
    "    casadi::Matrix< casadi::SXElem >::rand(casadi::Sparsity const &)\n"
    "    casadi::Matrix< casadi::SXElem >::rand(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_export_code(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::string *arg2 = 0 ;
  std::ostream &arg3_defvalue = casadi::uout() ;
  std::ostream *arg3 = (std::ostream *) &arg3_defvalue ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[3] ;
  
  arg3 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "SX_export_code", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_export_code" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->export_code((std::string const &)*arg2,*arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_info" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->info();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_serialize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_serialize" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    try {
      result = ((casadi::Matrix< casadi::SXElem > const *)arg1)->serialize();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_deserialize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::istream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_deserialize" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SX_deserialize" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_deserialize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR deserialize((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_serialize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  casadi::SerializingStream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_serialize" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__SerializingStream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SX_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SX_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  arg2 = reinterpret_cast< casadi::SerializingStream * >(argp2);
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->serialize(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_serialize(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_serialize", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SX_serialize__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_casadi__SerializingStream, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SX_serialize__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_serialize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::serialize() const\n"
    "    casadi::Matrix< casadi::SXElem >::serialize(casadi::SerializingStream &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_deserialize__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DeserializingStream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__DeserializingStream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SX_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializingStream * >(argp1);
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_deserialize(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SX_deserialize", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SX_deserialize__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DeserializingStream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_SX_deserialize__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      return _wrap_SX_deserialize__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SX_deserialize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::deserialize(std::istream &)\n"
    "    casadi::Matrix< casadi::SXElem >::deserialize(std::string const &)\n"
    "    casadi::Matrix< casadi::SXElem >::deserialize(casadi::DeserializingStream &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SX_to_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  std::string *arg2 = 0 ;
  std::string const &arg3_defvalue = "" ;
  std::string *arg3 = (std::string *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_to_file", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SX_to_file" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  }
  {
    try {
      ((casadi::Matrix< casadi::SXElem > const *)arg1)->to_file((std::string const &)*arg2,(std::string const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SX_from_file(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string const &arg2_defvalue = "" ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  casadi::Matrix< double > result;
  
  if (!SWIG_Python_UnpackTuple(args, "SX_from_file", 1, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  {
    try {
      result = casadi::Matrix< casadi::SXElem >::SWIGTEMPLATEDISAMBIGUATOR from_file((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SX__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< double,std::allocator< double > > *arg1 = 0 ;
  std::vector< double > m1 ;
  casadi::Matrix< casadi::SXElem > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "float" "]" "'.");
  {
    try {
      result = (casadi::Matrix< casadi::SXElem > *)new casadi::Matrix< casadi::SXElem >((std::vector< double,std::allocator< double > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SX__SWIG_8(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< casadi::SXElem > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = (casadi::Matrix< casadi::SXElem > *)new casadi::Matrix< casadi::SXElem >((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_SX(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_SX", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_SX__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_new_SX__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_new_SX__SWIG_5(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<std::vector<double> > **>(0));
    if (_v) {
      return _wrap_new_SX__SWIG_6(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<double> **>(0));
    if (_v) {
      return _wrap_new_SX__SWIG_7(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_new_SX__SWIG_8(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_new_SX__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_new_SX__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_new_SX__SWIG_4(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_SX'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Matrix< casadi::SXElem >::Matrix()\n"
    "    casadi::Matrix< casadi::SXElem >::Matrix(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::Matrix< casadi::SXElem >::Matrix(casadi_int,casadi_int)\n"
    "    casadi::Matrix< casadi::SXElem >::Matrix(casadi::Sparsity const &)\n"
    "    casadi::Matrix< casadi::SXElem >::Matrix(casadi::Sparsity const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::Matrix< casadi::SXElem >::Matrix(double)\n"
    "    casadi::Matrix< casadi::SXElem >::Matrix(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)\n"
    "    casadi::Matrix< casadi::SXElem >::Matrix(std::vector< double,std::allocator< double > > const &)\n"
    "    casadi::Matrix< casadi::SXElem >::Matrix(casadi::Matrix< double > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_SX(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = (casadi::Matrix< casadi::SXElem > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SX" "', argument " "1"" of type '" "casadi::Matrix< casadi::SXElem > *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Matrix< casadi::SXElem > * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SX_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__MatrixT_casadi__SXElem_t, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *SX_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_MX_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_type_name", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::MX::type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MX__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::MX *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::MX *)new casadi::MX();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MX, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MX__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi_int arg2 ;
  casadi::MX *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi::MX *)new casadi::MX(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MX, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MX__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::MX *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = (casadi::MX *)new casadi::MX((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MX, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MX__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::Sparsity m1 ;
  casadi::MX m2 ;
  casadi::MX *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = (casadi::MX *)new casadi::MX((casadi::Sparsity const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MX, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MX__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Sparsity m1 ;
  std::string m2 ;
  casadi::MX *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi::MX *)new casadi::MX((casadi::Sparsity const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MX, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MX__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double arg1 ;
  casadi::MX *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (casadi::MX *)new casadi::MX(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MX, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MX__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = (casadi::MX *)new casadi::MX((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MX, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MX__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::MX *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = (casadi::MX *)new casadi::MX((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MX, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MX(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_MX", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_MX__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_new_MX__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_new_MX__SWIG_5(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_new_MX__SWIG_7(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_new_MX__SWIG_6(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_new_MX__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_new_MX__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_new_MX__SWIG_4(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_MX'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MX::MX()\n"
    "    casadi::MX::MX(casadi_int,casadi_int)\n"
    "    casadi::MX::MX(casadi::Sparsity const &)\n"
    "    casadi::MX::MX(casadi::Sparsity const &,casadi::MX const &)\n"
    "    casadi::MX::MX(casadi::Sparsity const &,std::string const &)\n"
    "    casadi::MX::MX(double)\n"
    "    casadi::MX::MX(casadi::MX const &)\n"
    "    casadi::MX::MX(casadi::Matrix< double > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_MX(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MX" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX___nonzero__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX___nonzero__" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->__nonzero__();
    } catch (const std::exception& e) {
      SWIG_exception(SWIG_TypeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_sparsity" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = ((casadi::MX const *)arg1)->get_sparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_erase__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_erase" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->erase((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_erase__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_erase" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->erase((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_erase(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MX_erase", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_MX_erase__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_MX_erase__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_MX_erase__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_MX_erase__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MX_erase'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MX::erase(std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n"
    "    casadi::MX::erase(std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MX_enlarge(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  bool arg6 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_enlarge", 5, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_enlarge" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  if (swig_obj[5]) {
    if (!casadi::to_val(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->enlarge(arg2,arg3,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg4,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg5,arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX___neg__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX___neg__" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = ((casadi::MX const *)arg1)->operator -();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_MX_dep(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi_int arg2 = (casadi_int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_dep", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_dep" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = ((casadi::MX const *)arg1)->dep(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_n_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_n_out" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::MX const *)arg1)->n_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_output(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_get_output", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get_output" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::MX const *)arg1)->get_output(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_n_dep(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_n_dep" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::MX const *)arg1)->n_dep();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_name" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = ((casadi::MX const *)arg1)->name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX___float__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX___float__" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (double)((casadi::MX const *)arg1)->operator double();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_to_DM(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< double > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_to_DM" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = ((casadi::MX const *)arg1)->operator casadi::Matrix<double>();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_symbolic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_symbolic" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_symbolic();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_constant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_constant" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_constant();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_call(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_call" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_call();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_which_function(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Function result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_which_function" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = ((casadi::MX const *)arg1)->which_function();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_output(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_output" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_output();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_which_output(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_which_output" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::MX const *)arg1)->which_output();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_op(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_is_op", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_op" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_op(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_multiplication(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_multiplication" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_multiplication();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_commutative(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_commutative" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_commutative();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_norm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_norm" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_norm();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_valid_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_valid_input" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_valid_input();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_n_primitives(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_n_primitives" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::MX const *)arg1)->n_primitives();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_primitives(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_primitives" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = ((casadi::MX const *)arg1)->primitives();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_split_primitives(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_split_primitives", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_split_primitives" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::MX const *)arg1)->split_primitives((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_join_primitives(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_join_primitives", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_join_primitives" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = ((casadi::MX const *)arg1)->join_primitives((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_has_duplicates(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_has_duplicates" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->has_duplicates();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_reset_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_reset_input" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      ((casadi::MX const *)arg1)->reset_input();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_eye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_eye" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_eye();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_zero(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_zero" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_zero();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_one(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_one" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_one();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_minus_one(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_minus_one" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_minus_one();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_transpose(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_transpose" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_transpose();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_regular(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_regular" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_regular();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_binary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_binary" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_binary();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_is_unary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_is_unary" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (bool)((casadi::MX const *)arg1)->is_unary();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_op(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_op" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::MX const *)arg1)->op();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_info" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = ((casadi::MX const *)arg1)->info();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_serialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::SerializingStream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_serialize", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_serialize" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__SerializingStream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "MX_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MX_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  arg2 = reinterpret_cast< casadi::SerializingStream * >(argp2);
  {
    try {
      ((casadi::MX const *)arg1)->serialize(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_deserialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializingStream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__DeserializingStream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "MX_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializingStream * >(argp1);
  {
    try {
      result = casadi::MX::deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_temp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get_temp" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::MX const *)arg1)->get_temp();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set_temp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_set_temp", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set_temp" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->set_temp(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_binary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_binary", 3, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      result = casadi::MX::binary(arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_unary(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_unary", 2, 2, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::MX::unary(arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_inf__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::MX::inf((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_inf__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::MX result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::MX::inf(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_inf__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::MX::inf((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_inf(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MX_inf", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_MX_inf__SWIG_1(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_MX_inf__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_MX_inf__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_MX_inf__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_MX_inf__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MX_inf'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MX::inf(casadi::Sparsity const &)\n"
    "    casadi::MX::inf(casadi_int,casadi_int)\n"
    "    casadi::MX::inf(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MX_nan__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::MX::nan((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_nan__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::MX result;
  
  if ((nobjs < 0) || (nobjs > 2)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::MX::nan(arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_nan__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::pair< casadi_int,casadi_int > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::MX::nan((std::pair< long long,long long > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_nan(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MX_nan", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 2)) {
    int _v;
    if (argc <= 0) {
      return _wrap_MX_nan__SWIG_1(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_MX_nan__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_MX_nan__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::pair<casadi_int,casadi_int> **>(0));
    if (_v) {
      return _wrap_MX_nan__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_MX_nan__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MX_nan'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MX::nan(casadi::Sparsity const &)\n"
    "    casadi::MX::nan(casadi_int,casadi_int)\n"
    "    casadi::MX::nan(std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MX_eye(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::MX::eye(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Sparsity *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Sparsity m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Sparsity" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::Sparsity const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::MX *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::MX m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::MX const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi_int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  casadi::Slice m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi_int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_8(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Slice m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_9(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi_int arg4 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_10(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_11(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi_int arg4 ;
  casadi_int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_12(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::MX *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::MX m4 ;
  casadi::Slice m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::MX const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_13(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::MX *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  casadi::MX m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "MX" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::MX const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get__SWIG_14(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::MX *arg4 = 0 ;
  casadi::MX *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::MX m4 ;
  casadi::MX m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "MX" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get(*arg2,arg3,(casadi::MX const &)*arg4,(casadi::MX const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MX_get", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_MX_get__SWIG_4(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Sparsity **>(0));
        if (_v) {
          return _wrap_MX_get__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          return _wrap_MX_get__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          return _wrap_MX_get__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          return _wrap_MX_get__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_11(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_9(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_7(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_6(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::MX **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_13(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_8(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_10(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_12(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::MX **>(0));
          if (_v) {
            return _wrap_MX_get__SWIG_14(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MX_get'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::Slice const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::Matrix< casadi_int > const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::Sparsity const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::MX const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi_int const) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::Slice const &,casadi::Slice const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::Slice const &,casadi::Matrix< casadi_int > const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::Slice const &,casadi_int) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::Matrix< casadi_int > const &,casadi::Slice const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi_int,casadi::Slice const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::Matrix< casadi_int > const &,casadi::Matrix< casadi_int > const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi_int,casadi_int) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::MX const &,casadi::Slice const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::Slice const &,casadi::MX const &) const\n"
    "    casadi::MX::get(casadi::MX &,bool,casadi::MX const &,casadi::MX const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MX_set__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set((casadi::MX const &)*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      (arg1)->set((casadi::MX const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Sparsity *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Sparsity m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Sparsity" "'.");
  {
    try {
      (arg1)->set((casadi::MX const &)*arg2,arg3,(casadi::Sparsity const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  casadi::Slice m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set((casadi::MX const &)*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      (arg1)->set((casadi::MX const &)*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Slice m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set((casadi::MX const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  casadi::Matrix< casadi_int > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< casadi_int > m4 ;
  casadi::Matrix< casadi_int > m5 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "IM" "'.");
  {
    try {
      (arg1)->set((casadi::MX const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4,(casadi::Matrix< casadi_int > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MX_set", 0, 5, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Sparsity **>(0));
          if (_v) {
            return _wrap_MX_set__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_MX_set__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_MX_set__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Slice **>(0));
            if (_v) {
              return _wrap_MX_set__SWIG_3(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Matrix<casadi_int> **>(0));
            if (_v) {
              return _wrap_MX_set__SWIG_4(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Slice **>(0));
            if (_v) {
              return _wrap_MX_set__SWIG_5(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Matrix<casadi_int> **>(0));
            if (_v) {
              return _wrap_MX_set__SWIG_6(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MX_set'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MX::set(casadi::MX const &,bool,casadi::Slice const &)\n"
    "    casadi::MX::set(casadi::MX const &,bool,casadi::Matrix< casadi_int > const &)\n"
    "    casadi::MX::set(casadi::MX const &,bool,casadi::Sparsity const &)\n"
    "    casadi::MX::set(casadi::MX const &,bool,casadi::Slice const &,casadi::Slice const &)\n"
    "    casadi::MX::set(casadi::MX const &,bool,casadi::Slice const &,casadi::Matrix< casadi_int > const &)\n"
    "    casadi::MX::set(casadi::MX const &,bool,casadi::Matrix< casadi_int > const &,casadi::Slice const &)\n"
    "    casadi::MX::set(casadi::MX const &,bool,casadi::Matrix< casadi_int > const &,casadi::Matrix< casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MX_get_nz__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get_nz" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get_nz(*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_nz__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get_nz" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get_nz(*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_nz__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::MX *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::MX m4 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get_nz" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get_nz(*arg2,arg3,(casadi::MX const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_nz__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi_int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  
  arg2 = &m2;
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get_nz" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get_nz(*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_nz__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::MX *arg4 = 0 ;
  casadi::Slice *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::MX m4 ;
  casadi::Slice m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get_nz" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "Slice" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get_nz(*arg2,arg3,(casadi::MX const &)*arg4,(casadi::Slice const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_nz__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  casadi::MX *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  casadi::MX m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get_nz" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "MX" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get_nz(*arg2,arg3,(casadi::Slice const &)*arg4,(casadi::MX const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_nz__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::MX *arg4 = 0 ;
  casadi::MX *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::MX m4 ;
  casadi::MX m5 ;
  
  arg2 = &m2;
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_get_nz" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "MX" "'.");
  {
    try {
      ((casadi::MX const *)arg1)->get_nz(*arg2,arg3,(casadi::MX const &)*arg4,(casadi::MX const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_nz(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MX_get_nz", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_MX_get_nz__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          return _wrap_MX_get_nz__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi_int> **>(0));
        if (_v) {
          return _wrap_MX_get_nz__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          return _wrap_MX_get_nz__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Slice **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::MX **>(0));
          if (_v) {
            return _wrap_MX_get_nz__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_MX_get_nz__SWIG_4(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::MX **>(0));
          if (_v) {
            return _wrap_MX_get_nz__SWIG_6(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MX_get_nz'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MX::get_nz(casadi::MX &,bool,casadi::Slice const &) const\n"
    "    casadi::MX::get_nz(casadi::MX &,bool,casadi::Matrix< casadi_int > const &) const\n"
    "    casadi::MX::get_nz(casadi::MX &,bool,casadi::MX const &) const\n"
    "    casadi::MX::get_nz(casadi::MX &,bool,casadi_int) const\n"
    "    casadi::MX::get_nz(casadi::MX &,bool,casadi::MX const &,casadi::Slice const &) const\n"
    "    casadi::MX::get_nz(casadi::MX &,bool,casadi::Slice const &,casadi::MX const &) const\n"
    "    casadi::MX::get_nz(casadi::MX &,bool,casadi::MX const &,casadi::MX const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MX_set_nz__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Slice *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Slice m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set_nz" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Slice" "'.");
  {
    try {
      (arg1)->set_nz((casadi::MX const &)*arg2,arg3,(casadi::Slice const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set_nz__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::Matrix< casadi_int > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< casadi_int > m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set_nz" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "IM" "'.");
  {
    try {
      (arg1)->set_nz((casadi::MX const &)*arg2,arg3,(casadi::Matrix< casadi_int > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set_nz__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi::MX *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::MX m4 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set_nz" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  {
    try {
      (arg1)->set_nz((casadi::MX const &)*arg2,arg3,(casadi::MX const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set_nz__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 ;
  casadi_int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_set_nz" "', argument " "1"" of type '" "casadi::MX *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      (arg1)->set_nz((casadi::MX const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set_nz(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MX_set_nz", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_MX_set_nz__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Slice **>(0));
          if (_v) {
            return _wrap_MX_set_nz__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi_int> **>(0));
          if (_v) {
            return _wrap_MX_set_nz__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__MX, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::MX **>(0));
          if (_v) {
            return _wrap_MX_set_nz__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MX_set_nz'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MX::set_nz(casadi::MX const &,bool,casadi::Slice const &)\n"
    "    casadi::MX::set_nz(casadi::MX const &,bool,casadi::Matrix< casadi_int > const &)\n"
    "    casadi::MX::set_nz(casadi::MX const &,bool,casadi::MX const &)\n"
    "    casadi::MX::set_nz(casadi::MX const &,bool,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MX_einstein__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg7 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg8 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg9 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< casadi_int > m7 ;
  std::vector< casadi_int > m8 ;
  std::vector< casadi_int > m9 ;
  casadi::MX result;
  
  if ((nobjs < 9) || (nobjs > 9)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  arg7 = &m7;
  if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "[" "int" "]" "'.");
  arg8 = &m8;
  if (!casadi::to_ptr(swig_obj[7], &arg8)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 8 to type '" "[" "int" "]" "'.");
  arg9 = &m9;
  if (!casadi::to_ptr(swig_obj[8], &arg9)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 9 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::MX::einstein((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,(std::vector< long long,std::allocator< long long > > const &)*arg7,(std::vector< long long,std::allocator< long long > > const &)*arg8,(std::vector< long long,std::allocator< long long > > const &)*arg9);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_einstein__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg7 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg8 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< casadi_int > m7 ;
  std::vector< casadi_int > m8 ;
  casadi::MX result;
  
  if ((nobjs < 8) || (nobjs > 8)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  arg7 = &m7;
  if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "[" "int" "]" "'.");
  arg8 = &m8;
  if (!casadi::to_ptr(swig_obj[7], &arg8)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 8 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::MX::einstein((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,(std::vector< long long,std::allocator< long long > > const &)*arg7,(std::vector< long long,std::allocator< long long > > const &)*arg8);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_einstein(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[10] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "MX_einstein", 0, 9, argv))) SWIG_fail;
  --argc;
  if (argc == 8) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                _v = casadi::to_ptr(argv[6], static_cast< std::vector<casadi_int> **>(0));
                if (_v) {
                  _v = casadi::to_ptr(argv[7], static_cast< std::vector<casadi_int> **>(0));
                  if (_v) {
                    return _wrap_MX_einstein__SWIG_1(self, argc, argv);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                _v = casadi::to_ptr(argv[6], static_cast< std::vector<casadi_int> **>(0));
                if (_v) {
                  _v = casadi::to_ptr(argv[7], static_cast< std::vector<casadi_int> **>(0));
                  if (_v) {
                    _v = casadi::to_ptr(argv[8], static_cast< std::vector<casadi_int> **>(0));
                    if (_v) {
                      return _wrap_MX_einstein__SWIG_0(self, argc, argv);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'MX_einstein'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MX::einstein(casadi::MX const &,casadi::MX const &,casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::MX::einstein(casadi::MX const &,casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_MX_bspline_dual(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< double,std::allocator< double > > *arg1 = 0 ;
  std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< double > m1 ;
  std::vector< std::vector< double > > m2 ;
  std::vector< casadi_int > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[4] ;
  casadi::DM result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_bspline_dual", 3, 4, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "float" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "[" "float" "]" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::MX::bspline_dual((std::vector< double,std::allocator< double > > const &)*arg1,(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_interpn_linear(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< casadi::MX > m1 ;
  casadi::MX m2 ;
  std::vector< casadi::MX > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[4] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_interpn_linear", 3, 4, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::MX::interpn_linear((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,(casadi::MX const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_printme(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_printme", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_printme" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::MX const *)arg1)->printme((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_attachAssert(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  casadi::MX *arg2 = 0 ;
  std::string const &arg3_defvalue = "" ;
  std::string *arg3 = (std::string *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::string m3 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_attachAssert", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_attachAssert" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  }
  {
    try {
      result = ((casadi::MX const *)arg1)->attachAssert((casadi::MX const &)*arg2,(std::string const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_monitor(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_monitor", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_monitor" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::MX const *)arg1)->monitor((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_mapping(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = (casadi::MX *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< casadi_int > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MX, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_mapping" "', argument " "1"" of type '" "casadi::MX const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MX * >(argp1);
  {
    try {
      result = ((casadi::MX const *)arg1)->mapping();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "IM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_set_max_depth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 = (casadi_int) 1 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_set_max_depth", 0, 1, swig_obj)) SWIG_fail;
  if (swig_obj[0]) {
    if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  }
  {
    try {
      casadi::MX::set_max_depth(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_max_depth(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "MX_get_max_depth", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::MX::get_max_depth();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_test_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObjectInternal *arg1 = (casadi::SharedObjectInternal *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObjectInternal, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MX_test_cast" "', argument " "1"" of type '" "casadi::SharedObjectInternal const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObjectInternal * >(argp1);
  {
    try {
      result = (bool)casadi::MX::test_cast((casadi::SharedObjectInternal const *)arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  casadi::Function m1 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  {
    try {
      result = casadi::MX::get_input((casadi::Function const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MX_get_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  casadi::Function m1 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  {
    try {
      result = casadi::MX::get_free((casadi::Function const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MX_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__MX, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MX_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_Function_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_type_name", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::Function::type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::Function *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::Function *)new casadi::Function();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Function, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  casadi::Function *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (casadi::Function *)new casadi::Function((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Function, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > *arg2 = 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function *result = 0 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "SX" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::Function *)new casadi::Function((std::string const &)*arg1,(std::vector< casadi::SX,std::allocator< casadi::SX > > const &)*arg2,(std::vector< casadi::SX,std::allocator< casadi::SX > > const &)*arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Function, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > *arg2 = 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  std::string m1 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m3 ;
  std::vector< std::string > m4 ;
  std::vector< std::string > m5 ;
  std::map< std::string,casadi::GenericType > m6 ;
  casadi::Function *result = 0 ;
  
  if ((nobjs < 5) || (nobjs > 6)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "SX" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "str" "]" "'.");
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::Function *)new casadi::Function((std::string const &)*arg1,(std::vector< casadi::SX,std::allocator< casadi::SX > > const &)*arg2,(std::vector< casadi::SX,std::allocator< casadi::SX > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(casadi::Dict const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Function, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::map< std::string,casadi::SX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::SX > > > *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  std::string m1 ;
  std::map< std::string,casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< std::string > m3 ;
  std::vector< std::string > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function *result = 0 ;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::Function *)new casadi::Function((std::string const &)*arg1,(std::map< std::string,casadi::SX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::SX > > > const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(casadi::Dict const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Function, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::vector< casadi::MX > m2 ;
  std::vector< casadi::MX > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function *result = 0 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::Function *)new casadi::Function((std::string const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Function, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  std::string m1 ;
  std::vector< casadi::MX > m2 ;
  std::vector< casadi::MX > m3 ;
  std::vector< std::string > m4 ;
  std::vector< std::string > m5 ;
  std::map< std::string,casadi::GenericType > m6 ;
  casadi::Function *result = 0 ;
  
  if ((nobjs < 5) || (nobjs > 6)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "str" "]" "'.");
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::Function *)new casadi::Function((std::string const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(casadi::Dict const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Function, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  std::string m1 ;
  std::map< std::string,casadi::MX > m2 ;
  std::vector< std::string > m3 ;
  std::vector< std::string > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function *result = 0 ;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::Function *)new casadi::Function((std::string const &)*arg1,(std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(casadi::Dict const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Function, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_jit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::vector< std::string > m3 ;
  std::vector< std::string > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function result;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::Function::jit((std::string const &)*arg1,(std::string const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_jit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > *arg5 = 0 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > *arg6 = 0 ;
  casadi::Dict const &arg7_defvalue = casadi::Dict() ;
  casadi::Dict *arg7 = (casadi::Dict *) &arg7_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::vector< std::string > m3 ;
  std::vector< std::string > m4 ;
  std::vector< casadi::Sparsity > m5 ;
  std::vector< casadi::Sparsity > m6 ;
  std::map< std::string,casadi::GenericType > m7 ;
  casadi::Function result;
  
  if ((nobjs < 6) || (nobjs > 7)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "Sparsity" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "Sparsity" "]" "'.");
  if (swig_obj[6]) {
    arg7 = &m7;
    if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::Function::jit((std::string const &)*arg1,(std::string const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)*arg5,(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)*arg6,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_jit(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[8] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_jit", 0, 7, argv))) SWIG_fail;
  --argc;
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::string> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<std::string> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_Function_jit__SWIG_0(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_Function_jit__SWIG_0(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 6) && (argc <= 7)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::string> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<std::string> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector< casadi::Sparsity> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector< casadi::Sparsity> **>(0));
              if (_v) {
                if (argc <= 6) {
                  return _wrap_Function_jit__SWIG_1(self, argc, argv);
                }
                _v = casadi::to_ptr(argv[6], static_cast< std::map<std::string,casadi::GenericType> **>(0));
                if (_v) {
                  return _wrap_Function_jit__SWIG_1(self, argc, argv);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_jit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::jit(std::string const &,std::string const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &)\n"
    "    casadi::Function::jit(std::string const &,std::string const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &,std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Function(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Function" "', argument " "1"" of type '" "casadi::Function *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_expand__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Function result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_expand" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->expand();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_expand__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Function result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_expand" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->expand((std::string const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_expand(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_expand", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_expand__SWIG_0(self, argc, argv);
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_expand__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_Function_expand__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_expand'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::expand() const\n"
    "    casadi::Function::expand(std::string const &,casadi::Dict const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_n_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_n_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->n_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_n_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_n_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->n_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size1_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size1_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->size1_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size1_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size1_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->size1_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size1_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_size1_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_size1_in__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_size1_in__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_size1_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::size1_in(casadi_int) const\n"
    "    casadi::Function::size1_in(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_size2_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size2_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->size2_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size2_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size2_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->size2_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size2_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_size2_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_size2_in__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_size2_in__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_size2_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::size2_in(casadi_int) const\n"
    "    casadi::Function::size2_in(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_size_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::pair< casadi_int,casadi_int > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->size_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "(" "int" "," "int" ")" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::pair< casadi_int,casadi_int > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->size_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "(" "int" "," "int" ")" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_size_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_size_in__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_size_in__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_size_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::size_in(casadi_int) const\n"
    "    casadi::Function::size_in(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_size1_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size1_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->size1_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size1_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size1_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->size1_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size1_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_size1_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_size1_out__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_size1_out__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_size1_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::size1_out(casadi_int) const\n"
    "    casadi::Function::size1_out(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_size2_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size2_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->size2_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size2_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size2_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->size2_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size2_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_size2_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_size2_out__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_size2_out__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_size2_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::size2_out(casadi_int) const\n"
    "    casadi::Function::size2_out(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_size_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::pair< casadi_int,casadi_int > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->size_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "(" "int" "," "int" ")" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::pair< casadi_int,casadi_int > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_size_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->size_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "(" "int" "," "int" ")" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_size_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_size_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_size_out__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_size_out__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_size_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::size_out(casadi_int) const\n"
    "    casadi::Function::size_out(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_nnz_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nnz_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->nnz_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_nnz_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nnz_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->nnz_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_nnz_in__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nnz_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->nnz_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_nnz_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_nnz_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_nnz_in__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_nnz_in__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_nnz_in__SWIG_2(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_nnz_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::nnz_in() const\n"
    "    casadi::Function::nnz_in(casadi_int) const\n"
    "    casadi::Function::nnz_in(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_nnz_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nnz_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->nnz_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_nnz_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nnz_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->nnz_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_nnz_out__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nnz_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->nnz_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_nnz_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_nnz_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_nnz_out__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_nnz_out__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_nnz_out__SWIG_2(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_nnz_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::nnz_out() const\n"
    "    casadi::Function::nnz_out(casadi_int) const\n"
    "    casadi::Function::nnz_out(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_numel_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_numel_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->numel_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_numel_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_numel_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->numel_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_numel_in__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_numel_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->numel_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_numel_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_numel_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_numel_in__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_numel_in__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_numel_in__SWIG_2(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_numel_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::numel_in() const\n"
    "    casadi::Function::numel_in(casadi_int) const\n"
    "    casadi::Function::numel_in(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_numel_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_numel_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->numel_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_numel_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_numel_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->numel_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_numel_out__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_numel_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->numel_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_numel_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_numel_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_numel_out__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_numel_out__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_numel_out__SWIG_2(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_numel_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::numel_out() const\n"
    "    casadi::Function::numel_out(casadi_int) const\n"
    "    casadi::Function::numel_out(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_name_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_name_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (std::vector< std::string,std::allocator< std::string > > *) &((casadi::Function const *)arg1)->name_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_name_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_name_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (std::vector< std::string,std::allocator< std::string > > *) &((casadi::Function const *)arg1)->name_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_name_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_name_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (std::string *) &((casadi::Function const *)arg1)->name_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_name_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_name_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_name_in__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_name_in__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_name_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::name_in() const\n"
    "    casadi::Function::name_in(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_name_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_name_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (std::string *) &((casadi::Function const *)arg1)->name_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_name_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_name_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_name_out__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_name_out__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_name_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::name_out() const\n"
    "    casadi::Function::name_out(casadi_int) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_index_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_index_in", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_index_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->index_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_index_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_index_out", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_index_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->index_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_default_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_default_in", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_default_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (double)((casadi::Function const *)arg1)->default_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_max_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_max_in", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_max_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (double)((casadi::Function const *)arg1)->max_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_min_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_min_in", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_min_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (double)((casadi::Function const *)arg1)->min_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sparsity_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi::Sparsity *) &((casadi::Function const *)arg1)->sparsity_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::Sparsity *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sparsity_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi::Sparsity *) &((casadi::Function const *)arg1)->sparsity_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_sparsity_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_sparsity_in__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_sparsity_in__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_sparsity_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::sparsity_in(casadi_int) const\n"
    "    casadi::Function::sparsity_in(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sparsity_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi::Sparsity *) &((casadi::Function const *)arg1)->sparsity_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::Sparsity *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sparsity_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi::Sparsity *) &((casadi::Function const *)arg1)->sparsity_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_sparsity_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_sparsity_out__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_sparsity_out__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_sparsity_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::sparsity_out(casadi_int) const\n"
    "    casadi::Function::sparsity_out(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_is_diff_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_is_diff_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::Function const *)arg1)->is_diff_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_is_diff_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_is_diff_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (bool)((casadi::Function const *)arg1)->is_diff_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_is_diff_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< bool,std::allocator< bool > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_is_diff_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->is_diff_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "bool" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_is_diff_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_is_diff_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_is_diff_in__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_is_diff_in__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_is_diff_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::is_diff_in(casadi_int) const\n"
    "    casadi::Function::is_diff_in() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_is_diff_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< bool,std::allocator< bool > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_is_diff_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->is_diff_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "bool" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_is_diff_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_is_diff_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_is_diff_out__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_is_diff_out__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_is_diff_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::is_diff_out(casadi_int) const\n"
    "    casadi::Function::is_diff_out() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_factory(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  casadi::Function::AuxOut const &arg5_defvalue = casadi::Function::AuxOut() ;
  casadi::Function::AuxOut *arg5 = (casadi::Function::AuxOut *) &arg5_defvalue ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< std::string > m3 ;
  std::vector< std::string > m4 ;
  std::map< std::string,std::vector< std::string > > m5 ;
  std::map< std::string,casadi::GenericType > m6 ;
  PyObject *swig_obj[6] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_factory", 4, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_factory" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" ":" "[" "str" "]" "'.");
  }
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->factory((std::string const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(casadi::Function::AuxOut const &)*arg5,(casadi::Dict const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_oracle(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Function result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_oracle" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->oracle();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_wrap(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Function result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_wrap" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->wrap();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_wrap_as_needed(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::Dict *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::GenericType > m2 ;
  PyObject *swig_obj[2] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_wrap_as_needed", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_wrap_as_needed" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->wrap_as_needed((casadi::Dict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_which_depends(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  casadi_int arg4 = (casadi_int) 1 ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< std::string > m3 ;
  PyObject *swig_obj[5] ;
  std::vector< bool,std::allocator< bool > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_which_depends", 3, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_which_depends" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  }
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->which_depends((std::string const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "bool" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_print_dimensions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::ostream &arg2_defvalue = casadi::uout() ;
  std::ostream *arg2 = (std::ostream *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &casadi::uout();
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_print_dimensions" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      ((casadi::Function const *)arg1)->print_dimensions(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_print_options(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::ostream &arg2_defvalue = casadi::uout() ;
  std::ostream *arg2 = (std::ostream *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &casadi::uout();
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_print_options" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      ((casadi::Function const *)arg1)->print_options(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_print_option(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::ostream &arg3_defvalue = casadi::uout() ;
  std::ostream *arg3 = (std::ostream *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  
  arg3 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "Function_print_option", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_print_option" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      ((casadi::Function const *)arg1)->print_option((std::string const &)*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_uses_output(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_uses_output" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (bool)((casadi::Function const *)arg1)->uses_output();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_jacobian_old(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_jacobian_old", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_jacobian_old" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->jacobian_old(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_hessian_old(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_hessian_old", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_hessian_old" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->hessian_old(arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_jacobian(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Function result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_jacobian" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->jacobian();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_jac(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Function result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_jac" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->jac();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_call__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > *arg2 = 0 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< double > > m2 ;
  std::vector< casadi::Matrix< double > > m3 ;
  
  arg3 = &m3;
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_call" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Function const *)arg1)->call((std::vector< casadi::DM,std::allocator< casadi::DM > > const &)*arg2,*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_call__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > *arg2 = 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m3 ;
  
  arg3 = &m3;
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_call" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Function const *)arg1)->call((std::vector< casadi::SX,std::allocator< casadi::SX > > const &)*arg2,*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_call__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  std::vector< casadi::MX > m3 ;
  
  arg3 = &m3;
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_call" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Function const *)arg1)->call((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_call__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::DMDict *arg2 = 0 ;
  casadi::DMDict *arg3 = 0 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::Matrix< double > > m2 ;
  std::map< std::string,casadi::Matrix< double > > m3 ;
  
  arg3 = &m3;
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_call" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "DM" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Function const *)arg1)->call((casadi::DMDict const &)*arg2,*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_call__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::SXDict *arg2 = 0 ;
  casadi::SXDict *arg3 = 0 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::Matrix< casadi::SXElem > > m2 ;
  std::map< std::string,casadi::Matrix< casadi::SXElem > > m3 ;
  
  arg3 = &m3;
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_call" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "SX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Function const *)arg1)->call((casadi::SXDict const &)*arg2,*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_call__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::MXDict *arg2 = 0 ;
  casadi::MXDict *arg3 = 0 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::MX > m2 ;
  std::map< std::string,casadi::MX > m3 ;
  
  arg3 = &m3;
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_call" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Function const *)arg1)->call((casadi::MXDict const &)*arg2,*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_call(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_call", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::Matrix<double> > **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_call__SWIG_3(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_call__SWIG_3(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Function_call__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_call__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_call__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Function_call__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_call__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_call__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Function_call__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_call__SWIG_4(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_call__SWIG_4(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Function_call__SWIG_4(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::MX> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_call__SWIG_5(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_call__SWIG_5(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Function_call__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_call__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_call__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Function_call__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_call'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::call(std::vector< casadi::DM,std::allocator< casadi::DM > > const &,std::vector< casadi::DM,std::allocator< casadi::DM > > &,bool,bool) const\n"
    "    casadi::Function::call(std::vector< casadi::SX,std::allocator< casadi::SX > > const &,std::vector< casadi::SX,std::allocator< casadi::SX > > &,bool,bool) const\n"
    "    casadi::Function::call(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > &,bool,bool) const\n"
    "    casadi::Function::call(casadi::DMDict const &,casadi::DMDict &,bool,bool) const\n"
    "    casadi::Function::call(casadi::SXDict const &,casadi::SXDict &,bool,bool) const\n"
    "    casadi::Function::call(casadi::MXDict const &,casadi::MXDict &,bool,bool) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_mapsum(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::string const &arg3_defvalue = "serial" ;
  std::string *arg3 = (std::string *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  std::string m3 ;
  PyObject *swig_obj[3] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_mapsum", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mapsum" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->mapsum((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::string const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mapaccum__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi_int arg3 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mapaccum" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->mapaccum((std::string const &)*arg2,arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mapaccum__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function result;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mapaccum" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->mapaccum((std::string const &)*arg2,arg3,arg4,(casadi::Dict const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mapaccum__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi_int arg3 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::map< std::string,casadi::GenericType > m6 ;
  casadi::Function result;
  
  if ((nobjs < 5) || (nobjs > 6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mapaccum" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->mapaccum((std::string const &)*arg2,arg3,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg4,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg5,(casadi::Dict const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mapaccum__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi_int arg3 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< std::string > m4 ;
  std::vector< std::string > m5 ;
  std::map< std::string,casadi::GenericType > m6 ;
  casadi::Function result;
  
  if ((nobjs < 5) || (nobjs > 6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mapaccum" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "str" "]" "'.");
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->mapaccum((std::string const &)*arg2,arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(casadi::Dict const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mapaccum__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Function result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mapaccum" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->mapaccum(arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mapaccum(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[7] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_mapaccum", 0, 6, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_mapaccum__SWIG_4(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_Function_mapaccum__SWIG_4(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_mapaccum__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_Function_mapaccum__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_Function_mapaccum__SWIG_1(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_Function_mapaccum__SWIG_1(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 5) && (argc <= 6)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<std::string> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<std::string> **>(0));
            if (_v) {
              if (argc <= 5) {
                return _wrap_Function_mapaccum__SWIG_3(self, argc, argv);
              }
              _v = casadi::to_ptr(argv[5], static_cast< std::map<std::string,casadi::GenericType> **>(0));
              if (_v) {
                return _wrap_Function_mapaccum__SWIG_3(self, argc, argv);
              }
            }
          }
        }
      }
    }
  }
  if ((argc >= 5) && (argc <= 6)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              if (argc <= 5) {
                return _wrap_Function_mapaccum__SWIG_2(self, argc, argv);
              }
              _v = casadi::to_ptr(argv[5], static_cast< std::map<std::string,casadi::GenericType> **>(0));
              if (_v) {
                return _wrap_Function_mapaccum__SWIG_2(self, argc, argv);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_mapaccum'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::mapaccum(std::string const &,casadi_int,casadi::Dict const &) const\n"
    "    casadi::Function::mapaccum(std::string const &,casadi_int,casadi_int,casadi::Dict const &) const\n"
    "    casadi::Function::mapaccum(std::string const &,casadi_int,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi::Dict const &) const\n"
    "    casadi::Function::mapaccum(std::string const &,casadi_int,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &) const\n"
    "    casadi::Function::mapaccum(casadi_int,casadi::Dict const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_fold(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::GenericType > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_fold", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_fold" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->fold(arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_map__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  std::string const &arg3_defvalue = "serial" ;
  std::string *arg3 = (std::string *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m3 ;
  casadi::Function result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_map" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->map(arg2,(std::string const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_map__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  std::string *arg3 = 0 ;
  casadi_int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m3 ;
  casadi::Function result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_map" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->map(arg2,(std::string const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_map__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi_int arg4 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  casadi::Dict const &arg7_defvalue = casadi::Dict() ;
  casadi::Dict *arg7 = (casadi::Dict *) &arg7_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string m3 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::map< std::string,casadi::GenericType > m7 ;
  casadi::Function result;
  
  if ((nobjs < 6) || (nobjs > 7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_map" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  if (swig_obj[6]) {
    arg7 = &m7;
    if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->map((std::string const &)*arg2,(std::string const &)*arg3,arg4,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg5,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg6,(casadi::Dict const &)*arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_map__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi_int arg4 ;
  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg6 = 0 ;
  casadi::Dict const &arg7_defvalue = casadi::Dict() ;
  casadi::Dict *arg7 = (casadi::Dict *) &arg7_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string m3 ;
  std::vector< std::string > m5 ;
  std::vector< std::string > m6 ;
  std::map< std::string,casadi::GenericType > m7 ;
  casadi::Function result;
  
  if ((nobjs < 6) || (nobjs > 7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_map" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "str" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "str" "]" "'.");
  if (swig_obj[6]) {
    arg7 = &m7;
    if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->map((std::string const &)*arg2,(std::string const &)*arg3,arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(std::vector< std::string,std::allocator< std::string > > const &)*arg6,(casadi::Dict const &)*arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_map__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  std::vector< bool,std::allocator< bool > > *arg3 = 0 ;
  std::vector< bool,std::allocator< bool > > const &arg4_defvalue = std::vector< bool >() ;
  std::vector< bool,std::allocator< bool > > *arg4 = (std::vector< bool,std::allocator< bool > > *) &arg4_defvalue ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< bool > m3 ;
  std::vector< bool > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_map" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "bool" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "bool" "]" "'.");
  }
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->map(arg2,(std::vector< bool,std::allocator< bool > > const &)*arg3,(std::vector< bool,std::allocator< bool > > const &)*arg4,(casadi::Dict const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_map(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[8] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_map", 0, 7, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_map__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          return _wrap_Function_map__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<bool> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_map__SWIG_4(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<bool> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_Function_map__SWIG_4(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_Function_map__SWIG_4(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_Function_map__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 6) && (argc <= 7)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<std::string> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<std::string> **>(0));
              if (_v) {
                if (argc <= 6) {
                  return _wrap_Function_map__SWIG_3(self, argc, argv);
                }
                _v = casadi::to_ptr(argv[6], static_cast< std::map<std::string,casadi::GenericType> **>(0));
                if (_v) {
                  return _wrap_Function_map__SWIG_3(self, argc, argv);
                }
              }
            }
          }
        }
      }
    }
  }
  if ((argc >= 6) && (argc <= 7)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                if (argc <= 6) {
                  return _wrap_Function_map__SWIG_2(self, argc, argv);
                }
                _v = casadi::to_ptr(argv[6], static_cast< std::map<std::string,casadi::GenericType> **>(0));
                if (_v) {
                  return _wrap_Function_map__SWIG_2(self, argc, argv);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_map'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::map(casadi_int,std::string const &) const\n"
    "    casadi::Function::map(casadi_int,std::string const &,casadi_int) const\n"
    "    casadi::Function::map(std::string const &,std::string const &,casadi_int,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi::Dict const &) const\n"
    "    casadi::Function::map(std::string const &,std::string const &,casadi_int,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &) const\n"
    "    casadi::Function::map(casadi_int,std::vector< bool,std::allocator< bool > > const &,std::vector< bool,std::allocator< bool > > const &,casadi::Dict const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_slice(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  PyObject *swig_obj[5] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_slice", 4, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_slice" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->slice((std::string const &)*arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg4,(casadi::Dict const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_conditional(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::vector< casadi::Function,std::allocator< casadi::Function > > *arg2 = 0 ;
  casadi::Function *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::vector< casadi::Function > m2 ;
  casadi::Function m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[4] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_conditional", 3, 4, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "Function" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "Function" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::Function::conditional((std::string const &)*arg1,(std::vector< casadi::Function,std::allocator< casadi::Function > > const &)*arg2,(casadi::Function const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_bspline(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  casadi_int arg5 = (casadi_int) 1 ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  std::string m1 ;
  std::vector< std::vector< double > > m2 ;
  std::vector< double > m3 ;
  std::vector< casadi_int > m4 ;
  std::map< std::string,casadi::GenericType > m6 ;
  PyObject *swig_obj[6] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_bspline", 4, 6, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "[" "float" "]" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  }
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::Function::bspline((std::string const &)*arg1,(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,arg5,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_if_else(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Function *arg2 = 0 ;
  casadi::Function *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  casadi::Function m2 ;
  casadi::Function m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[4] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_if_else", 3, 4, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Function" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "Function" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::Function::if_else((std::string const &)*arg1,(casadi::Function const &)*arg2,(casadi::Function const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_forward(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_forward", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_forward" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->forward(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_reverse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_reverse", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_reverse" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->reverse(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_jac__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity result;
  
  if ((nobjs < 3) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sparsity_jac" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->sparsity_jac(arg2,arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_jac__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) 0 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::Sparsity result;
  
  if ((nobjs < 2) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sparsity_jac" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->sparsity_jac((std::string const &)*arg2,arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_jac__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  std::string *arg3 = 0 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m3 ;
  casadi::Sparsity result;
  
  if ((nobjs < 3) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sparsity_jac" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->sparsity_jac(arg2,(std::string const &)*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_jac__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool arg4 = (bool) false ;
  bool arg5 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string m3 ;
  casadi::Sparsity result;
  
  if ((nobjs < 3) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sparsity_jac" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->sparsity_jac((std::string const &)*arg2,(std::string const &)*arg3,arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sparsity_jac(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_sparsity_jac", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_sparsity_jac__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_sparsity_jac__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_Function_sparsity_jac__SWIG_1(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< bool **>(0));
            if (_v) {
              return _wrap_Function_sparsity_jac__SWIG_1(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_sparsity_jac__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_Function_sparsity_jac__SWIG_0(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< bool **>(0));
            if (_v) {
              return _wrap_Function_sparsity_jac__SWIG_0(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_sparsity_jac__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_Function_sparsity_jac__SWIG_2(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< bool **>(0));
            if (_v) {
              return _wrap_Function_sparsity_jac__SWIG_2(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_sparsity_jac__SWIG_3(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_Function_sparsity_jac__SWIG_3(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< bool **>(0));
            if (_v) {
              return _wrap_Function_sparsity_jac__SWIG_3(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_sparsity_jac'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::sparsity_jac(casadi_int,casadi_int,bool,bool) const\n"
    "    casadi::Function::sparsity_jac(std::string const &,casadi_int,bool,bool) const\n"
    "    casadi::Function::sparsity_jac(casadi_int,std::string const &,bool,bool) const\n"
    "    casadi::Function::sparsity_jac(std::string const &,std::string const &,bool,bool) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_generate__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  std::string result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_generate" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->generate((std::string const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_generate__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::Dict const &arg2_defvalue = casadi::Dict() ;
  casadi::Dict *arg2 = (casadi::Dict *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::GenericType > m2 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_generate" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->generate((casadi::Dict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_generate(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_generate", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      if (argc <= 1) {
        return _wrap_Function_generate__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::GenericType> **>(0));
      if (_v) {
        return _wrap_Function_generate__SWIG_1(self, argc, argv);
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_generate__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_Function_generate__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_generate'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::generate(std::string const &,casadi::Dict const &) const\n"
    "    casadi::Function::generate(casadi::Dict const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_generate_dependencies(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  PyObject *swig_obj[3] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_generate_dependencies", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_generate_dependencies" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->generate_dependencies((std::string const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_generate_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< casadi::Matrix< double > > m3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_generate_in" "', argument " "1"" of type '" "casadi::Function *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "DM" "]" "'.");
  {
    try {
      (arg1)->generate_in((std::string const &)*arg2,(std::vector< casadi::DM,std::allocator< casadi::DM > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_generate_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_generate_in" "', argument " "1"" of type '" "casadi::Function *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (arg1)->generate_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_generate_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_generate_in", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_generate_in__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector< casadi::Matrix<double> > **>(0));
        if (_v) {
          return _wrap_Function_generate_in__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_generate_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::generate_in(std::string const &,std::vector< casadi::DM,std::allocator< casadi::DM > > const &)\n"
    "    casadi::Function::generate_in(std::string const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_generate_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< casadi::Matrix< double > > m3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_generate_out" "', argument " "1"" of type '" "casadi::Function *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "DM" "]" "'.");
  {
    try {
      (arg1)->generate_out((std::string const &)*arg2,(std::vector< casadi::DM,std::allocator< casadi::DM > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_generate_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_generate_out" "', argument " "1"" of type '" "casadi::Function *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (arg1)->generate_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_generate_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_generate_out", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_generate_out__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector< casadi::Matrix<double> > **>(0));
        if (_v) {
          return _wrap_Function_generate_out__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_generate_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::generate_out(std::string const &,std::vector< casadi::DM,std::allocator< casadi::DM > > const &)\n"
    "    casadi::Function::generate_out(std::string const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_export_code__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_export_code" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      ((casadi::Function const *)arg1)->export_code((std::string const &)*arg2,(std::string const &)*arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_serialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::Dict const &arg2_defvalue = casadi::Dict() ;
  casadi::Dict *arg2 = (casadi::Dict *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::GenericType > m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_serialize", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_serialize" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->serialize((casadi::Dict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_save(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_save", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_save" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      ((casadi::Function const *)arg1)->save((std::string const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_export_code__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  std::string result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_export_code" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->export_code((std::string const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_export_code(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_export_code", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Function_export_code__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_Function_export_code__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Function_export_code__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_Function_export_code__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_export_code'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::export_code(std::string const &,std::string const &,casadi::Dict const &) const\n"
    "    casadi::Function::export_code(std::string const &,casadi::Dict const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_stats(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  int arg2 = (int) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::Dict result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_stats", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_stats" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Function_stats" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  {
    try {
      result = ((casadi::Function const *)arg1)->stats(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sx_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::SX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sx_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->sx_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sx_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::SX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sx_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->sx_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sx_in__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sx_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->sx_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sx_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_sx_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_sx_in__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_sx_in__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_sx_in__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_sx_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::sx_in(casadi_int) const\n"
    "    casadi::Function::sx_in(std::string const &) const\n"
    "    casadi::Function::sx_in() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_mx_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mx_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->mx_in(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mx_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mx_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->mx_in((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mx_in__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mx_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->mx_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mx_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_mx_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_mx_in__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_mx_in__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_mx_in__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_mx_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::mx_in(casadi_int) const\n"
    "    casadi::Function::mx_in(std::string const &) const\n"
    "    casadi::Function::mx_in() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_sx_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::SX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sx_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->sx_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sx_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::SX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sx_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->sx_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sx_out__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sx_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->sx_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sx_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_sx_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_sx_out__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_sx_out__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_sx_out__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_sx_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::sx_out(casadi_int) const\n"
    "    casadi::Function::sx_out(std::string const &) const\n"
    "    casadi::Function::sx_out() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_mx_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mx_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->mx_out(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mx_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mx_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->mx_out((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mx_out__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_mx_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->mx_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_mx_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_mx_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_mx_out__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_Function_mx_out__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_mx_out__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_mx_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::mx_out(casadi_int) const\n"
    "    casadi::Function::mx_out(std::string const &) const\n"
    "    casadi::Function::mx_out() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_nz_from_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< double > > m2 ;
  PyObject *swig_obj[2] ;
  std::vector< double,std::allocator< double > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_nz_from_in", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nz_from_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->nz_from_in((std::vector< casadi::DM,std::allocator< casadi::DM > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_nz_from_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< double > > m2 ;
  PyObject *swig_obj[2] ;
  std::vector< double,std::allocator< double > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_nz_from_out", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nz_from_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->nz_from_out((std::vector< casadi::DM,std::allocator< casadi::DM > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_nz_to_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< double,std::allocator< double > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< double > m2 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_nz_to_in", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nz_to_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "float" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->nz_to_in((std::vector< double,std::allocator< double > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_nz_to_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< double,std::allocator< double > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< double > m2 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_nz_to_out", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_nz_to_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "float" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->nz_to_out((std::vector< double,std::allocator< double > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< double > > m2 ;
  casadi::DMDict result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_in((std::vector< casadi::DM,std::allocator< casadi::DM > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" ":" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::DMDict *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::Matrix< double > > m2 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "DM" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_in((casadi::DMDict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< double > > m2 ;
  casadi::DMDict result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_out((std::vector< casadi::DM,std::allocator< casadi::DM > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" ":" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::DMDict *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::Matrix< double > > m2 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "DM" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_out((casadi::DMDict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_in__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  casadi::SXDict result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_in((std::vector< casadi::SX,std::allocator< casadi::SX > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" ":" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_in__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::SXDict *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "SX" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_in((casadi::SXDict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_out__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  casadi::SXDict result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_out((std::vector< casadi::SX,std::allocator< casadi::SX > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" ":" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_out__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::SXDict *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "SX" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_out((casadi::SXDict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_in__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  casadi::MXDict result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_in((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" ":" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_in__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::MXDict *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::MX > m2 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "MX" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_in((casadi::MXDict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_convert_in", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::Matrix<double> > **>(0));
      if (_v) {
        return _wrap_Function_convert_in__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        return _wrap_Function_convert_in__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        return _wrap_Function_convert_in__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        return _wrap_Function_convert_in__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::MX> **>(0));
      if (_v) {
        return _wrap_Function_convert_in__SWIG_5(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        return _wrap_Function_convert_in__SWIG_4(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_convert_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::convert_in(std::vector< casadi::DM,std::allocator< casadi::DM > > const &) const\n"
    "    casadi::Function::convert_in(casadi::DMDict const &) const\n"
    "    casadi::Function::convert_in(std::vector< casadi::SX,std::allocator< casadi::SX > > const &) const\n"
    "    casadi::Function::convert_in(casadi::SXDict const &) const\n"
    "    casadi::Function::convert_in(std::vector< casadi::MX,std::allocator< casadi::MX > > const &) const\n"
    "    casadi::Function::convert_in(casadi::MXDict const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_convert_out__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  casadi::MXDict result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_out((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" ":" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_out__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::MXDict *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::MX > m2 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_convert_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "MX" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->convert_out((casadi::MXDict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_convert_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_convert_out", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::Matrix<double> > **>(0));
      if (_v) {
        return _wrap_Function_convert_out__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        return _wrap_Function_convert_out__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        return _wrap_Function_convert_out__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        return _wrap_Function_convert_out__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::MX> **>(0));
      if (_v) {
        return _wrap_Function_convert_out__SWIG_5(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        return _wrap_Function_convert_out__SWIG_4(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_convert_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::convert_out(std::vector< casadi::DM,std::allocator< casadi::DM > > const &) const\n"
    "    casadi::Function::convert_out(casadi::DMDict const &) const\n"
    "    casadi::Function::convert_out(std::vector< casadi::SX,std::allocator< casadi::SX > > const &) const\n"
    "    casadi::Function::convert_out(casadi::SXDict const &) const\n"
    "    casadi::Function::convert_out(std::vector< casadi::MX,std::allocator< casadi::MX > > const &) const\n"
    "    casadi::Function::convert_out(casadi::MXDict const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_has_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_has_free" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (bool)((casadi::Function const *)arg1)->has_free();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_get_free(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_get_free" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->get_free();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_free_sx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::SX,std::allocator< casadi::SX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_free_sx" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->free_sx();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_free_mx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_free_mx" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->free_mx();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_generate_lifted(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi::Function *arg2 = 0 ;
  casadi::Function *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Function m2 ;
  casadi::Function m3 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &m2;
  arg3 = &m3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_generate_lifted" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      ((casadi::Function const *)arg1)->generate_lifted(*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_n_nodes(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_n_nodes" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->n_nodes();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_n_instructions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_n_instructions" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->n_instructions();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_instruction_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_instruction_id", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_instruction_id" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->instruction_id(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_instruction_input(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_instruction_input", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_instruction_input" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->instruction_input(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_instruction_constant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_instruction_constant", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_instruction_constant" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = (double)((casadi::Function const *)arg1)->instruction_constant(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_instruction_output(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_instruction_output", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_instruction_output" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->instruction_output(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_instruction_MX(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_instruction_MX", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_instruction_MX" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->instruction_MX(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_instructions_sx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::SX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_instructions_sx" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->instructions_sx();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_has_spfwd(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_has_spfwd" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (bool)((casadi::Function const *)arg1)->has_spfwd();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_has_sprev(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_has_sprev" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (bool)((casadi::Function const *)arg1)->has_sprev();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sz_arg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sz_arg" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->sz_arg();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sz_res(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sz_res" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->sz_res();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sz_iw(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sz_iw" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->sz_iw();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_sz_w(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_sz_w" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->sz_w();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_name" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_is_a(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_is_a", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_is_a" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = (bool)((casadi::Function const *)arg1)->is_a((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_check_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::Function::check_name((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_fix_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::Function::fix_name((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_deserialize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::istream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Function result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_std__istream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_deserialize" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Function_deserialize" "', argument " "1"" of type '" "std::istream &""'"); 
  }
  arg1 = reinterpret_cast< std::istream * >(argp1);
  {
    try {
      result = casadi::Function::deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_deserialize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  casadi::Function result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::Function::deserialize((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_load(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  casadi::Function result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::Function::load((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_deserialize__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DeserializingStream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Function result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__DeserializingStream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Function_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializingStream * >(argp1);
  {
    try {
      result = casadi::Function::deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_deserialize(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_deserialize", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_std__istream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_deserialize__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DeserializingStream, SWIG_POINTER_NO_NULL);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_deserialize__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      return _wrap_Function_deserialize__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_deserialize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::deserialize(std::istream &)\n"
    "    casadi::Function::deserialize(std::string const &)\n"
    "    casadi::Function::deserialize(casadi::DeserializingStream &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_assert_size_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_assert_size_in", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_assert_size_in" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      ((casadi::Function const *)arg1)->assert_size_in(arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_assert_size_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi_int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_assert_size_out", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_assert_size_out" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  {
    try {
      ((casadi::Function const *)arg1)->assert_size_out(arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_checkout(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_checkout" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Function const *)arg1)->checkout();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_release(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_release", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_release" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Function_release" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      ((casadi::Function const *)arg1)->release(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_get_function__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_get_function" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->get_function();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_get_function__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::Function result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_get_function" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::Function const *)arg1)->get_function((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_get_function(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Function_get_function", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Function_get_function__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Function, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_Function_get_function__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Function_get_function'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::get_function() const\n"
    "    casadi::Function::get_function(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Function_has_function(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Function_has_function", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_has_function" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (bool)((casadi::Function const *)arg1)->has_function((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Function_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = (casadi::Function *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Function, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Function_info" "', argument " "1"" of type '" "casadi::Function const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Function * >(argp1);
  {
    try {
      result = ((casadi::Function const *)arg1)->info();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function__SWIG_8(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  casadi::Function m1 ;
  casadi::Function *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  {
    result = (casadi::Function *)new casadi::Function((casadi::Function const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Function, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Function(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[7] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Function", 0, 6, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_Function__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      return _wrap_new_Function__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Function **>(0));
    if (_v) {
      return _wrap_new_Function__SWIG_8(self, argc, argv);
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_new_Function__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_new_Function__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_new_Function__SWIG_5(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_new_Function__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::string> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<std::string> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_new_Function__SWIG_4(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_new_Function__SWIG_4(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::string> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<std::string> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_new_Function__SWIG_7(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_new_Function__SWIG_7(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 5) && (argc <= 6)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<std::string> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<std::string> **>(0));
            if (_v) {
              if (argc <= 5) {
                return _wrap_new_Function__SWIG_3(self, argc, argv);
              }
              _v = casadi::to_ptr(argv[5], static_cast< std::map<std::string,casadi::GenericType> **>(0));
              if (_v) {
                return _wrap_new_Function__SWIG_3(self, argc, argv);
              }
            }
          }
        }
      }
    }
  }
  if ((argc >= 5) && (argc <= 6)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<std::string> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<std::string> **>(0));
            if (_v) {
              if (argc <= 5) {
                return _wrap_new_Function__SWIG_6(self, argc, argv);
              }
              _v = casadi::to_ptr(argv[5], static_cast< std::map<std::string,casadi::GenericType> **>(0));
              if (_v) {
                return _wrap_new_Function__SWIG_6(self, argc, argv);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Function'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Function::Function()\n"
    "    casadi::Function::Function(std::string const &)\n"
    "    casadi::Function::Function(std::string const &,std::vector< casadi::SX,std::allocator< casadi::SX > > const &,std::vector< casadi::SX,std::allocator< casadi::SX > > const &,casadi::Dict const &)\n"
    "    casadi::Function::Function(std::string const &,std::vector< casadi::SX,std::allocator< casadi::SX > > const &,std::vector< casadi::SX,std::allocator< casadi::SX > > const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &)\n"
    "    casadi::Function::Function(std::string const &,std::map< std::string,casadi::SX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::SX > > > const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &)\n"
    "    casadi::Function::Function(std::string const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,casadi::Dict const &)\n"
    "    casadi::Function::Function(std::string const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &)\n"
    "    casadi::Function::Function(std::string const &,std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &)\n"
    "    casadi::Function::Function(casadi::Function const &)\n");
  return 0;
}


SWIGINTERN PyObject *Function_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__Function, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Function_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_FunctionBuffer__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  casadi::Function m1 ;
  casadi::FunctionBuffer *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  {
    try {
      result = (casadi::FunctionBuffer *)new casadi::FunctionBuffer((casadi::Function const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__FunctionBuffer, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionBuffer_set_arg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::FunctionBuffer *arg1 = (casadi::FunctionBuffer *) 0 ;
  casadi_int arg2 ;
  double *arg3 = (double *) 0 ;
  casadi_int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Py_buffer *buffer3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "FunctionBuffer_set_arg", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__FunctionBuffer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionBuffer_set_arg" "', argument " "1"" of type '" "casadi::FunctionBuffer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::FunctionBuffer * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!PyMemoryView_Check(swig_obj[2])) SWIG_exception_fail(SWIG_TypeError, "Must supply a MemoryView.");
  buffer3 = PyMemoryView_GET_BUFFER(swig_obj[2]);
  arg3 = static_cast<double*>(buffer3->buf); // const double cast comes later
  arg4 = buffer3->len;
  {
    try {
      (arg1)->set_arg(arg2,(double const *)arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionBuffer_set_res(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::FunctionBuffer *arg1 = (casadi::FunctionBuffer *) 0 ;
  casadi_int arg2 ;
  double *arg3 = (double *) 0 ;
  casadi_int arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Py_buffer *buffer3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "FunctionBuffer_set_res", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__FunctionBuffer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionBuffer_set_res" "', argument " "1"" of type '" "casadi::FunctionBuffer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::FunctionBuffer * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!PyMemoryView_Check(swig_obj[2])) SWIG_exception_fail(SWIG_TypeError, "Must supply a writable MemoryView.");
  buffer3 = PyMemoryView_GET_BUFFER(swig_obj[2]);
  if (buffer3->readonly) SWIG_exception_fail(SWIG_TypeError, "Must supply a writable MemoryView.");
  arg3 = static_cast<double*>(buffer3->buf);
  arg4 = buffer3->len;
  {
    try {
      (arg1)->set_res(arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionBuffer_ret(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::FunctionBuffer *arg1 = (casadi::FunctionBuffer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__FunctionBuffer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionBuffer_ret" "', argument " "1"" of type '" "casadi::FunctionBuffer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::FunctionBuffer * >(argp1);
  {
    try {
      result = (int)(arg1)->ret();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionBuffer__eval(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::FunctionBuffer *arg1 = (casadi::FunctionBuffer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__FunctionBuffer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionBuffer__eval" "', argument " "1"" of type '" "casadi::FunctionBuffer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::FunctionBuffer * >(argp1);
  {
    try {
      (arg1)->_eval();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_FunctionBuffer__self(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::FunctionBuffer *arg1 = (casadi::FunctionBuffer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  void *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__FunctionBuffer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "FunctionBuffer__self" "', argument " "1"" of type '" "casadi::FunctionBuffer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::FunctionBuffer * >(argp1);
  {
    try {
      result = (void *)(arg1)->_self();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = PyCapsule_New(result, NULL,NULL);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FunctionBuffer__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::FunctionBuffer *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::FunctionBuffer *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__FunctionBuffer,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_FunctionBuffer" "', argument " "1"" of type '" "casadi::FunctionBuffer const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_FunctionBuffer" "', argument " "1"" of type '" "casadi::FunctionBuffer const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::FunctionBuffer * >(argp1);
  {
    result = (casadi::FunctionBuffer *)new casadi::FunctionBuffer((casadi::FunctionBuffer const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__FunctionBuffer, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_FunctionBuffer(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_FunctionBuffer", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__FunctionBuffer, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_FunctionBuffer__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Function **>(0));
    if (_v) {
      return _wrap_new_FunctionBuffer__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_FunctionBuffer'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::FunctionBuffer::FunctionBuffer(casadi::Function const &)\n"
    "    casadi::FunctionBuffer::FunctionBuffer(casadi::FunctionBuffer const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_FunctionBuffer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::FunctionBuffer *arg1 = (casadi::FunctionBuffer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__FunctionBuffer, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FunctionBuffer" "', argument " "1"" of type '" "casadi::FunctionBuffer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::FunctionBuffer * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *FunctionBuffer_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__FunctionBuffer, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *FunctionBuffer_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap__function_buffer_eval(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  void *arg1 = (void *) 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = PyCapsule_GetPointer(swig_obj[0], NULL);
  {
    try {
      casadi::_function_buffer_eval(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_external__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Dict const &arg2_defvalue = casadi::Dict() ;
  casadi::Dict *arg2 = (casadi::Dict *) &arg2_defvalue ;
  std::string m1 ;
  std::map< std::string,casadi::GenericType > m2 ;
  casadi::Function result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::external((std::string const &)*arg1,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_external__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Function result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::external((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_external__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Importer *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  std::string m1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Function result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__Importer,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "external" "', argument " "2"" of type '" "casadi::Importer const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "external" "', argument " "2"" of type '" "casadi::Importer const &""'"); 
  }
  arg2 = reinterpret_cast< casadi::Importer * >(argp2);
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::external((std::string const &)*arg1,(casadi::Importer const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_external(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "external", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_external__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::GenericType> **>(0));
      if (_v) {
        return _wrap_external__SWIG_0(self, argc, argv);
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_casadi__Importer, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        if (argc <= 2) {
          return _wrap_external__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_external__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_external__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_external__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'external'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::external(std::string const &,casadi::Dict const &)\n"
    "    casadi::external(std::string const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::external(std::string const &,casadi::Importer const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_integrator__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::SXDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::Matrix< casadi::SXElem > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "SX" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::integrator((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::Matrix< casadi::SXElem >,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::Matrix< casadi::SXElem > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_integrator__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::MXDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::MX > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "MX" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::integrator((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_integrator(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "integrator", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::Matrix<casadi::SXElem> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_integrator__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_integrator__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::MX> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_integrator__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_integrator__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'integrator'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::integrator(std::string const &,std::string const &,casadi::SXDict const &,casadi::Dict const &)\n"
    "    casadi::integrator(std::string const &,std::string const &,casadi::MXDict const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_has_integrator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::has_integrator((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_load_integrator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::load_integrator((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doc_integrator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::doc_integrator((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_integrator_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::integrator_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_integrator_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::integrator_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_integrator_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::integrator_in(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_integrator_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "integrator_in", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_integrator_in__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_integrator_in__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'integrator_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::integrator_in()\n"
    "    casadi::integrator_in(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_integrator_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::integrator_out(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_integrator_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "integrator_out", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_integrator_out__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_integrator_out__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'integrator_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::integrator_out()\n"
    "    casadi::integrator_out(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_integrator_n_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "integrator_n_in", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::integrator_n_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_integrator_n_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "integrator_n_out", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::integrator_n_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::SpDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::Sparsity > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[4] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "conic", 3, 4, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "Sparsity" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::conic((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::Sparsity,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::Sparsity > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_qpsol__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::SXDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::Matrix< casadi::SXElem > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "SX" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::qpsol((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::Matrix< casadi::SXElem >,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::Matrix< casadi::SXElem > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_qpsol__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::MXDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::MX > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "MX" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::qpsol((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_qpsol(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "qpsol", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::Matrix<casadi::SXElem> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_qpsol__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_qpsol__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::MX> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_qpsol__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_qpsol__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'qpsol'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::qpsol(std::string const &,std::string const &,casadi::SXDict const &,casadi::Dict const &)\n"
    "    casadi::qpsol(std::string const &,std::string const &,casadi::MXDict const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_conic_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::conic_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::conic_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::conic_in(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "conic_in", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_conic_in__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_conic_in__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'conic_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::conic_in()\n"
    "    casadi::conic_in(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_conic_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::conic_out(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "conic_out", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_conic_out__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_conic_out__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'conic_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::conic_out()\n"
    "    casadi::conic_out(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_conic_n_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "conic_n_in", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::conic_n_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_n_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "conic_n_out", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::conic_n_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_options(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::conic_options((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_option_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "conic_option_type", 2, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = casadi::conic_option_type((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_option_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "conic_option_info", 2, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = casadi::conic_option_info((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_has_conic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::has_conic((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_load_conic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::load_conic((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doc_conic(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::doc_conic((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_debug__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Function m1 ;
  std::string m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      casadi::conic_debug((casadi::Function const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_debug__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Function *arg1 = 0 ;
  std::ostream *arg2 = 0 ;
  casadi::Function m1 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_std__ostream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "conic_debug" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "conic_debug" "', argument " "2"" of type '" "std::ostream &""'"); 
  }
  arg2 = reinterpret_cast< std::ostream * >(argp2);
  {
    try {
      casadi::conic_debug((casadi::Function const &)*arg1,*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conic_debug(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "conic_debug", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Function **>(0));
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_std__ostream, SWIG_POINTER_NO_NULL);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_conic_debug__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Function **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_conic_debug__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'conic_debug'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::conic_debug(casadi::Function const &,std::string const &)\n"
    "    casadi::conic_debug(casadi::Function const &,std::ostream &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_nlpsol__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::SXDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::Matrix< casadi::SXElem > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "SX" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::nlpsol((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::Matrix< casadi::SXElem >,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::Matrix< casadi::SXElem > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::MXDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::MX > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "MX" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::nlpsol((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::string m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::nlpsol((std::string const &)*arg1,(std::string const &)*arg2,(std::string const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Importer *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_casadi__Importer,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "nlpsol" "', argument " "3"" of type '" "casadi::Importer const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "nlpsol" "', argument " "3"" of type '" "casadi::Importer const &""'"); 
  }
  arg3 = reinterpret_cast< casadi::Importer * >(argp3);
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::nlpsol((std::string const &)*arg1,(std::string const &)*arg2,(casadi::Importer const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::NlpBuilder *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_casadi__NlpBuilder,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "nlpsol" "', argument " "3"" of type '" "casadi::NlpBuilder const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "nlpsol" "', argument " "3"" of type '" "casadi::NlpBuilder const &""'"); 
  }
  arg3 = reinterpret_cast< casadi::NlpBuilder * >(argp3);
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::nlpsol((std::string const &)*arg1,(std::string const &)*arg2,(casadi::NlpBuilder const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "nlpsol", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_casadi__Importer, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          if (argc <= 3) {
            return _wrap_nlpsol__SWIG_3(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_nlpsol__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_casadi__NlpBuilder, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          if (argc <= 3) {
            return _wrap_nlpsol__SWIG_4(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_nlpsol__SWIG_4(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::Matrix<casadi::SXElem> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_nlpsol__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_nlpsol__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::MX> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_nlpsol__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_nlpsol__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_nlpsol__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_nlpsol__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'nlpsol'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::nlpsol(std::string const &,std::string const &,casadi::SXDict const &,casadi::Dict const &)\n"
    "    casadi::nlpsol(std::string const &,std::string const &,casadi::MXDict const &,casadi::Dict const &)\n"
    "    casadi::nlpsol(std::string const &,std::string const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::nlpsol(std::string const &,std::string const &,casadi::Importer const &,casadi::Dict const &)\n"
    "    casadi::nlpsol(std::string const &,std::string const &,casadi::NlpBuilder const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_nlpsol_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::nlpsol_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::nlpsol_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::nlpsol_in(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "nlpsol_in", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_nlpsol_in__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_nlpsol_in__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'nlpsol_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::nlpsol_in()\n"
    "    casadi::nlpsol_in(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_nlpsol_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::nlpsol_out(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "nlpsol_out", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_nlpsol_out__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_nlpsol_out__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'nlpsol_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::nlpsol_out()\n"
    "    casadi::nlpsol_out(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_nlpsol_n_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "nlpsol_n_in", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::nlpsol_n_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_n_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "nlpsol_n_out", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::nlpsol_n_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_default_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = (double)casadi::nlpsol_default_in(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_default_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< double,std::allocator< double > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::nlpsol_default_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_default_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "nlpsol_default_in", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_nlpsol_default_in__SWIG_1(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_nlpsol_default_in__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'nlpsol_default_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::nlpsol_default_in(casadi_int)\n"
    "    casadi::nlpsol_default_in()\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_nlpsol_options(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::nlpsol_options((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_option_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "nlpsol_option_type", 2, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = casadi::nlpsol_option_type((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nlpsol_option_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "nlpsol_option_info", 2, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = casadi::nlpsol_option_info((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_has_nlpsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::has_nlpsol((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_load_nlpsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::load_nlpsol((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doc_nlpsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::doc_nlpsol((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::SXDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::Matrix< casadi::SXElem > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "SX" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::rootfinder((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::Matrix< casadi::SXElem >,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::Matrix< casadi::SXElem > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::MXDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::MX > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "MX" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::rootfinder((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Function *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  casadi::Function m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "Function" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::rootfinder((std::string const &)*arg1,(std::string const &)*arg2,(casadi::Function const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "rootfinder", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::Matrix<casadi::SXElem> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_rootfinder__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_rootfinder__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::MX> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_rootfinder__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_rootfinder__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Function **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_rootfinder__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_rootfinder__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'rootfinder'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::rootfinder(std::string const &,std::string const &,casadi::SXDict const &,casadi::Dict const &)\n"
    "    casadi::rootfinder(std::string const &,std::string const &,casadi::MXDict const &,casadi::Dict const &)\n"
    "    casadi::rootfinder(std::string const &,std::string const &,casadi::Function const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_rootfinder_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::rootfinder_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::rootfinder_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::rootfinder_in(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "rootfinder_in", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_rootfinder_in__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_rootfinder_in__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'rootfinder_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::rootfinder_in()\n"
    "    casadi::rootfinder_in(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_rootfinder_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::rootfinder_out(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "rootfinder_out", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_rootfinder_out__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_rootfinder_out__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'rootfinder_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::rootfinder_out()\n"
    "    casadi::rootfinder_out(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_rootfinder_n_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "rootfinder_n_in", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::rootfinder_n_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder_n_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "rootfinder_n_out", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::rootfinder_n_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder_options(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::rootfinder_options((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder_option_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "rootfinder_option_type", 2, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = casadi::rootfinder_option_type((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rootfinder_option_info(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::string m1 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "rootfinder_option_info", 2, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = casadi::rootfinder_option_info((std::string const &)*arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_has_rootfinder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::has_rootfinder((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_load_rootfinder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::load_rootfinder((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doc_rootfinder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::doc_rootfinder((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Linsol_type_name", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::Linsol::type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Linsol__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::Linsol *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::Linsol *)new casadi::Linsol();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Linsol, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Linsol__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Sparsity *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  casadi::Sparsity m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Linsol *result = 0 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "Sparsity" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::Linsol *)new casadi::Linsol((std::string const &)*arg1,(std::string const &)*arg2,(casadi::Sparsity const &)*arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Linsol, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_has_plugin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::Linsol::has_plugin((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_load_plugin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::Linsol::load_plugin((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_doc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::Linsol::doc((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_plugin_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Linsol_plugin_name" "', argument " "1"" of type '" "casadi::Linsol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  {
    try {
      result = ((casadi::Linsol const *)arg1)->plugin_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Linsol_sparsity" "', argument " "1"" of type '" "casadi::Linsol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  {
    try {
      result = (casadi::Sparsity *) &((casadi::Linsol const *)arg1)->sparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_sfact(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  casadi::DM *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Linsol_sfact", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Linsol_sfact" "', argument " "1"" of type '" "casadi::Linsol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      ((casadi::Linsol const *)arg1)->sfact((casadi::DM const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_nfact(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  casadi::DM *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Linsol_nfact", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Linsol_nfact" "', argument " "1"" of type '" "casadi::Linsol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      ((casadi::Linsol const *)arg1)->nfact((casadi::DM const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_solve__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  casadi::DM *arg2 = 0 ;
  casadi::DM *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::DM result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Linsol_solve" "', argument " "1"" of type '" "casadi::Linsol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Linsol const *)arg1)->solve((casadi::DM const &)*arg2,(casadi::DM const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_solve__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Linsol_solve" "', argument " "1"" of type '" "casadi::Linsol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Linsol const *)arg1)->solve((casadi::MX const &)*arg2,(casadi::MX const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_solve(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Linsol_solve", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Linsol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Linsol_solve__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Linsol_solve__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Linsol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_Linsol_solve__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_Linsol_solve__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Linsol_solve'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Linsol::solve(casadi::DM const &,casadi::DM const &,bool) const\n"
    "    casadi::Linsol::solve(casadi::MX const &,casadi::MX const &,bool) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Linsol_neig(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  casadi::DM *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  PyObject *swig_obj[2] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Linsol_neig", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Linsol_neig" "', argument " "1"" of type '" "casadi::Linsol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = (casadi_int)((casadi::Linsol const *)arg1)->neig((casadi::DM const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_rank(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  casadi::DM *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  PyObject *swig_obj[2] ;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Linsol_rank", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Linsol_rank" "', argument " "1"" of type '" "casadi::Linsol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = (casadi_int)((casadi::Linsol const *)arg1)->rank((casadi::DM const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Linsol_stats(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  int arg2 = (int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::Dict result;
  
  if (!SWIG_Python_UnpackTuple(args, "Linsol_stats", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Linsol_stats" "', argument " "1"" of type '" "casadi::Linsol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  if (swig_obj[1]) {
    ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
    if (!SWIG_IsOK(ecode2)) {
      SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "Linsol_stats" "', argument " "2"" of type '" "int""'");
    } 
    arg2 = static_cast< int >(val2);
  }
  {
    try {
      result = ((casadi::Linsol const *)arg1)->stats(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Linsol__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Linsol *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__Linsol,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Linsol" "', argument " "1"" of type '" "casadi::Linsol const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Linsol" "', argument " "1"" of type '" "casadi::Linsol const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  {
    result = (casadi::Linsol *)new casadi::Linsol((casadi::Linsol const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Linsol, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Linsol(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Linsol", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_Linsol__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__Linsol, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Linsol__SWIG_2(self, argc, argv);
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Sparsity **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_new_Linsol__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_new_Linsol__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Linsol'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Linsol::Linsol()\n"
    "    casadi::Linsol::Linsol(std::string const &,std::string const &,casadi::Sparsity const &,casadi::Dict const &)\n"
    "    casadi::Linsol::Linsol(casadi::Linsol const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Linsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Linsol *arg1 = (casadi::Linsol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Linsol, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Linsol" "', argument " "1"" of type '" "casadi::Linsol *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Linsol * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Linsol_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__Linsol, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Linsol_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_has_linsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::has_linsol((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_load_linsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::load_linsol((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doc_linsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::doc_linsol((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dplesol__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::SpDict *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::Sparsity > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "Sparsity" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::dplesol((std::string const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::Sparsity,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::Sparsity > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dplesol__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  std::string m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::dplesol((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(std::string const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dplesol__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MXVector *arg1 = 0 ;
  casadi::MXVector *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< casadi::MX > m1 ;
  std::vector< casadi::MX > m2 ;
  std::string m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::MXVector result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::dplesol((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::string const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dplesol__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DMVector *arg1 = 0 ;
  casadi::DMVector *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< casadi::Matrix< double > > m1 ;
  std::vector< casadi::Matrix< double > > m2 ;
  std::string m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::DMVector result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::dplesol((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1,(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg2,(std::string const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dplesol(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "dplesol", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_dplesol__SWIG_3(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_dplesol__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_dplesol__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_dplesol__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_dplesol__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_dplesol__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::Sparsity > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_dplesol__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_dplesol__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'dplesol'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::dplesol(std::string const &,std::string const &,casadi::SpDict const &,casadi::Dict const &)\n"
    "    casadi::dplesol(casadi::MX const &,casadi::MX const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::dplesol(casadi::MXVector const &,casadi::MXVector const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::dplesol(casadi::DMVector const &,casadi::DMVector const &,std::string const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_dple_in__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::dple_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dple_out__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = casadi::dple_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dple_in__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::dple_in(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dple_in(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "dple_in", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_dple_in__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_dple_in__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'dple_in'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::dple_in()\n"
    "    casadi::dple_in(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_dple_out__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      result = casadi::dple_out(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dple_out(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "dple_out", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_dple_out__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi_int **>(0));
    if (_v) {
      return _wrap_dple_out__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'dple_out'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::dple_out()\n"
    "    casadi::dple_out(casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_dple_n_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "dple_n_in", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::dple_n_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dple_n_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "dple_n_out", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::dple_n_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_has_dple(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::has_dple((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_load_dple(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::load_dple((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doc_dple(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::doc_dple((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expmsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Sparsity *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::string m1 ;
  std::string m2 ;
  casadi::Sparsity m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[4] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "expmsol", 3, 4, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "Sparsity" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::expmsol((std::string const &)*arg1,(std::string const &)*arg2,(casadi::Sparsity const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expm_n_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "expm_n_in", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::expm_n_in();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expm_n_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "expm_n_out", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::expm_n_out();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_has_expm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::has_expm((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_load_expm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::load_expm((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doc_expm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::doc_expm((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_interpolant__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *arg3 = 0 ;
  std::vector< double,std::allocator< double > > *arg4 = 0 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::vector< std::vector< double > > m3 ;
  std::vector< double > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function result;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "float" "]" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "float" "]" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::interpolant((std::string const &)*arg1,(std::string const &)*arg2,(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)*arg3,(std::vector< double,std::allocator< double > > const &)*arg4,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_interpolant__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *arg3 = 0 ;
  casadi_int arg4 = (casadi_int) 1 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::vector< std::vector< double > > m3 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "float" "]" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  }
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::interpolant((std::string const &)*arg1,(std::string const &)*arg2,(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)*arg3,arg4,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_interpolant__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi_int arg4 = (casadi_int) 1 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::vector< casadi_int > m3 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  }
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::interpolant((std::string const &)*arg1,(std::string const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,arg4,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_interpolant__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< double,std::allocator< double > > *arg4 = 0 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< double > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function result;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "float" "]" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::interpolant((std::string const &)*arg1,(std::string const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,(std::vector< double,std::allocator< double > > const &)*arg4,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_interpolant(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "interpolant", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector<double> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_interpolant__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_interpolant__SWIG_1(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_interpolant__SWIG_1(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_interpolant__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_interpolant__SWIG_2(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_interpolant__SWIG_2(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector<double> > **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<double> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_interpolant__SWIG_0(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_interpolant__SWIG_0(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<double> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_interpolant__SWIG_3(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_interpolant__SWIG_3(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'interpolant'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::interpolant(std::string const &,std::string const &,std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &,std::vector< double,std::allocator< double > > const &,casadi::Dict const &)\n"
    "    casadi::interpolant(std::string const &,std::string const &,std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &,casadi_int,casadi::Dict const &)\n"
    "    casadi::interpolant(std::string const &,std::string const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi_int,casadi::Dict const &)\n"
    "    casadi::interpolant(std::string const &,std::string const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< double,std::allocator< double > > const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_has_interpolant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::has_interpolant((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_load_interpolant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::load_interpolant((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_doc_interpolant(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::doc_interpolant((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CodeGenerator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Dict const &arg2_defvalue = casadi::Dict() ;
  casadi::Dict *arg2 = (casadi::Dict *) &arg2_defvalue ;
  std::string m1 ;
  std::map< std::string,casadi::GenericType > m2 ;
  PyObject *swig_obj[2] ;
  casadi::CodeGenerator *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_CodeGenerator", 1, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::CodeGenerator *)new casadi::CodeGenerator((std::string const &)*arg1,(casadi::Dict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__CodeGenerator, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CodeGenerator_add(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::CodeGenerator *arg1 = (casadi::CodeGenerator *) 0 ;
  casadi::Function *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Function m2 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "CodeGenerator_add", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__CodeGenerator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CodeGenerator_add" "', argument " "1"" of type '" "casadi::CodeGenerator *""'"); 
  }
  arg1 = reinterpret_cast< casadi::CodeGenerator * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Function" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->add((casadi::Function const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CodeGenerator_dump(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::CodeGenerator *arg1 = (casadi::CodeGenerator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__CodeGenerator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CodeGenerator_dump" "', argument " "1"" of type '" "casadi::CodeGenerator *""'"); 
  }
  arg1 = reinterpret_cast< casadi::CodeGenerator * >(argp1);
  {
    try {
      result = (arg1)->dump();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CodeGenerator_generate(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::CodeGenerator *arg1 = (casadi::CodeGenerator *) 0 ;
  std::string const &arg2_defvalue = "" ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "CodeGenerator_generate", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__CodeGenerator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CodeGenerator_generate" "', argument " "1"" of type '" "casadi::CodeGenerator *""'"); 
  }
  arg1 = reinterpret_cast< casadi::CodeGenerator * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  {
    try {
      result = (arg1)->generate((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CodeGenerator_add_include(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::CodeGenerator *arg1 = (casadi::CodeGenerator *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 = (bool) false ;
  std::string const &arg4_defvalue = std::string() ;
  std::string *arg4 = (std::string *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string m4 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "CodeGenerator_add_include", 2, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__CodeGenerator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CodeGenerator_add_include" "', argument " "1"" of type '" "casadi::CodeGenerator *""'"); 
  }
  arg1 = reinterpret_cast< casadi::CodeGenerator * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "str" "'.");
  }
  {
    try {
      (arg1)->add_include((std::string const &)*arg2,arg3,(std::string const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CodeGenerator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::CodeGenerator *arg1 = (casadi::CodeGenerator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__CodeGenerator, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CodeGenerator" "', argument " "1"" of type '" "casadi::CodeGenerator *""'"); 
  }
  arg1 = reinterpret_cast< casadi::CodeGenerator * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CodeGenerator_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__CodeGenerator, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *CodeGenerator_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap__horzcat__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > *arg1 = 0 ;
  std::vector< casadi::Sparsity > m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "Sparsity" "]" "'.");
  {
    try {
      result = casadi::casadi_horzcat((std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__vertcat__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > *arg1 = 0 ;
  std::vector< casadi::Sparsity > m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "Sparsity" "]" "'.");
  {
    try {
      result = casadi::casadi_vertcat((std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_horzsplit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Sparsity m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_horzsplit((casadi::Sparsity const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_horzsplit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Sparsity m1 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_horzsplit((casadi::Sparsity const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vertsplit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Sparsity m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_vertsplit((casadi::Sparsity const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_offset__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > *arg1 = 0 ;
  bool arg2 = (bool) true ;
  std::vector< casadi::Sparsity > m1 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "Sparsity" "]" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_offset((std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vertsplit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Sparsity m1 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_vertsplit((casadi::Sparsity const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blockcat__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::Sparsity *arg3 = 0 ;
  casadi::Sparsity *arg4 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity m2 ;
  casadi::Sparsity m3 ;
  casadi::Sparsity m4 ;
  casadi::Sparsity result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "Sparsity" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_blockcat((casadi::Sparsity const &)*arg1,(casadi::Sparsity const &)*arg2,(casadi::Sparsity const &)*arg3,(casadi::Sparsity const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blocksplit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi::Sparsity m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >,std::allocator< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_blocksplit((casadi::Sparsity const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "Sparsity"  "]"  "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blocksplit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::Sparsity m1 ;
  std::vector< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >,std::allocator< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > > > result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_blocksplit((casadi::Sparsity const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "Sparsity"  "]"  "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__diagcat__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > *arg1 = 0 ;
  std::vector< casadi::Sparsity > m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "Sparsity" "]" "'.");
  {
    try {
      result = casadi::casadi_diagcat((std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi::Sparsity m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Sparsity const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Sparsity m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Sparsity const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Sparsity m1 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Sparsity const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Sparsity m1 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Sparsity const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__veccat__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > *arg1 = 0 ;
  std::vector< casadi::Sparsity > m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "Sparsity" "]" "'.");
  {
    try {
      result = casadi::casadi_veccat((std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtimes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity m2 ;
  casadi::Sparsity result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_mtimes((casadi::Sparsity const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtimes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > *arg1 = 0 ;
  std::vector< casadi::Sparsity > m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "Sparsity" "]" "'.");
  {
    try {
      result = casadi::casadi_mtimes((std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mac__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::Sparsity *arg3 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity m2 ;
  casadi::Sparsity m3 ;
  casadi::Sparsity result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_mac((casadi::Sparsity const &)*arg1,(casadi::Sparsity const &)*arg2,(casadi::Sparsity const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_transpose__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_transpose((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vec__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_vec((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::Sparsity const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > arg2 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::Sparsity const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity m2 ;
  casadi::Sparsity result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::Sparsity const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sprank__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_sprank((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_0_mul__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_norm_0_mul((casadi::Sparsity const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_triu__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  bool arg2 = (bool) true ;
  casadi::Sparsity m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_triu((casadi::Sparsity const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tril__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  bool arg2 = (bool) true ;
  casadi::Sparsity m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_tril((casadi::Sparsity const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_kron__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity m2 ;
  casadi::Sparsity result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_kron((casadi::Sparsity const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repmat__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_repmat((casadi::Sparsity const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repmat__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > *arg2 = 0 ;
  casadi::Sparsity m1 ;
  std::pair< casadi_int,casadi_int > m2 ;
  casadi::Sparsity result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::casadi_repmat((casadi::Sparsity const &)*arg1,(std::pair< long long,long long > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sum2__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_sum2((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sum1__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Sparsity *arg1 = 0 ;
  casadi::Sparsity m1 ;
  casadi::Sparsity result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_sum1((casadi::Sparsity const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__horzcat__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = casadi::casadi_horzcat((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__vertcat__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = casadi::casadi_vertcat((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_horzsplit__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::MX m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_horzsplit((casadi::MX const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_horzsplit__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::MX m1 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_horzsplit((casadi::MX const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vertsplit__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::MX m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_vertsplit((casadi::MX const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_offset__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  bool arg2 = (bool) true ;
  std::vector< casadi::MX > m1 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_offset((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vertsplit__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::MX m1 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_vertsplit((casadi::MX const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blockcat__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX *arg4 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX m4 ;
  casadi::MX result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_blockcat((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3,(casadi::MX const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blocksplit__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi::MX m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_blocksplit((casadi::MX const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "MX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blocksplit__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::MX m1 ;
  std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_blocksplit((casadi::MX const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "MX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__diagcat__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = casadi::casadi_diagcat((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi::MX m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::MX const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::MX m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::MX const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::MX m1 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_diagsplit((casadi::MX const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::MX m1 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::MX const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__veccat__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = casadi::casadi_veccat((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtimes__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_mtimes((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtimes__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = casadi::casadi_mtimes((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mac__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_mac((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_transpose__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_transpose((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vec__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_vec((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::MX const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > arg2 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::MX const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::Sparsity m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::MX const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sprank__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_sprank((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_0_mul__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_norm_0_mul((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_triu__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  bool arg2 = (bool) true ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_triu((casadi::MX const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tril__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  bool arg2 = (bool) true ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_tril((casadi::MX const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_kron__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_kron((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repmat__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_repmat((casadi::MX const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repmat__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > *arg2 = 0 ;
  casadi::MX m1 ;
  std::pair< casadi_int,casadi_int > m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::casadi_repmat((casadi::MX const &)*arg1,(std::pair< long long,long long > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sum2__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_sum2((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sum1__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_sum1((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__horzcat__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double > > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = casadi::casadi_horzcat((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__vertcat__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double > > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = casadi::casadi_vertcat((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_horzsplit__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_horzsplit((casadi::Matrix< double > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_horzsplit__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_horzsplit((casadi::Matrix< double > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vertsplit__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_vertsplit((casadi::Matrix< double > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_offset__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  bool arg2 = (bool) true ;
  std::vector< casadi::Matrix< double > > m1 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_offset((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vertsplit__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_vertsplit((casadi::Matrix< double > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blockcat__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > *arg4 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > m4 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_blockcat((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,(casadi::Matrix< double > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blocksplit__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_blocksplit((casadi::Matrix< double > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "DM" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blocksplit__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::Matrix< double > m1 ;
  std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_blocksplit((casadi::Matrix< double > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "DM" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__diagcat__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double > > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = casadi::casadi_diagcat((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_8(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Matrix< double > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_9(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Matrix< double > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_10(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Matrix< double > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_11(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Matrix< double > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__veccat__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double > > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = casadi::casadi_veccat((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtimes__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_mtimes((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtimes__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double > > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = casadi::casadi_mtimes((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mac__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_mac((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_transpose__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_transpose((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vec__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_vec((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::Matrix< double > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > arg2 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::Matrix< double > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_8(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Sparsity m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::Matrix< double > const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sprank__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_sprank((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_0_mul__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_norm_0_mul((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_triu__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  bool arg2 = (bool) true ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_triu((casadi::Matrix< double > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tril__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  bool arg2 = (bool) true ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_tril((casadi::Matrix< double > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_kron__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_kron((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repmat__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_repmat((casadi::Matrix< double > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repmat__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  std::pair< casadi_int,casadi_int > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::casadi_repmat((casadi::Matrix< double > const &)*arg1,(std::pair< long long,long long > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sum2__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_sum2((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sum1__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_sum1((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__horzcat__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  {
    try {
      result = casadi::casadi_horzcat((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__horzcat(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "_horzcat", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Sparsity> **>(0));
    if (_v) {
      return _wrap__horzcat__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      return _wrap__horzcat__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      return _wrap__horzcat__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      return _wrap__horzcat__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function '_horzcat'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_horzcat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)\n"
    "    casadi::casadi_horzcat(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n"
    "    casadi::casadi_horzcat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)\n"
    "    casadi::casadi_horzcat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap__vertcat__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  {
    try {
      result = casadi::casadi_vertcat((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__vertcat(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "_vertcat", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Sparsity> **>(0));
    if (_v) {
      return _wrap__vertcat__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      return _wrap__vertcat__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      return _wrap__vertcat__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      return _wrap__vertcat__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function '_vertcat'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_vertcat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)\n"
    "    casadi::casadi_vertcat(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n"
    "    casadi::casadi_vertcat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)\n"
    "    casadi::casadi_vertcat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_horzsplit__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_horzsplit((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_horzsplit__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_horzsplit((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_horzsplit(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "horzsplit", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_horzsplit__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_horzsplit__SWIG_1(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_horzsplit__SWIG_5(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_horzsplit__SWIG_5(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_horzsplit__SWIG_7(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_horzsplit__SWIG_7(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_horzsplit__SWIG_3(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_horzsplit__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_horzsplit__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_horzsplit__SWIG_4(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_horzsplit__SWIG_6(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_horzsplit__SWIG_2(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'horzsplit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_horzsplit(casadi::Sparsity const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_horzsplit(casadi::Sparsity const &,casadi_int)\n"
    "    casadi::casadi_horzsplit(casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_horzsplit(casadi::MX const &,casadi_int)\n"
    "    casadi::casadi_horzsplit(casadi::Matrix< double > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_horzsplit(casadi::Matrix< double > const &,casadi_int)\n"
    "    casadi::casadi_horzsplit(casadi::Matrix< casadi::SXElem > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_horzsplit(casadi::Matrix< casadi::SXElem > const &,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_vertsplit__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_vertsplit((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_offset__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  bool arg2 = (bool) true ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_offset((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_offset(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "offset", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Sparsity> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_offset__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_offset__SWIG_0(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_offset__SWIG_2(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_offset__SWIG_2(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_offset__SWIG_3(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_offset__SWIG_3(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_offset__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_offset__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'offset'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_offset(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &,bool)\n"
    "    casadi::casadi_offset(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,bool)\n"
    "    casadi::casadi_offset(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,bool)\n"
    "    casadi::casadi_offset(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_vertsplit__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_vertsplit((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vertsplit(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "vertsplit", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_vertsplit__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_vertsplit__SWIG_1(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_vertsplit__SWIG_5(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_vertsplit__SWIG_5(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_vertsplit__SWIG_7(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_vertsplit__SWIG_7(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_vertsplit__SWIG_3(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_vertsplit__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_vertsplit__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_vertsplit__SWIG_4(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_vertsplit__SWIG_6(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_vertsplit__SWIG_2(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'vertsplit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_vertsplit(casadi::Sparsity const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_vertsplit(casadi::Sparsity const &,casadi_int)\n"
    "    casadi::casadi_vertsplit(casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_vertsplit(casadi::MX const &,casadi_int)\n"
    "    casadi::casadi_vertsplit(casadi::Matrix< double > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_vertsplit(casadi::Matrix< double > const &,casadi_int)\n"
    "    casadi::casadi_vertsplit(casadi::Matrix< casadi::SXElem > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_vertsplit(casadi::Matrix< casadi::SXElem > const &,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_blockcat__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg4 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > m4 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_blockcat((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,(casadi::Matrix< casadi::SXElem > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blocksplit__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_blocksplit((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "SX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blocksplit__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_blocksplit((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "SX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blocksplit(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "blocksplit", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_blocksplit__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_blocksplit__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_blocksplit__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_blocksplit__SWIG_5(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_blocksplit__SWIG_5(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_blocksplit__SWIG_5(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_blocksplit__SWIG_7(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_blocksplit__SWIG_7(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_blocksplit__SWIG_7(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_blocksplit__SWIG_3(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_blocksplit__SWIG_3(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_blocksplit__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          return _wrap_blocksplit__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          return _wrap_blocksplit__SWIG_4(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          return _wrap_blocksplit__SWIG_6(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          return _wrap_blocksplit__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'blocksplit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_blocksplit(casadi::Sparsity const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_blocksplit(casadi::Sparsity const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_blocksplit(casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_blocksplit(casadi::MX const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_blocksplit(casadi::Matrix< double > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_blocksplit(casadi::Matrix< double > const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_blocksplit(casadi::Matrix< casadi::SXElem > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_blocksplit(casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap__diagcat__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  {
    try {
      result = casadi::casadi_diagcat((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__diagcat(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "_diagcat", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Sparsity> **>(0));
    if (_v) {
      return _wrap__diagcat__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      return _wrap__diagcat__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      return _wrap__diagcat__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      return _wrap__diagcat__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function '_diagcat'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_diagcat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)\n"
    "    casadi::casadi_diagcat(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n"
    "    casadi::casadi_diagcat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)\n"
    "    casadi::casadi_diagcat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_12(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_13(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi_int > m2 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::vector< long long,std::allocator< long long > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_14(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit__SWIG_15(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_diagsplit((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diagsplit(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "diagsplit", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_diagsplit__SWIG_2(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_diagsplit__SWIG_2(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_diagsplit__SWIG_10(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_diagsplit__SWIG_10(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_diagsplit__SWIG_14(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_diagsplit__SWIG_14(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_diagsplit__SWIG_6(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_diagsplit__SWIG_6(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_diagsplit__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_diagsplit__SWIG_9(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_diagsplit__SWIG_13(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_diagsplit__SWIG_5(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_diagsplit__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          return _wrap_diagsplit__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_diagsplit__SWIG_11(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          return _wrap_diagsplit__SWIG_8(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_diagsplit__SWIG_15(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          return _wrap_diagsplit__SWIG_12(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_diagsplit__SWIG_7(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          return _wrap_diagsplit__SWIG_4(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'diagsplit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_diagsplit(casadi::Sparsity const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_diagsplit(casadi::Sparsity const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_diagsplit(casadi::Sparsity const &,casadi_int)\n"
    "    casadi::casadi_diagsplit(casadi::Sparsity const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_diagsplit(casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_diagsplit(casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_diagsplit(casadi::MX const &,casadi_int)\n"
    "    casadi::casadi_diagsplit(casadi::MX const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_diagsplit(casadi::Matrix< double > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_diagsplit(casadi::Matrix< double > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_diagsplit(casadi::Matrix< double > const &,casadi_int)\n"
    "    casadi::casadi_diagsplit(casadi::Matrix< double > const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_diagsplit(casadi::Matrix< casadi::SXElem > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_diagsplit(casadi::Matrix< casadi::SXElem > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_diagsplit(casadi::Matrix< casadi::SXElem > const &,casadi_int)\n"
    "    casadi::casadi_diagsplit(casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap__veccat__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  {
    try {
      result = casadi::casadi_veccat((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap__veccat(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "_veccat", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Sparsity> **>(0));
    if (_v) {
      return _wrap__veccat__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      return _wrap__veccat__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      return _wrap__veccat__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      return _wrap__veccat__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function '_veccat'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_veccat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)\n"
    "    casadi::casadi_veccat(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n"
    "    casadi::casadi_veccat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)\n"
    "    casadi::casadi_veccat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_mtimes__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_mtimes((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtimes__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  {
    try {
      result = casadi::casadi_mtimes((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtimes(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "mtimes", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Sparsity> **>(0));
    if (_v) {
      return _wrap_mtimes__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      return _wrap_mtimes__SWIG_5(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      return _wrap_mtimes__SWIG_7(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      return _wrap_mtimes__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_mtimes__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_mtimes__SWIG_4(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_mtimes__SWIG_6(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_mtimes__SWIG_2(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'mtimes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_mtimes(casadi::Sparsity const &,casadi::Sparsity const &)\n"
    "    casadi::casadi_mtimes(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)\n"
    "    casadi::casadi_mtimes(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_mtimes(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n"
    "    casadi::casadi_mtimes(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_mtimes(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)\n"
    "    casadi::casadi_mtimes(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_mtimes(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_mac__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_mac((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mac(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "mac", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Sparsity **>(0));
        if (_v) {
          return _wrap_mac__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          return _wrap_mac__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          return _wrap_mac__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          return _wrap_mac__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'mac'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_mac(casadi::Sparsity const &,casadi::Sparsity const &,casadi::Sparsity const &)\n"
    "    casadi::casadi_mac(casadi::MX const &,casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_mac(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_mac(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_transpose__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_transpose((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_transpose(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "transpose", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_transpose__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_transpose__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_transpose__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_transpose__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'transpose'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_transpose(casadi::Sparsity const &)\n"
    "    casadi::casadi_transpose(casadi::MX const &)\n"
    "    casadi::casadi_transpose(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_transpose(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_vec__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_vec((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_vec(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "vec", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_vec__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_vec__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_vec__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_vec__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'vec'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_vec(casadi::Sparsity const &)\n"
    "    casadi::casadi_vec(casadi::MX const &)\n"
    "    casadi::casadi_vec(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_vec(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_9(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_10(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > arg2 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape__SWIG_11(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Sparsity m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      result = casadi::casadi_reshape((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reshape(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "reshape", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_reshape__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_reshape__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_reshape__SWIG_7(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_reshape__SWIG_8(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_reshape__SWIG_10(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_reshape__SWIG_11(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_reshape__SWIG_4(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_reshape__SWIG_5(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_reshape__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_reshape__SWIG_6(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_reshape__SWIG_9(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_reshape__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'reshape'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_reshape(casadi::Sparsity const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_reshape(casadi::Sparsity const &,std::pair< casadi_int,casadi_int >)\n"
    "    casadi::casadi_reshape(casadi::Sparsity const &,casadi::Sparsity const &)\n"
    "    casadi::casadi_reshape(casadi::MX const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_reshape(casadi::MX const &,std::pair< casadi_int,casadi_int >)\n"
    "    casadi::casadi_reshape(casadi::MX const &,casadi::Sparsity const &)\n"
    "    casadi::casadi_reshape(casadi::Matrix< double > const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_reshape(casadi::Matrix< double > const &,std::pair< casadi_int,casadi_int >)\n"
    "    casadi::casadi_reshape(casadi::Matrix< double > const &,casadi::Sparsity const &)\n"
    "    casadi::casadi_reshape(casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_reshape(casadi::Matrix< casadi::SXElem > const &,std::pair< casadi_int,casadi_int >)\n"
    "    casadi::casadi_reshape(casadi::Matrix< casadi::SXElem > const &,casadi::Sparsity const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_sprank__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_sprank((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sprank(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "sprank", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_sprank__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_sprank__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_sprank__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_sprank__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'sprank'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_sprank(casadi::Sparsity const &)\n"
    "    casadi::casadi_sprank(casadi::MX const &)\n"
    "    casadi::casadi_sprank(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_sprank(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_norm_0_mul__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi_int result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_norm_0_mul((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_0_mul(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "norm_0_mul", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_norm_0_mul__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_norm_0_mul__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_norm_0_mul__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_norm_0_mul__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'norm_0_mul'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_norm_0_mul(casadi::Sparsity const &,casadi::Sparsity const &)\n"
    "    casadi::casadi_norm_0_mul(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_norm_0_mul(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_norm_0_mul(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_triu__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  bool arg2 = (bool) true ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_triu((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_triu(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "triu", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_triu__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_triu__SWIG_0(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_triu__SWIG_2(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_triu__SWIG_2(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_triu__SWIG_3(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_triu__SWIG_3(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_triu__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_triu__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'triu'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_triu(casadi::Sparsity const &,bool)\n"
    "    casadi::casadi_triu(casadi::MX const &,bool)\n"
    "    casadi::casadi_triu(casadi::Matrix< double > const &,bool)\n"
    "    casadi::casadi_triu(casadi::Matrix< casadi::SXElem > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_tril__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  bool arg2 = (bool) true ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_tril((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tril(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "tril", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_tril__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_tril__SWIG_0(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_tril__SWIG_2(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_tril__SWIG_2(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_tril__SWIG_3(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_tril__SWIG_3(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_tril__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_tril__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'tril'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_tril(casadi::Sparsity const &,bool)\n"
    "    casadi::casadi_tril(casadi::MX const &,bool)\n"
    "    casadi::casadi_tril(casadi::Matrix< double > const &,bool)\n"
    "    casadi::casadi_tril(casadi::Matrix< casadi::SXElem > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_kron__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_kron((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_kron(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "kron", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_kron__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_kron__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_kron__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_kron__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'kron'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_kron(casadi::Sparsity const &,casadi::Sparsity const &)\n"
    "    casadi::casadi_kron(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_kron(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_kron(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_repmat__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_repmat((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repmat__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::pair< casadi_int,casadi_int > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::pair< casadi_int,casadi_int > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "(" "int" "," "int" ")" "'.");
  {
    try {
      result = casadi::casadi_repmat((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::pair< long long,long long > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repmat(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "repmat", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_repmat__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_repmat__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_repmat__SWIG_1(self, argc, argv);
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_repmat__SWIG_4(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_repmat__SWIG_4(self, argc, argv);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_repmat__SWIG_5(self, argc, argv);
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_repmat__SWIG_6(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_repmat__SWIG_6(self, argc, argv);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_repmat__SWIG_7(self, argc, argv);
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_repmat__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_repmat__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::pair<casadi_int,casadi_int> **>(0));
      if (_v) {
        return _wrap_repmat__SWIG_3(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'repmat'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_repmat(casadi::Sparsity const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_repmat(casadi::Sparsity const &,std::pair< casadi_int,casadi_int > const &)\n"
    "    casadi::casadi_repmat(casadi::MX const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_repmat(casadi::MX const &,std::pair< casadi_int,casadi_int > const &)\n"
    "    casadi::casadi_repmat(casadi::Matrix< double > const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_repmat(casadi::Matrix< double > const &,std::pair< casadi_int,casadi_int > const &)\n"
    "    casadi::casadi_repmat(casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_repmat(casadi::Matrix< casadi::SXElem > const &,std::pair< casadi_int,casadi_int > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_sum2__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_sum2((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sum2(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "sum2", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_sum2__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_sum2__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_sum2__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_sum2__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'sum2'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_sum2(casadi::Sparsity const &)\n"
    "    casadi::casadi_sum2(casadi::MX const &)\n"
    "    casadi::casadi_sum2(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_sum2(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_sum1__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_sum1((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sum1(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "sum1", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      return _wrap_sum1__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_sum1__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_sum1__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_sum1__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'sum1'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_sum1(casadi::Sparsity const &)\n"
    "    casadi::casadi_sum1(casadi::MX const &)\n"
    "    casadi::casadi_sum1(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_sum1(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_plus__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_plus((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_minus__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_minus((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_times__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_times((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_rdivide__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_rdivide((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ldivide__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_ldivide((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lt__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_lt((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_le__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_le((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_gt__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_gt((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ge__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_ge((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_eq__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_eq((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ne__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_ne((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_and__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_and((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_or__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_or((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_not__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_not((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fabs__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_abs((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sqrt__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_sqrt((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_sin((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cos__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_cos((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tan__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_tan((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atan__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_atan((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_asin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_asin((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_acos__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_acos((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tanh__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_tanh((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sinh__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_sinh((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cosh__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_cosh((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atanh__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_atanh((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_asinh__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_asinh((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_acosh__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_acosh((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_exp__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_exp((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_log__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_log((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_log10__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_log10((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_floor__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_floor((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ceil__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_ceil((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_erf__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_erf((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_erfinv__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_erfinv((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sign__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_sign((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_power__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_power((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_mod__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_mod((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_fmod__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_fmod((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atan2__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_atan2((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_fmin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_fmin((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fmax__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_fmax((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_simplify__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_simplify((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_equal__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (bool)casadi::casadi_is_equal((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_copysign__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_copysign((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_constpow__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_constpow((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_plus__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_plus((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_minus__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_minus((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_times__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_times((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_rdivide__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_rdivide((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ldivide__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_ldivide((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lt__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_lt((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_le__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_le((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_gt__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_gt((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ge__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_ge((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_eq__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_eq((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ne__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_ne((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_and__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_and((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_or__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_or((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_not__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_not((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fabs__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_abs((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sqrt__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_sqrt((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_sin((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cos__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_cos((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tan__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_tan((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atan__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_atan((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_asin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_asin((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_acos__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_acos((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tanh__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_tanh((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sinh__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_sinh((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cosh__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_cosh((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atanh__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_atanh((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_asinh__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_asinh((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_acosh__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_acosh((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_exp__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_exp((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_log__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_log((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_log10__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_log10((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_floor__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_floor((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ceil__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_ceil((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_erf__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_erf((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_erfinv__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_erfinv((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sign__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_sign((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_power__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_power((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_mod__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_mod((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_fmod__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_fmod((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atan2__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_atan2((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_fmin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_fmin((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fmax__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_fmax((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_simplify__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_simplify((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_equal__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (bool)casadi::casadi_is_equal((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_copysign__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_copysign((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_constpow__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_constpow((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_plus__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_plus((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_minus__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_minus((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_times__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_times((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_rdivide__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_rdivide((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ldivide__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_ldivide((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_lt__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_lt((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_le__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_le((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_gt__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_gt((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ge__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_ge((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_eq__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_eq((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ne__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_ne((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_and__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_and((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_or__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_or((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_not__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_not((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fabs__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_abs((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sqrt__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_sqrt((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sin__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_sin((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cos__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_cos((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tan__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_tan((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atan__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_atan((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_asin__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_asin((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_acos__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_acos((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tanh__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_tanh((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sinh__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_sinh((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cosh__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_cosh((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atanh__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_atanh((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_asinh__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_asinh((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_acosh__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_acosh((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_exp__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_exp((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_log__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_log((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_log10__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_log10((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_floor__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_floor((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ceil__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_ceil((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_erf__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_erf((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_erfinv__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_erfinv((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sign__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_sign((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_power__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_power((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_mod__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_mod((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_fmod__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_fmod((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atan2__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_atan2((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_fmin__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_fmin((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fmax__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_fmax((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_simplify__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_simplify((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_equal__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (bool)casadi::casadi_is_equal((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_copysign__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_copysign((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_constpow__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_constpow((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_plus__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_plus((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_plus(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "plus", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_plus__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_plus__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_plus__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_plus__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_minus__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_minus((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_minus(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "minus", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_minus__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_minus__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_minus__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_minus__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_times__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_times((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_times(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "times", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_times__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_times__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_times__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_times__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_rdivide__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_rdivide((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_rdivide(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "rdivide", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_rdivide__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_rdivide__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_rdivide__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_rdivide__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ldivide__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_ldivide((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ldivide(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "ldivide", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_ldivide__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_ldivide__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_ldivide__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_ldivide__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'ldivide'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_ldivide(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_ldivide(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_ldivide(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_ldivide(double const &,double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_lt__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_lt((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_lt(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "lt", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_lt__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_lt__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_lt__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_lt__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_le__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_le((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_le(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "le", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_le__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_le__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_le__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_le__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_gt__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_gt((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gt(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "gt", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_gt__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_gt__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_gt__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_gt__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'gt'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_gt(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_gt(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_gt(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_gt(double const &,double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ge__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_ge((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ge(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "ge", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_ge__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_ge__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_ge__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_ge__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'ge'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_ge(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_ge(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_ge(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_ge(double const &,double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_eq__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_eq((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_eq(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "eq", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_eq__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_eq__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_eq__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_eq__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ne__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_ne((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_ne(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "ne", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_ne__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_ne__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_ne__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_ne__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_and__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_and((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_and(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "logic_and", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_logic_and__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_logic_and__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_logic_and__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_logic_and__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_or__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_or((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_or(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "logic_or", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_logic_or__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_logic_or__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_logic_or__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_logic_or__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_logic_not__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_not((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_logic_not(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "logic_not", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_logic_not__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_logic_not__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_logic_not__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_logic_not__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'logic_not'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_not(casadi::MX const &)\n"
    "    casadi::casadi_not(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_not(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_not(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_fabs__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_abs((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fabs(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "fabs", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_fabs__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_fabs__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_fabs__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_fabs__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'fabs'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_abs(casadi::MX const &)\n"
    "    casadi::casadi_abs(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_abs(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_abs(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_sqrt__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_sqrt((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sqrt(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "sqrt", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_sqrt__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_sqrt__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_sqrt__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_sqrt__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'sqrt'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_sqrt(casadi::MX const &)\n"
    "    casadi::casadi_sqrt(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_sqrt(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_sqrt(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_sin__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_sin((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sin(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "sin", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_sin__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_sin__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_sin__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_sin__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'sin'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_sin(casadi::MX const &)\n"
    "    casadi::casadi_sin(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_sin(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_sin(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_cos__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_cos((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cos(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "cos", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_cos__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_cos__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_cos__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_cos__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'cos'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_cos(casadi::MX const &)\n"
    "    casadi::casadi_cos(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_cos(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_cos(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_tan__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_tan((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tan(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "tan", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_tan__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_tan__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_tan__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_tan__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'tan'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_tan(casadi::MX const &)\n"
    "    casadi::casadi_tan(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_tan(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_tan(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_atan__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_atan((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atan(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "atan", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_atan__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_atan__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_atan__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_atan__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'atan'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_atan(casadi::MX const &)\n"
    "    casadi::casadi_atan(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_atan(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_atan(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_asin__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_asin((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_asin(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "asin", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_asin__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_asin__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_asin__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_asin__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'asin'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_asin(casadi::MX const &)\n"
    "    casadi::casadi_asin(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_asin(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_asin(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_acos__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_acos((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_acos(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "acos", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_acos__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_acos__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_acos__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_acos__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'acos'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_acos(casadi::MX const &)\n"
    "    casadi::casadi_acos(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_acos(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_acos(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_tanh__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_tanh((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tanh(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "tanh", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_tanh__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_tanh__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_tanh__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_tanh__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'tanh'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_tanh(casadi::MX const &)\n"
    "    casadi::casadi_tanh(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_tanh(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_tanh(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_sinh__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_sinh((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sinh(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "sinh", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_sinh__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_sinh__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_sinh__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_sinh__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'sinh'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_sinh(casadi::MX const &)\n"
    "    casadi::casadi_sinh(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_sinh(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_sinh(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_cosh__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_cosh((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cosh(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "cosh", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_cosh__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_cosh__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_cosh__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_cosh__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'cosh'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_cosh(casadi::MX const &)\n"
    "    casadi::casadi_cosh(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_cosh(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_cosh(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_atanh__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_atanh((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_atanh(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "atanh", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_atanh__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_atanh__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_atanh__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_atanh__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'atanh'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_atanh(casadi::MX const &)\n"
    "    casadi::casadi_atanh(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_atanh(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_atanh(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_asinh__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_asinh((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_asinh(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "asinh", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_asinh__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_asinh__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_asinh__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_asinh__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'asinh'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_asinh(casadi::MX const &)\n"
    "    casadi::casadi_asinh(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_asinh(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_asinh(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_acosh__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_acosh((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_acosh(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "acosh", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_acosh__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_acosh__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_acosh__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_acosh__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'acosh'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_acosh(casadi::MX const &)\n"
    "    casadi::casadi_acosh(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_acosh(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_acosh(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_exp__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_exp((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_exp(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "exp", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_exp__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_exp__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_exp__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_exp__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'exp'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_exp(casadi::MX const &)\n"
    "    casadi::casadi_exp(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_exp(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_exp(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_log__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_log((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_log(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "log", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_log__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_log__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_log__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_log__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'log'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_log(casadi::MX const &)\n"
    "    casadi::casadi_log(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_log(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_log(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_log10__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_log10((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_log10(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "log10", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_log10__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_log10__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_log10__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_log10__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'log10'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_log10(casadi::MX const &)\n"
    "    casadi::casadi_log10(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_log10(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_log10(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_floor__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_floor((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_floor(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "floor", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_floor__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_floor__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_floor__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_floor__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'floor'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_floor(casadi::MX const &)\n"
    "    casadi::casadi_floor(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_floor(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_floor(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ceil__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_ceil((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ceil(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "ceil", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_ceil__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_ceil__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_ceil__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_ceil__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'ceil'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_ceil(casadi::MX const &)\n"
    "    casadi::casadi_ceil(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_ceil(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_ceil(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_erf__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_erf((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_erf(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "erf", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_erf__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_erf__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_erf__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_erf__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'erf'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_erf(casadi::MX const &)\n"
    "    casadi::casadi_erf(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_erf(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_erf(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_erfinv__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_erfinv((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_erfinv(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "erfinv", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_erfinv__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_erfinv__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_erfinv__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_erfinv__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'erfinv'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_erfinv(casadi::MX const &)\n"
    "    casadi::casadi_erfinv(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_erfinv(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_erfinv(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_sign__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_sign((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sign(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "sign", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_sign__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_sign__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_sign__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_sign__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'sign'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_sign(casadi::MX const &)\n"
    "    casadi::casadi_sign(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_sign(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_sign(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_power__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_power((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_power(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "power", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_power__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_power__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_power__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_power__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_mod__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_mod((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_mod(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "mod", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_mod__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_mod__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_mod__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_mod__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_fmod__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_fmod((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fmod(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "fmod", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_fmod__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_fmod__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_fmod__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_fmod__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'fmod'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_fmod(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_fmod(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_fmod(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_fmod(double const &,double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_atan2__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_atan2((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_atan2(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "atan2", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_atan2__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_atan2__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_atan2__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_atan2__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_fmin__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_fmin((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fmin(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "fmin", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_fmin__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_fmin__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_fmin__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_fmin__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'fmin'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_fmin(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_fmin(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_fmin(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_fmin(double const &,double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_fmax__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_fmax((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_fmax(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "fmax", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_fmax__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_fmax__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_fmax__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_fmax__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'fmax'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_fmax(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_fmax(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_fmax(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_fmax(double const &,double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_simplify__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double m1 ;
  double result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_simplify((double const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_simplify(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "simplify", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      return _wrap_simplify__SWIG_3(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_simplify__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_simplify__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_simplify__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'simplify'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_simplify(casadi::MX const &)\n"
    "    casadi::casadi_simplify(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_simplify(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_simplify(double const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_is_equal__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) 0 ;
  double m1 ;
  double m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (bool)casadi::casadi_is_equal((double const &)*arg1,(double const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_equal(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "is_equal", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_is_equal__SWIG_3(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_is_equal__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_is_equal__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_is_equal__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_is_equal__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_is_equal__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_is_equal__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_is_equal__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'is_equal'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_is_equal(casadi::MX const &,casadi::MX const &,casadi_int)\n"
    "    casadi::casadi_is_equal(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi_int)\n"
    "    casadi::casadi_is_equal(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int)\n"
    "    casadi::casadi_is_equal(double const &,double const &,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_copysign__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_copysign((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_copysign(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "copysign", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_copysign__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_copysign__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_copysign__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_copysign__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_constpow__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  double *arg1 = 0 ;
  double *arg2 = 0 ;
  double m1 ;
  double m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "float" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      result = (double)casadi::casadi_constpow((double const &)*arg1,(double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  PyErr_Clear();
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_constpow(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "constpow", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< double **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_constpow__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_constpow__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_constpow__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_constpow__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  Py_INCREF(Py_NotImplemented);
  return Py_NotImplemented;
}


SWIGINTERN PyObject *_wrap_mpower__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_mpower((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mrdivide__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_mrdivide((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mldivide__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_mldivide((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_symvar__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_symvar((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_bilin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_bilin((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rank1__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX *arg4 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX m4 ;
  casadi::MX result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_rank1((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3,(casadi::MX const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sumsqr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_sumsqr((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linspace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi_int arg3 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_linspace((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_interp1d__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< double,std::allocator< double > > *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  std::string const &arg4_defvalue = "linear" ;
  std::string *arg4 = (std::string *) &arg4_defvalue ;
  bool arg5 = (bool) false ;
  std::vector< double > m1 ;
  casadi::MX m2 ;
  std::vector< double > m3 ;
  std::string m4 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "float" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "str" "'.");
  }
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_interp1d((std::vector< double,std::allocator< double > > const &)*arg1,(casadi::MX const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,(std::string const &)*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_soc__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_soc((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cross__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) -1 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_cross((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_skew__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_skew((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv_skew__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_inv_skew((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_det__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_det((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv_minor__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_inv_minor((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_inv((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::MX m1 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_inv((casadi::MX const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_trace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_trace((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tril2symm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_tril2symm((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_triu2symm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_triu2symm((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_fro__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_norm_fro((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_2__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_norm_2((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_1__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_norm_1((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_inf__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_norm_inf((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dot__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_dot((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nullspace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_nullspace((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_polyval__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_polyval((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diag__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_diag((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_unite__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_unite((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_densify__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_densify((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_project__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  bool arg3 = (bool) false ;
  casadi::MX m1 ;
  casadi::Sparsity m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_project((casadi::MX const &)*arg1,(casadi::Sparsity const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_if_else__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  bool arg4 = (bool) false ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_if_else((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conditional__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  bool arg4 = (bool) false ;
  casadi::MX m1 ;
  std::vector< casadi::MX > m2 ;
  casadi::MX m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_conditional((casadi::MX const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(casadi::MX const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_depends_on__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = (bool)casadi::casadi_depends_on((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solve__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_solve((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solve__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  std::string m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_solve((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(std::string const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pinv__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_pinv((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pinv__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::MX m1 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_pinv((casadi::MX const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expm_const__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_expm_const((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expm__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_expm((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_jacobian__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_jacobian((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_jtimes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  bool arg4 = (bool) false ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_jtimes((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearize__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_linearize((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_which_depends__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) 1 ;
  bool arg4 = (bool) false ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  std::vector< bool,std::allocator< bool > > result;
  
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_which_depends((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "bool" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_linear__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = (bool)casadi::casadi_is_linear((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_quadratic__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = (bool)casadi::casadi_is_quadratic((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gradient__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_gradient((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tangent__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_tangent((casadi::MX const &)*arg1,(casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_hessian__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX result;
  
  arg3 = &m3;
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_hessian((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_quadratic_coeff__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX *arg4 = 0 ;
  casadi::MX *arg5 = 0 ;
  bool arg6 = (bool) true ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX m4 ;
  casadi::MX m5 ;
  
  arg3 = &m3;
  arg4 = &m4;
  arg5 = &m5;
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_quadratic_coeff((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,*arg3,*arg4,*arg5,arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg5));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linear_coeff__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX *arg4 = 0 ;
  bool arg5 = (bool) true ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX m4 ;
  
  arg3 = &m3;
  arg4 = &m4;
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_linear_coeff((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,*arg3,*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_n_nodes__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_n_nodes((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_print_operator__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ;
  casadi::MX m1 ;
  std::vector< std::string > m2 ;
  std::string result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "str" "]" "'.");
  {
    try {
      result = casadi::casadi_print_operator((casadi::MX const &)*arg1,(std::vector< std::string,std::allocator< std::string > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repsum__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_repsum((casadi::MX const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diff__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_index arg3 = (casadi_index) -1 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_diff((casadi::MX const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cumsum__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi_index arg2 = (casadi_index) -1 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_cumsum((casadi::MX const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_einstein__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg7 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg8 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg9 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< casadi_int > m7 ;
  std::vector< casadi_int > m8 ;
  std::vector< casadi_int > m9 ;
  casadi::MX result;
  
  if ((nobjs < 9) || (nobjs > 9)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  arg7 = &m7;
  if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "[" "int" "]" "'.");
  arg8 = &m8;
  if (!casadi::to_ptr(swig_obj[7], &arg8)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 8 to type '" "[" "int" "]" "'.");
  arg9 = &m9;
  if (!casadi::to_ptr(swig_obj[8], &arg9)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 9 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_einstein((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,(std::vector< long long,std::allocator< long long > > const &)*arg7,(std::vector< long long,std::allocator< long long > > const &)*arg8,(std::vector< long long,std::allocator< long long > > const &)*arg9);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_einstein__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg7 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg8 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< casadi_int > m7 ;
  std::vector< casadi_int > m8 ;
  casadi::MX result;
  
  if ((nobjs < 8) || (nobjs > 8)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  arg7 = &m7;
  if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "[" "int" "]" "'.");
  arg8 = &m8;
  if (!casadi::to_ptr(swig_obj[7], &arg8)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 8 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_einstein((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,(std::vector< long long,std::allocator< long long > > const &)*arg7,(std::vector< long long,std::allocator< long long > > const &)*arg8);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mmin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_mmin((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mmax__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_mmax((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_evalf__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  casadi::DM result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_evalf((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_forward__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< casadi::MX > m1 ;
  std::vector< casadi::MX > m2 ;
  std::vector< std::vector< casadi::MX > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "MX" "]" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_forward((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "MX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reverse__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< casadi::MX > m1 ;
  std::vector< casadi::MX > m2 ;
  std::vector< std::vector< casadi::MX > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "MX" "]" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_reverse((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "MX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_substitute__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_substitute((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_substitute__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  std::vector< casadi::MX > m1 ;
  std::vector< casadi::MX > m2 ;
  std::vector< casadi::MX > m3 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = casadi::casadi_substitute((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_substitute_inplace__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  std::vector< casadi::MX > m1 ;
  std::vector< casadi::MX > m2 ;
  std::vector< casadi::MX > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "MX" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_substitute_inplace((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,*arg2,*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shared__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg4 = 0 ;
  std::string const &arg5_defvalue = "v_" ;
  std::string *arg5 = (std::string *) &arg5_defvalue ;
  std::string const &arg6_defvalue = "" ;
  std::string *arg6 = (std::string *) &arg6_defvalue ;
  std::vector< casadi::MX > m1 ;
  std::vector< casadi::MX > m2 ;
  std::vector< casadi::MX > m3 ;
  std::vector< casadi::MX > m4 ;
  std::string m5 ;
  std::string m6 ;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  if (swig_obj[1]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[1], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[2], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "str" "'.");
  }
  {
    try {
      casadi::casadi_shared((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,*arg2,*arg3,*arg4,(std::string const &)*arg5,(std::string const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blockcat__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > *arg1 = 0 ;
  std::vector< std::vector< casadi::MX > > m1 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "[" "MX" "]" "]" "'.");
  {
    try {
      result = casadi::casadi_blockcat((std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mpower__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_mpower((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mrdivide__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_mrdivide((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mldivide__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_mldivide((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_symvar__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_symvar((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_bilin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_bilin((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rank1__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > *arg4 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > m4 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_rank1((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,(casadi::Matrix< double > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sumsqr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_sumsqr((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linspace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi_int arg3 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_linspace((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_interp1d__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< double,std::allocator< double > > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  std::string const &arg4_defvalue = "linear" ;
  std::string *arg4 = (std::string *) &arg4_defvalue ;
  bool arg5 = (bool) false ;
  std::vector< double > m1 ;
  casadi::Matrix< double > m2 ;
  std::vector< double > m3 ;
  std::string m4 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "float" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "str" "'.");
  }
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_interp1d((std::vector< double,std::allocator< double > > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,(std::string const &)*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_soc__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_soc((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cross__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) -1 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_cross((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_skew__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_skew((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv_skew__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_inv_skew((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_det__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_det((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv_minor__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_inv_minor((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_inv((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::Matrix< double > m1 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_inv((casadi::Matrix< double > const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_trace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_trace((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tril2symm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_tril2symm((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_triu2symm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_triu2symm((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_fro__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_norm_fro((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_2__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_norm_2((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_1__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_norm_1((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_inf__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_norm_inf((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dot__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_dot((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nullspace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_nullspace((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_polyval__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_polyval((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diag__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_diag((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_unite__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_unite((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_densify__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_densify((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_project__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  bool arg3 = (bool) false ;
  casadi::Matrix< double > m1 ;
  casadi::Sparsity m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_project((casadi::Matrix< double > const &)*arg1,(casadi::Sparsity const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_if_else__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_if_else((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conditional__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  casadi::Matrix< double > m1 ;
  std::vector< casadi::Matrix< double > > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_conditional((casadi::Matrix< double > const &)*arg1,(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg2,(casadi::Matrix< double > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_depends_on__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = (bool)casadi::casadi_depends_on((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solve__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_solve((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solve__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  std::string m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_solve((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(std::string const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pinv__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_pinv((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pinv__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::Matrix< double > m1 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_pinv((casadi::Matrix< double > const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expm_const__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_expm_const((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expm__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_expm((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_jacobian__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_jacobian((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_jtimes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_jtimes((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearize__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_linearize((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_which_depends__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) 1 ;
  bool arg4 = (bool) false ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  std::vector< bool,std::allocator< bool > > result;
  
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_which_depends((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "bool" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_linear__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = (bool)casadi::casadi_is_linear((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_quadratic__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = (bool)casadi::casadi_is_quadratic((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gradient__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_gradient((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tangent__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_tangent((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_hessian__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  arg3 = &m3;
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_hessian((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_quadratic_coeff__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > *arg4 = 0 ;
  casadi::Matrix< double > *arg5 = 0 ;
  bool arg6 = (bool) true ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > m4 ;
  casadi::Matrix< double > m5 ;
  
  arg3 = &m3;
  arg4 = &m4;
  arg5 = &m5;
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_quadratic_coeff((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,*arg3,*arg4,*arg5,arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg5));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linear_coeff__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > *arg4 = 0 ;
  bool arg5 = (bool) true ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > m4 ;
  
  arg3 = &m3;
  arg4 = &m4;
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_linear_coeff((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,*arg3,*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_n_nodes__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_n_nodes((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_print_operator__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  std::vector< std::string > m2 ;
  std::string result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "str" "]" "'.");
  {
    try {
      result = casadi::casadi_print_operator((casadi::Matrix< double > const &)*arg1,(std::vector< std::string,std::allocator< std::string > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repsum__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_repsum((casadi::Matrix< double > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diff__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_index arg3 = (casadi_index) -1 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_diff((casadi::Matrix< double > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cumsum__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_index arg2 = (casadi_index) -1 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_cumsum((casadi::Matrix< double > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_einstein__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg7 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg8 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg9 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< casadi_int > m7 ;
  std::vector< casadi_int > m8 ;
  std::vector< casadi_int > m9 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 9) || (nobjs > 9)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  arg7 = &m7;
  if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "[" "int" "]" "'.");
  arg8 = &m8;
  if (!casadi::to_ptr(swig_obj[7], &arg8)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 8 to type '" "[" "int" "]" "'.");
  arg9 = &m9;
  if (!casadi::to_ptr(swig_obj[8], &arg9)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 9 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_einstein((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,(std::vector< long long,std::allocator< long long > > const &)*arg7,(std::vector< long long,std::allocator< long long > > const &)*arg8,(std::vector< long long,std::allocator< long long > > const &)*arg9);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_einstein__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg7 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg8 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< casadi_int > m7 ;
  std::vector< casadi_int > m8 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 8) || (nobjs > 8)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  arg7 = &m7;
  if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "[" "int" "]" "'.");
  arg8 = &m8;
  if (!casadi::to_ptr(swig_obj[7], &arg8)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 8 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_einstein((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,(std::vector< long long,std::allocator< long long > > const &)*arg7,(std::vector< long long,std::allocator< long long > > const &)*arg8);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mmin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_mmin((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mmax__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_mmax((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_evalf__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::DM result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_evalf((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_forward__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg2 = 0 ;
  std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< casadi::Matrix< double > > m1 ;
  std::vector< casadi::Matrix< double > > m2 ;
  std::vector< std::vector< casadi::Matrix< double > > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "DM" "]" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_forward((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1,(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg2,(std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "DM" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reverse__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg2 = 0 ;
  std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< casadi::Matrix< double > > m1 ;
  std::vector< casadi::Matrix< double > > m2 ;
  std::vector< std::vector< casadi::Matrix< double > > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "DM" "]" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_reverse((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1,(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg2,(std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "DM" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_substitute__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_substitute((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_substitute__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg2 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg3 = 0 ;
  std::vector< casadi::Matrix< double > > m1 ;
  std::vector< casadi::Matrix< double > > m2 ;
  std::vector< casadi::Matrix< double > > m3 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "DM" "]" "'.");
  {
    try {
      result = casadi::casadi_substitute((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1,(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg2,(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_substitute_inplace__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg2 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  std::vector< casadi::Matrix< double > > m1 ;
  std::vector< casadi::Matrix< double > > m2 ;
  std::vector< casadi::Matrix< double > > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "DM" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "DM" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_substitute_inplace((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1,*arg2,*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shared__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg2 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg3 = 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg4 = 0 ;
  std::string const &arg5_defvalue = "v_" ;
  std::string *arg5 = (std::string *) &arg5_defvalue ;
  std::string const &arg6_defvalue = "" ;
  std::string *arg6 = (std::string *) &arg6_defvalue ;
  std::vector< casadi::Matrix< double > > m1 ;
  std::vector< casadi::Matrix< double > > m2 ;
  std::vector< casadi::Matrix< double > > m3 ;
  std::vector< casadi::Matrix< double > > m4 ;
  std::string m5 ;
  std::string m6 ;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "DM" "]" "'.");
  if (swig_obj[1]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[1], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[2], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "str" "'.");
  }
  {
    try {
      casadi::casadi_shared((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg1,*arg2,*arg3,*arg4,(std::string const &)*arg5,(std::string const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blockcat__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > *arg1 = 0 ;
  std::vector< std::vector< casadi::Matrix< double > > > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "[" "DM" "]" "]" "'.");
  {
    try {
      result = casadi::casadi_blockcat((std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mpower__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_mpower((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mpower(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "mpower", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_mpower__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_mpower__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_mpower__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'mpower'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_mpower(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_mpower(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_mpower(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_mrdivide__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_mrdivide((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mrdivide(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "mrdivide", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_mrdivide__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_mrdivide__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_mrdivide__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'mrdivide'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_mrdivide(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_mrdivide(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_mrdivide(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_mldivide__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_mldivide((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mldivide(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "mldivide", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_mldivide__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_mldivide__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_mldivide__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'mldivide'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_mldivide(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_mldivide(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_mldivide(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_symvar__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_symvar((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_symvar(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "symvar", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_symvar__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_symvar__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_symvar__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'symvar'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_symvar(casadi::MX const &)\n"
    "    casadi::casadi_symvar(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_symvar(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_bilin__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_bilin((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_bilin(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "bilin", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          return _wrap_bilin__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          return _wrap_bilin__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          return _wrap_bilin__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'bilin'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_bilin(casadi::MX const &,casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_bilin(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_bilin(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_rank1__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg4 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > m4 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_rank1((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,(casadi::Matrix< casadi::SXElem > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rank1(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "rank1", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<double> **>(0));
          if (_v) {
            return _wrap_rank1__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
          if (_v) {
            return _wrap_rank1__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::MX **>(0));
          if (_v) {
            return _wrap_rank1__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'rank1'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_rank1(casadi::MX const &,casadi::MX const &,casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_rank1(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_rank1(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_sumsqr__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_sumsqr((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sumsqr(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "sumsqr", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_sumsqr__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_sumsqr__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_sumsqr__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'sumsqr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_sumsqr(casadi::MX const &)\n"
    "    casadi::casadi_sumsqr(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_sumsqr(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_linspace__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi_int arg3 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_linspace((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linspace(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "linspace", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_linspace__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_linspace__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_linspace__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'linspace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_linspace(casadi::MX const &,casadi::MX const &,casadi_int)\n"
    "    casadi::casadi_linspace(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi_int)\n"
    "    casadi::casadi_linspace(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_interp1d__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< double,std::allocator< double > > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  std::string const &arg4_defvalue = "linear" ;
  std::string *arg4 = (std::string *) &arg4_defvalue ;
  bool arg5 = (bool) false ;
  std::vector< double > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  std::vector< double > m3 ;
  std::string m4 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "float" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "str" "'.");
  }
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_interp1d((std::vector< double,std::allocator< double > > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,(std::string const &)*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_interp1d(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "interp1d", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_interp1d__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::string **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_interp1d__SWIG_1(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< bool **>(0));
            if (_v) {
              return _wrap_interp1d__SWIG_1(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_interp1d__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::string **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_interp1d__SWIG_2(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< bool **>(0));
            if (_v) {
              return _wrap_interp1d__SWIG_2(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_interp1d__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::string **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_interp1d__SWIG_0(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< bool **>(0));
            if (_v) {
              return _wrap_interp1d__SWIG_0(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'interp1d'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_interp1d(std::vector< double,std::allocator< double > > const &,casadi::MX const &,std::vector< double,std::allocator< double > > const &,std::string const &,bool)\n"
    "    casadi::casadi_interp1d(std::vector< double,std::allocator< double > > const &,casadi::Matrix< double > const &,std::vector< double,std::allocator< double > > const &,std::string const &,bool)\n"
    "    casadi::casadi_interp1d(std::vector< double,std::allocator< double > > const &,casadi::Matrix< casadi::SXElem > const &,std::vector< double,std::allocator< double > > const &,std::string const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_soc__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_soc((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_soc(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "soc", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_soc__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_soc__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_soc__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'soc'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_soc(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_soc(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_soc(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_cross__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) -1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_cross((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cross(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "cross", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_cross__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_cross__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_cross__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_cross__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_cross__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_cross__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'cross'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_cross(casadi::MX const &,casadi::MX const &,casadi_int)\n"
    "    casadi::casadi_cross(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi_int)\n"
    "    casadi::casadi_cross(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_skew__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_skew((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_skew(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "skew", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_skew__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_skew__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_skew__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'skew'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_skew(casadi::MX const &)\n"
    "    casadi::casadi_skew(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_skew(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_inv_skew__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_inv_skew((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv_skew(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "inv_skew", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_inv_skew__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_inv_skew__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_inv_skew__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'inv_skew'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_inv_skew(casadi::MX const &)\n"
    "    casadi::casadi_inv_skew(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_inv_skew(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_det__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_det((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_det(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "det", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_det__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_det__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_det__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'det'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_det(casadi::MX const &)\n"
    "    casadi::casadi_det(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_det(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_inv_minor__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_inv_minor((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv_minor(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "inv_minor", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_inv_minor__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_inv_minor__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_inv_minor__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'inv_minor'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_inv_minor(casadi::MX const &)\n"
    "    casadi::casadi_inv_minor(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_inv_minor(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_inv__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_inv((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_inv((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "inv", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_inv__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_inv__SWIG_4(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_inv__SWIG_0(self, argc, argv);
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_inv__SWIG_3(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_inv__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_inv__SWIG_5(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_inv__SWIG_5(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_inv__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_inv__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'inv'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_inv(casadi::MX const &)\n"
    "    casadi::casadi_inv(casadi::MX const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::casadi_inv(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_inv(casadi::Matrix< double > const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::casadi_inv(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_inv(casadi::Matrix< casadi::SXElem > const &,std::string const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_trace__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_trace((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_trace(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "trace", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_trace__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_trace__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_trace__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'trace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_trace(casadi::MX const &)\n"
    "    casadi::casadi_trace(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_trace(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_tril2symm__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_tril2symm((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tril2symm(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "tril2symm", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_tril2symm__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_tril2symm__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_tril2symm__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'tril2symm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_tril2symm(casadi::MX const &)\n"
    "    casadi::casadi_tril2symm(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_tril2symm(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_triu2symm__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_triu2symm((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_triu2symm(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "triu2symm", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_triu2symm__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_triu2symm__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_triu2symm__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'triu2symm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_triu2symm(casadi::MX const &)\n"
    "    casadi::casadi_triu2symm(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_triu2symm(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_norm_fro__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_norm_fro((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_fro(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "norm_fro", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_norm_fro__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_norm_fro__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_norm_fro__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'norm_fro'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_norm_fro(casadi::MX const &)\n"
    "    casadi::casadi_norm_fro(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_norm_fro(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_norm_2__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_norm_2((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_2(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "norm_2", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_norm_2__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_norm_2__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_norm_2__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'norm_2'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_norm_2(casadi::MX const &)\n"
    "    casadi::casadi_norm_2(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_norm_2(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_norm_1__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_norm_1((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_1(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "norm_1", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_norm_1__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_norm_1__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_norm_1__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'norm_1'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_norm_1(casadi::MX const &)\n"
    "    casadi::casadi_norm_1(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_norm_1(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_norm_inf__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_norm_inf((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_inf(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "norm_inf", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_norm_inf__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_norm_inf__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_norm_inf__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'norm_inf'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_norm_inf(casadi::MX const &)\n"
    "    casadi::casadi_norm_inf(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_norm_inf(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_dot__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_dot((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_dot(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "dot", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_dot__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_dot__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_dot__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'dot'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_dot(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_dot(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_dot(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_nullspace__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_nullspace((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_nullspace(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "nullspace", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_nullspace__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_nullspace__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_nullspace__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'nullspace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_nullspace(casadi::MX const &)\n"
    "    casadi::casadi_nullspace(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_nullspace(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_polyval__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_polyval((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_polyval(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "polyval", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_polyval__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_polyval__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_polyval__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'polyval'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_polyval(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_polyval(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_polyval(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_diag__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_diag((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diag(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "diag", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_diag__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_diag__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_diag__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'diag'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_diag(casadi::MX const &)\n"
    "    casadi::casadi_diag(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_diag(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_unite__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_unite((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_unite(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "unite", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_unite__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_unite__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_unite__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'unite'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_unite(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_unite(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_unite(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_densify__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_densify((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_densify(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "densify", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_densify__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_densify__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_densify__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'densify'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_densify(casadi::MX const &)\n"
    "    casadi::casadi_densify(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_densify(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_project__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Sparsity *arg2 = 0 ;
  bool arg3 = (bool) false ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Sparsity m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_project((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Sparsity const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_project(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "project", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_project__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_project__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_project__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_project__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_project__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_project__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'project'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_project(casadi::MX const &,casadi::Sparsity const &,bool)\n"
    "    casadi::casadi_project(casadi::Matrix< double > const &,casadi::Sparsity const &,bool)\n"
    "    casadi::casadi_project(casadi::Matrix< casadi::SXElem > const &,casadi::Sparsity const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_if_else__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_if_else((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_if_else(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "if_else", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_if_else__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_if_else__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_if_else__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_if_else__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_if_else__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_if_else__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'if_else'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_if_else(casadi::MX const &,casadi::MX const &,casadi::MX const &,bool)\n"
    "    casadi::casadi_if_else(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,bool)\n"
    "    casadi::casadi_if_else(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_conditional__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_conditional((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_conditional(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "conditional", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_conditional__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_conditional__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_conditional__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_conditional__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_conditional__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_conditional__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'conditional'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_conditional(casadi::MX const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,casadi::MX const &,bool)\n"
    "    casadi::casadi_conditional(casadi::Matrix< double > const &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,casadi::Matrix< double > const &,bool)\n"
    "    casadi::casadi_conditional(casadi::Matrix< casadi::SXElem > const &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,casadi::Matrix< casadi::SXElem > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_depends_on__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = (bool)casadi::casadi_depends_on((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_depends_on(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "depends_on", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_depends_on__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_depends_on__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_depends_on__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'depends_on'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_depends_on(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_depends_on(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_depends_on(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_solve__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_solve((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solve__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  std::string *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  std::string m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_solve((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(std::string const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_solve(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "solve", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_solve__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_solve__SWIG_4(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_solve__SWIG_0(self, argc, argv);
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_solve__SWIG_3(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_solve__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_solve__SWIG_5(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_solve__SWIG_5(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_solve__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_solve__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'solve'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_solve(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_solve(casadi::MX const &,casadi::MX const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::casadi_solve(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_solve(casadi::Matrix< double > const &,casadi::Matrix< double > const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::casadi_solve(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_solve(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,std::string const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_pinv__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_pinv((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pinv__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_pinv((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::string const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pinv(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "pinv", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_pinv__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_pinv__SWIG_4(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_pinv__SWIG_0(self, argc, argv);
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_pinv__SWIG_3(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_pinv__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_pinv__SWIG_5(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_pinv__SWIG_5(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_pinv__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_pinv__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'pinv'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_pinv(casadi::MX const &)\n"
    "    casadi::casadi_pinv(casadi::MX const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::casadi_pinv(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_pinv(casadi::Matrix< double > const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::casadi_pinv(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_pinv(casadi::Matrix< casadi::SXElem > const &,std::string const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_expm_const__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_expm_const((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expm_const(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "expm_const", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_expm_const__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_expm_const__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_expm_const__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'expm_const'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_expm_const(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_expm_const(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_expm_const(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_expm__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_expm((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expm(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "expm", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_expm__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_expm__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_expm__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'expm'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_expm(casadi::MX const &)\n"
    "    casadi::casadi_expm(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_expm(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_jacobian__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_jacobian((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_jacobian(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "jacobian", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_jacobian__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_jacobian__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_jacobian__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_jacobian__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_jacobian__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_jacobian__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'jacobian'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_jacobian(casadi::MX const &,casadi::MX const &,casadi::Dict const &)\n"
    "    casadi::casadi_jacobian(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Dict const &)\n"
    "    casadi::casadi_jacobian(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_jtimes__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_jtimes((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_jtimes(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "jtimes", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_jtimes__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_jtimes__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_jtimes__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_jtimes__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_jtimes__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_jtimes__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'jtimes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_jtimes(casadi::MX const &,casadi::MX const &,casadi::MX const &,bool)\n"
    "    casadi::casadi_jtimes(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,bool)\n"
    "    casadi::casadi_jtimes(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_linearize__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_linearize((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linearize(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "linearize", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          return _wrap_linearize__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          return _wrap_linearize__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          return _wrap_linearize__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'linearize'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_linearize(casadi::MX const &,casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_linearize(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_linearize(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_which_depends__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) 1 ;
  bool arg4 = (bool) false ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  std::vector< bool,std::allocator< bool > > result;
  
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_which_depends((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "bool" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_which_depends(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "which_depends", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_which_depends__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_which_depends__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_which_depends__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_which_depends__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_which_depends__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_which_depends__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_which_depends__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_which_depends__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_which_depends__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'which_depends'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_which_depends(casadi::MX const &,casadi::MX const &,casadi_int,bool)\n"
    "    casadi::casadi_which_depends(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi_int,bool)\n"
    "    casadi::casadi_which_depends(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_is_linear__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = (bool)casadi::casadi_is_linear((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_linear(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "is_linear", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_is_linear__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_is_linear__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_is_linear__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'is_linear'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_is_linear(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_is_linear(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_is_linear(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_is_quadratic__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  bool result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = (bool)casadi::casadi_is_quadratic((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_is_quadratic(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "is_quadratic", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_is_quadratic__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_is_quadratic__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_is_quadratic__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'is_quadratic'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_is_quadratic(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_is_quadratic(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_is_quadratic(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_gradient__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_gradient((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gradient(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "gradient", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_gradient__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_gradient__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_gradient__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'gradient'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_gradient(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_gradient(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_gradient(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_tangent__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_tangent((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_tangent(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "tangent", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_tangent__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_tangent__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_tangent__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'tangent'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_tangent(casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_tangent(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_tangent(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_hessian__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  arg3 = &m3;
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_hessian((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_hessian(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "hessian", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_hessian__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_hessian__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_hessian__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'hessian'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_hessian(casadi::MX const &,casadi::MX const &,casadi::MX &)\n"
    "    casadi::casadi_hessian(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > &)\n"
    "    casadi::casadi_hessian(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_quadratic_coeff__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg4 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg5 = 0 ;
  bool arg6 = (bool) true ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > m4 ;
  casadi::Matrix< casadi::SXElem > m5 ;
  
  arg3 = &m3;
  arg4 = &m4;
  arg5 = &m5;
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_quadratic_coeff((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,*arg3,*arg4,*arg5,arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg5));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_quadratic_coeff(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "quadratic_coeff", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_quadratic_coeff__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_quadratic_coeff__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_quadratic_coeff__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_quadratic_coeff__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_quadratic_coeff__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_quadratic_coeff__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'quadratic_coeff'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_quadratic_coeff(casadi::MX const &,casadi::MX const &,casadi::MX &,casadi::MX &,casadi::MX &,bool)\n"
    "    casadi::casadi_quadratic_coeff(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > &,casadi::Matrix< double > &,casadi::Matrix< double > &,bool)\n"
    "    casadi::casadi_quadratic_coeff(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > &,casadi::Matrix< casadi::SXElem > &,casadi::Matrix< casadi::SXElem > &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_linear_coeff__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg4 = 0 ;
  bool arg5 = (bool) true ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > m4 ;
  
  arg3 = &m3;
  arg4 = &m4;
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_linear_coeff((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,*arg3,*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_linear_coeff(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "linear_coeff", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_linear_coeff__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_linear_coeff__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_linear_coeff__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_linear_coeff__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_linear_coeff__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_linear_coeff__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'linear_coeff'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_linear_coeff(casadi::MX const &,casadi::MX const &,casadi::MX &,casadi::MX &,bool)\n"
    "    casadi::casadi_linear_coeff(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > &,casadi::Matrix< double > &,bool)\n"
    "    casadi::casadi_linear_coeff(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > &,casadi::Matrix< casadi::SXElem > &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_n_nodes__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi_int result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = (casadi_int)casadi::casadi_n_nodes((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_n_nodes(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "n_nodes", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_n_nodes__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_n_nodes__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_n_nodes__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'n_nodes'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_n_nodes(casadi::MX const &)\n"
    "    casadi::casadi_n_nodes(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_n_nodes(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_print_operator__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  std::vector< std::string > m2 ;
  std::string result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "str" "]" "'.");
  {
    try {
      result = casadi::casadi_print_operator((casadi::Matrix< casadi::SXElem > const &)*arg1,(std::vector< std::string,std::allocator< std::string > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_print_operator(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "print_operator", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<std::string> **>(0));
      if (_v) {
        return _wrap_print_operator__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<std::string> **>(0));
      if (_v) {
        return _wrap_print_operator__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<std::string> **>(0));
      if (_v) {
        return _wrap_print_operator__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'print_operator'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_print_operator(casadi::MX const &,std::vector< std::string,std::allocator< std::string > > const &)\n"
    "    casadi::casadi_print_operator(casadi::Matrix< double > const &,std::vector< std::string,std::allocator< std::string > > const &)\n"
    "    casadi::casadi_print_operator(casadi::Matrix< casadi::SXElem > const &,std::vector< std::string,std::allocator< std::string > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_repsum__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_repsum((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_repsum(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "repsum", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_repsum__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_repsum__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_repsum__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_repsum__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_repsum__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_repsum__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'repsum'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_repsum(casadi::MX const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_repsum(casadi::Matrix< double > const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_repsum(casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_diff__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_index arg3 = (casadi_index) -1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_diff((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_diff(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "diff", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_diff__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_diff__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_diff__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_diff__SWIG_2(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_diff__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_diff__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_diff__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_diff__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_diff__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'diff'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_diff(casadi::MX const &,casadi_int,casadi_index)\n"
    "    casadi::casadi_diff(casadi::Matrix< double > const &,casadi_int,casadi_index)\n"
    "    casadi::casadi_diff(casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi_index)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_cumsum__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_index arg2 = (casadi_index) -1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_cumsum((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cumsum(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "cumsum", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_cumsum__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_cumsum__SWIG_1(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_cumsum__SWIG_2(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_cumsum__SWIG_2(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_cumsum__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_cumsum__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'cumsum'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_cumsum(casadi::MX const &,casadi_index)\n"
    "    casadi::casadi_cumsum(casadi::Matrix< double > const &,casadi_index)\n"
    "    casadi::casadi_cumsum(casadi::Matrix< casadi::SXElem > const &,casadi_index)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_einstein__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg7 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg8 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg9 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< casadi_int > m7 ;
  std::vector< casadi_int > m8 ;
  std::vector< casadi_int > m9 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 9) || (nobjs > 9)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  arg7 = &m7;
  if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "[" "int" "]" "'.");
  arg8 = &m8;
  if (!casadi::to_ptr(swig_obj[7], &arg8)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 8 to type '" "[" "int" "]" "'.");
  arg9 = &m9;
  if (!casadi::to_ptr(swig_obj[8], &arg9)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 9 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_einstein((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,(std::vector< long long,std::allocator< long long > > const &)*arg7,(std::vector< long long,std::allocator< long long > > const &)*arg8,(std::vector< long long,std::allocator< long long > > const &)*arg9);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_einstein__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg7 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg8 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  std::vector< casadi_int > m3 ;
  std::vector< casadi_int > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  std::vector< casadi_int > m7 ;
  std::vector< casadi_int > m8 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 8) || (nobjs > 8)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  arg7 = &m7;
  if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "[" "int" "]" "'.");
  arg8 = &m8;
  if (!casadi::to_ptr(swig_obj[7], &arg8)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 8 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_einstein((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(std::vector< long long,std::allocator< long long > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,(std::vector< long long,std::allocator< long long > > const &)*arg7,(std::vector< long long,std::allocator< long long > > const &)*arg8);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_einstein(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[10] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "einstein", 0, 9, argv))) SWIG_fail;
  --argc;
  if (argc == 8) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                _v = casadi::to_ptr(argv[6], static_cast< std::vector<casadi_int> **>(0));
                if (_v) {
                  _v = casadi::to_ptr(argv[7], static_cast< std::vector<casadi_int> **>(0));
                  if (_v) {
                    return _wrap_einstein__SWIG_3(self, argc, argv);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                _v = casadi::to_ptr(argv[6], static_cast< std::vector<casadi_int> **>(0));
                if (_v) {
                  _v = casadi::to_ptr(argv[7], static_cast< std::vector<casadi_int> **>(0));
                  if (_v) {
                    return _wrap_einstein__SWIG_5(self, argc, argv);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 8) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi_int> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                _v = casadi::to_ptr(argv[6], static_cast< std::vector<casadi_int> **>(0));
                if (_v) {
                  _v = casadi::to_ptr(argv[7], static_cast< std::vector<casadi_int> **>(0));
                  if (_v) {
                    return _wrap_einstein__SWIG_1(self, argc, argv);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                _v = casadi::to_ptr(argv[6], static_cast< std::vector<casadi_int> **>(0));
                if (_v) {
                  _v = casadi::to_ptr(argv[7], static_cast< std::vector<casadi_int> **>(0));
                  if (_v) {
                    _v = casadi::to_ptr(argv[8], static_cast< std::vector<casadi_int> **>(0));
                    if (_v) {
                      return _wrap_einstein__SWIG_2(self, argc, argv);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                _v = casadi::to_ptr(argv[6], static_cast< std::vector<casadi_int> **>(0));
                if (_v) {
                  _v = casadi::to_ptr(argv[7], static_cast< std::vector<casadi_int> **>(0));
                  if (_v) {
                    _v = casadi::to_ptr(argv[8], static_cast< std::vector<casadi_int> **>(0));
                    if (_v) {
                      return _wrap_einstein__SWIG_4(self, argc, argv);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (argc == 9) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                _v = casadi::to_ptr(argv[6], static_cast< std::vector<casadi_int> **>(0));
                if (_v) {
                  _v = casadi::to_ptr(argv[7], static_cast< std::vector<casadi_int> **>(0));
                  if (_v) {
                    _v = casadi::to_ptr(argv[8], static_cast< std::vector<casadi_int> **>(0));
                    if (_v) {
                      return _wrap_einstein__SWIG_0(self, argc, argv);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'einstein'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_einstein(casadi::MX const &,casadi::MX const &,casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_einstein(casadi::MX const &,casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_einstein(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_einstein(casadi::Matrix< double > const &,casadi::Matrix< double > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_einstein(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_einstein(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_mmin__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_mmin((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mmin(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "mmin", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_mmin__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_mmin__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_mmin__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'mmin'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_mmin(casadi::MX const &)\n"
    "    casadi::casadi_mmin(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_mmin(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_mmax__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_mmax((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mmax(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "mmax", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_mmax__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_mmax__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_mmax__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'mmax'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_mmax(casadi::MX const &)\n"
    "    casadi::casadi_mmax(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_mmax(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_evalf__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::DM result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_evalf((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_evalf(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "evalf", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_evalf__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_evalf__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      return _wrap_evalf__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'evalf'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_evalf(casadi::MX const &)\n"
    "    casadi::casadi_evalf(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_evalf(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_forward__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg2 = 0 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem > > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "SX" "]" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_forward((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1,(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg2,(std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "SX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_forward(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "forward", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector< casadi::Matrix<double> > > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_forward__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_forward__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector< casadi::Matrix<casadi::SXElem> > > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_forward__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_forward__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector<casadi::MX> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_forward__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_forward__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'forward'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_forward(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const &,casadi::Dict const &)\n"
    "    casadi::casadi_forward(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const &,casadi::Dict const &)\n"
    "    casadi::casadi_forward(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_reverse__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg2 = 0 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem > > > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "SX" "]" "]" "'.");
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_reverse((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1,(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg2,(std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const &)*arg3,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "[" "SX" "]" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_reverse(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "reverse", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector< casadi::Matrix<double> > > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_reverse__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_reverse__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector< casadi::Matrix<casadi::SXElem> > > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_reverse__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_reverse__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector<casadi::MX> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_reverse__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_reverse__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'reverse'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_reverse(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const &,casadi::Dict const &)\n"
    "    casadi::casadi_reverse(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const &,casadi::Dict const &)\n"
    "    casadi::casadi_reverse(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_substitute__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_substitute((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_substitute__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg2 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg3 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m3 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "SX" "]" "'.");
  {
    try {
      result = casadi::casadi_substitute((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1,(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg2,(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_substitute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "substitute", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          return _wrap_substitute__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector< casadi::Matrix<double> > **>(0));
        if (_v) {
          return _wrap_substitute__SWIG_3(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          return _wrap_substitute__SWIG_4(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
        if (_v) {
          return _wrap_substitute__SWIG_5(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          return _wrap_substitute__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          return _wrap_substitute__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'substitute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_substitute(casadi::MX const &,casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_substitute(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n"
    "    casadi::casadi_substitute(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_substitute(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)\n"
    "    casadi::casadi_substitute(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_substitute(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_substitute_inplace__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg2 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "SX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input to type '" "[" "SX" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_substitute_inplace((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1,*arg2,*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_substitute_inplace(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "substitute_inplace", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector< casadi::Matrix<double> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_substitute_inplace__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_substitute_inplace__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_substitute_inplace__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_substitute_inplace__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_substitute_inplace__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_substitute_inplace__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'substitute_inplace'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_substitute_inplace(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > &,std::vector< casadi::MX,std::allocator< casadi::MX > > &,bool)\n"
    "    casadi::casadi_substitute_inplace(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > &,bool)\n"
    "    casadi::casadi_substitute_inplace(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_shared__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg2 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg3 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg4 = 0 ;
  std::string const &arg5_defvalue = "v_" ;
  std::string *arg5 = (std::string *) &arg5_defvalue ;
  std::string const &arg6_defvalue = "" ;
  std::string *arg6 = (std::string *) &arg6_defvalue ;
  std::vector< casadi::Matrix< casadi::SXElem > > m1 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m3 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m4 ;
  std::string m5 ;
  std::string m6 ;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "SX" "]" "'.");
  if (swig_obj[1]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[1], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[2], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "str" "'.");
  }
  {
    try {
      casadi::casadi_shared((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg1,*arg2,*arg3,*arg4,(std::string const &)*arg5,(std::string const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_shared(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "shared", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<double> > **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_shared__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_shared__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          return _wrap_shared__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_shared__SWIG_2(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_shared__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          return _wrap_shared__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_shared__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_shared__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::string **>(0));
        if (_v) {
          return _wrap_shared__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'shared'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_shared(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > &,std::vector< casadi::MX,std::allocator< casadi::MX > > &,std::vector< casadi::MX,std::allocator< casadi::MX > > &,std::string const &,std::string const &)\n"
    "    casadi::casadi_shared(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > &,std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > &,std::string const &,std::string const &)\n"
    "    casadi::casadi_shared(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > &,std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > &,std::string const &,std::string const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_blockcat__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > *arg1 = 0 ;
  std::vector< std::vector< casadi::Matrix< casadi::SXElem > > > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "[" "SX" "]" "]" "'.");
  {
    try {
      result = casadi::casadi_blockcat((std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_blockcat(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "blockcat", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<std::vector< casadi::Matrix<double> > > **>(0));
    if (_v) {
      return _wrap_blockcat__SWIG_5(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<std::vector< casadi::Matrix<casadi::SXElem> > > **>(0));
    if (_v) {
      return _wrap_blockcat__SWIG_6(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<std::vector<casadi::MX> > **>(0));
    if (_v) {
      return _wrap_blockcat__SWIG_4(self, argc, argv);
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Sparsity **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Sparsity **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Sparsity **>(0));
          if (_v) {
            return _wrap_blockcat__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<double> **>(0));
          if (_v) {
            return _wrap_blockcat__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
          if (_v) {
            return _wrap_blockcat__SWIG_3(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::MX **>(0));
          if (_v) {
            return _wrap_blockcat__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'blockcat'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_blockcat(casadi::Sparsity const &,casadi::Sparsity const &,casadi::Sparsity const &,casadi::Sparsity const &)\n"
    "    casadi::casadi_blockcat(casadi::MX const &,casadi::MX const &,casadi::MX const &,casadi::MX const &)\n"
    "    casadi::casadi_blockcat(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_blockcat(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::casadi_blockcat(std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const &)\n"
    "    casadi::casadi_blockcat(std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const &)\n"
    "    casadi::casadi_blockcat(std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_logic_all__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_all((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_logic_any__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_any((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_adj__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_adj((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_minor__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_minor((casadi::Matrix< double > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cofactor__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_cofactor((casadi::Matrix< double > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_qr__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  
  arg2 = &m2;
  arg3 = &m3;
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      casadi::casadi_qr((casadi::Matrix< double > const &)*arg1,*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_qr_sparse__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  bool arg7 = (bool) true ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  arg5 = &m5;
  arg6 = &m6;
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_qr_sparse((casadi::Matrix< double > const &)*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg5));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg6));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_qr_solve__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  bool arg7 = (bool) false ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 6) || (nobjs > 7)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "DM" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  if (swig_obj[6]) {
    if (!casadi::to_val(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_qr_solve((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,(casadi::Matrix< double > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ldl__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  bool arg5 = (bool) true ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  std::vector< casadi_int > m4 ;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_ldl((casadi::Matrix< double > const &)*arg1,*arg2,*arg3,*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ldl_solve__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  std::vector< casadi_int > m4 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_ldl_solve((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_chol__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_chol((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_inf_mul__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_norm_inf_mul((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sparsify__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  double arg2 = (double) 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  }
  {
    try {
      result = casadi::casadi_sparsify((casadi::Matrix< double > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expand__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  
  arg2 = &m2;
  arg3 = &m3;
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      casadi::casadi_expand((casadi::Matrix< double > const &)*arg1,*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pw_const__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_pw_const((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pw_lin__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_pw_lin((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_heaviside__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_heaviside((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rectangle__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_rectangle((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_triangle__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_triangle((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ramp__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_ramp((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gauss_quadrature__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > *arg4 = 0 ;
  casadi_int arg5 = (casadi_int) 5 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > m4 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "DM" "'.");
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_gauss_quadrature((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,(casadi::Matrix< double > const &)*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gauss_quadrature__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi::Matrix< double > *arg4 = 0 ;
  casadi_int arg5 ;
  casadi::Matrix< double > *arg6 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > m4 ;
  casadi::Matrix< double > m6 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 6) || (nobjs > 6)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_gauss_quadrature((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,(casadi::Matrix< double > const &)*arg4,arg5,(casadi::Matrix< double > const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_taylor__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > const &arg3_defvalue = 0 ;
  casadi::Matrix< double > *arg3 = (casadi::Matrix< double > *) &arg3_defvalue ;
  casadi_int arg4 = (casadi_int) 1 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_taylor((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtaylor__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi_int arg4 = (casadi_int) 1 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_mtaylor((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtaylor__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > *arg3 = 0 ;
  casadi_int arg4 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  std::vector< casadi_int > m5 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_mtaylor((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2,(casadi::Matrix< double > const &)*arg3,arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_poly_coeff__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_poly_coeff((casadi::Matrix< double > const &)*arg1,(casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_poly_roots__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_poly_roots((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_eig_symbolic__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< double > *arg1 = 0 ;
  casadi::Matrix< double > m1 ;
  casadi::Matrix< double > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "DM" "'.");
  {
    try {
      result = casadi::casadi_eig_symbolic((casadi::Matrix< double > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_logic_all__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_all((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_logic_all(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "logic_all", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_logic_all__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_logic_all__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'logic_all'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_all(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_all(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_logic_any__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_any((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_logic_any(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "logic_any", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_logic_any__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_logic_any__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'logic_any'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_any(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_any(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_adj__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_adj((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_adj(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "adj", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_adj__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_adj__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'adj'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_adj(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_adj(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_minor__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_minor((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_minor(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "minor", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_minor__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_minor__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'minor'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_minor(casadi::Matrix< double > const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_minor(casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_cofactor__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi_int arg2 ;
  casadi_int arg3 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  {
    try {
      result = casadi::casadi_cofactor((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_cofactor(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "cofactor", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_cofactor__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_cofactor__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'cofactor'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_cofactor(casadi::Matrix< double > const &,casadi_int,casadi_int)\n"
    "    casadi::casadi_cofactor(casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_qr__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  
  arg2 = &m2;
  arg3 = &m3;
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      casadi::casadi_qr((casadi::Matrix< casadi::SXElem > const &)*arg1,*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_qr(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "qr", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_qr__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_qr__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'qr'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_qr(casadi::Matrix< double > const &,casadi::Matrix< double > &,casadi::Matrix< double > &)\n"
    "    casadi::casadi_qr(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > &,casadi::Matrix< casadi::SXElem > &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_qr_sparse__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  bool arg7 = (bool) true ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  arg5 = &m5;
  arg6 = &m6;
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_qr_sparse((casadi::Matrix< casadi::SXElem > const &)*arg1,*arg2,*arg3,*arg4,*arg5,*arg6,arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg5));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg6));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_qr_sparse(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "qr_sparse", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_qr_sparse__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_qr_sparse__SWIG_0(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_qr_sparse__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_qr_sparse__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'qr_sparse'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_qr_sparse(casadi::Matrix< double > const &,casadi::Matrix< double > &,casadi::Matrix< double > &,casadi::Matrix< double > &,std::vector< casadi_int,std::allocator< casadi_int > > &,std::vector< casadi_int,std::allocator< casadi_int > > &,bool)\n"
    "    casadi::casadi_qr_sparse(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > &,casadi::Matrix< casadi::SXElem > &,casadi::Matrix< casadi::SXElem > &,std::vector< casadi_int,std::allocator< casadi_int > > &,std::vector< casadi_int,std::allocator< casadi_int > > &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_qr_solve__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg4 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  bool arg7 = (bool) false ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > m4 ;
  std::vector< casadi_int > m5 ;
  std::vector< casadi_int > m6 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 6) || (nobjs > 7)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "SX" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "int" "]" "'.");
  if (swig_obj[6]) {
    if (!casadi::to_val(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "bool" "'.");
  }
  {
    try {
      result = casadi::casadi_qr_solve((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,(casadi::Matrix< casadi::SXElem > const &)*arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5,(std::vector< long long,std::allocator< long long > > const &)*arg6,arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_qr_solve(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[8] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "qr_solve", 0, 7, argv))) SWIG_fail;
  --argc;
  if ((argc >= 6) && (argc <= 7)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<double> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                if (argc <= 6) {
                  return _wrap_qr_solve__SWIG_0(self, argc, argv);
                }
                _v = casadi::to_ptr(argv[6], static_cast< bool **>(0));
                if (_v) {
                  return _wrap_qr_solve__SWIG_0(self, argc, argv);
                }
              }
            }
          }
        }
      }
    }
  }
  if ((argc >= 6) && (argc <= 7)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<casadi_int> **>(0));
              if (_v) {
                if (argc <= 6) {
                  return _wrap_qr_solve__SWIG_1(self, argc, argv);
                }
                _v = casadi::to_ptr(argv[6], static_cast< bool **>(0));
                if (_v) {
                  return _wrap_qr_solve__SWIG_1(self, argc, argv);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'qr_solve'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_qr_solve(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n"
    "    casadi::casadi_qr_solve(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ldl__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  bool arg5 = (bool) true ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  std::vector< casadi_int > m4 ;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "bool" "'.");
  }
  {
    try {
      casadi::casadi_ldl((casadi::Matrix< casadi::SXElem > const &)*arg1,*arg2,*arg3,*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ldl(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "ldl", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_ldl__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_ldl__SWIG_0(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_ldl__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< bool **>(0));
      if (_v) {
        return _wrap_ldl__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'ldl'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_ldl(casadi::Matrix< double > const &,casadi::Matrix< double > &,casadi::Matrix< double > &,std::vector< casadi_int,std::allocator< casadi_int > > &,bool)\n"
    "    casadi::casadi_ldl(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > &,casadi::Matrix< casadi::SXElem > &,std::vector< casadi_int,std::allocator< casadi_int > > &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ldl_solve__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  std::vector< casadi_int > m4 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_ldl_solve((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ldl_solve(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "ldl_solve", 0, 4, argv))) SWIG_fail;
  --argc;
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            return _wrap_ldl_solve__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 4) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            return _wrap_ldl_solve__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'ldl_solve'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_ldl_solve(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_ldl_solve(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_chol__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_chol((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_chol(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "chol", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_chol__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_chol__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'chol'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_chol(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_chol(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_norm_inf_mul__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_norm_inf_mul((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_norm_inf_mul(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "norm_inf_mul", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_norm_inf_mul__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_norm_inf_mul__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'norm_inf_mul'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_norm_inf_mul(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_norm_inf_mul(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_sparsify__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  double arg2 = (double) 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  }
  {
    try {
      result = casadi::casadi_sparsify((casadi::Matrix< casadi::SXElem > const &)*arg1,arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_sparsify(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "sparsify", 0, 2, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_sparsify__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_sparsify__SWIG_0(self, argc, argv);
      }
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_sparsify__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_sparsify__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'sparsify'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_sparsify(casadi::Matrix< double > const &,double)\n"
    "    casadi::casadi_sparsify(casadi::Matrix< casadi::SXElem > const &,double)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_expand__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  
  arg2 = &m2;
  arg3 = &m3;
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      casadi::casadi_expand((casadi::Matrix< casadi::SXElem > const &)*arg1,*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_expand(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "expand", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_expand__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_expand__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'expand'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_expand(casadi::Matrix< double > const &,casadi::Matrix< double > &,casadi::Matrix< double > &)\n"
    "    casadi::casadi_expand(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > &,casadi::Matrix< casadi::SXElem > &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_pw_const__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_pw_const((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pw_const(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "pw_const", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          return _wrap_pw_const__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          return _wrap_pw_const__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'pw_const'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_pw_const(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_pw_const(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_pw_lin__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_pw_lin((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_pw_lin(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "pw_lin", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          return _wrap_pw_lin__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          return _wrap_pw_lin__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'pw_lin'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_pw_lin(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_pw_lin(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_heaviside__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_heaviside((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_heaviside(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "heaviside", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_heaviside__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_heaviside__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'heaviside'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_heaviside(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_heaviside(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_rectangle__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_rectangle((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_rectangle(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "rectangle", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_rectangle__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_rectangle__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'rectangle'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_rectangle(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_rectangle(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_triangle__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_triangle((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_triangle(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "triangle", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_triangle__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_triangle__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'triangle'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_triangle(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_triangle(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ramp__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_ramp((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ramp(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "ramp", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_ramp__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_ramp__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'ramp'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_ramp(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_ramp(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_gauss_quadrature__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg4 = 0 ;
  casadi_int arg5 = (casadi_int) 5 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > m4 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "SX" "'.");
  if (swig_obj[4]) {
    if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_gauss_quadrature((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,(casadi::Matrix< casadi::SXElem > const &)*arg4,arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gauss_quadrature__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg4 = 0 ;
  casadi_int arg5 ;
  casadi::Matrix< casadi::SXElem > *arg6 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > m4 ;
  casadi::Matrix< casadi::SXElem > m6 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 6) || (nobjs > 6)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_gauss_quadrature((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,(casadi::Matrix< casadi::SXElem > const &)*arg4,arg5,(casadi::Matrix< casadi::SXElem > const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_gauss_quadrature(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[7] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "gauss_quadrature", 0, 6, argv))) SWIG_fail;
  --argc;
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<double> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_gauss_quadrature__SWIG_0(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              return _wrap_gauss_quadrature__SWIG_0(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_gauss_quadrature__SWIG_2(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              return _wrap_gauss_quadrature__SWIG_2(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<double> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< casadi::Matrix<double> **>(0));
              if (_v) {
                return _wrap_gauss_quadrature__SWIG_1(self, argc, argv);
              }
            }
          }
        }
      }
    }
  }
  if (argc == 6) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
              if (_v) {
                return _wrap_gauss_quadrature__SWIG_3(self, argc, argv);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'gauss_quadrature'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_gauss_quadrature(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi_int)\n"
    "    casadi::casadi_gauss_quadrature(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi_int,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_gauss_quadrature(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int)\n"
    "    casadi::casadi_gauss_quadrature(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_taylor__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > const &arg3_defvalue = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = (casadi::Matrix< casadi::SXElem > *) &arg3_defvalue ;
  casadi_int arg4 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  }
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_taylor((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_taylor(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "taylor", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_taylor__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_taylor__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_taylor__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_taylor__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_taylor__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_taylor__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'taylor'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_taylor(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi_int)\n"
    "    casadi::casadi_taylor(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_mtaylor__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi_int arg4 = (casadi_int) 1 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::casadi_mtaylor((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtaylor__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg3 = 0 ;
  casadi_int arg4 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  std::vector< casadi_int > m5 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "int" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  {
    try {
      result = casadi::casadi_mtaylor((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,arg4,(std::vector< long long,std::allocator< long long > > const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_mtaylor(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "mtaylor", 0, 5, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_mtaylor__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_mtaylor__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_mtaylor__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            return _wrap_mtaylor__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              return _wrap_mtaylor__SWIG_1(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi_int **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<casadi_int> **>(0));
            if (_v) {
              return _wrap_mtaylor__SWIG_3(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'mtaylor'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_mtaylor(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi_int)\n"
    "    casadi::casadi_mtaylor(casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi::Matrix< double > const &,casadi_int,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::casadi_mtaylor(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int)\n"
    "    casadi::casadi_mtaylor(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &,casadi_int,std::vector< casadi_int,std::allocator< casadi_int > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_poly_coeff__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_poly_coeff((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_poly_coeff(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "poly_coeff", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_poly_coeff__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_poly_coeff__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'poly_coeff'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_poly_coeff(casadi::Matrix< double > const &,casadi::Matrix< double > const &)\n"
    "    casadi::casadi_poly_coeff(casadi::Matrix< casadi::SXElem > const &,casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_poly_roots__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_poly_roots((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_poly_roots(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "poly_roots", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_poly_roots__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_poly_roots__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'poly_roots'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_poly_roots(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_poly_roots(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_eig_symbolic__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Matrix< casadi::SXElem > *arg1 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  {
    try {
      result = casadi::casadi_eig_symbolic((casadi::Matrix< casadi::SXElem > const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_eig_symbolic(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "eig_symbolic", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<double> **>(0));
    if (_v) {
      return _wrap_eig_symbolic__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      return _wrap_eig_symbolic__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'eig_symbolic'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_eig_symbolic(casadi::Matrix< double > const &)\n"
    "    casadi::casadi_eig_symbolic(casadi::Matrix< casadi::SXElem > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_find(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_find((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_low(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "low", 2, 3, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_low((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_inv_node(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX m1 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  {
    try {
      result = casadi::casadi_inv_node((casadi::MX const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_matrix_expand__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > const &arg2_defvalue = std::vector< casadi::MX >() ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) &arg2_defvalue ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  std::vector< casadi::MX > m1 ;
  std::vector< casadi::MX > m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  }
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_matrix_expand((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_matrix_expand__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > const &arg2_defvalue = std::vector< casadi::MX >() ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) &arg2_defvalue ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::MX m1 ;
  std::vector< casadi::MX > m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::MX result;
  
  if ((nobjs < 1) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  }
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_matrix_expand((casadi::MX const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_matrix_expand(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "matrix_expand", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_matrix_expand__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_matrix_expand__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_matrix_expand__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 1) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_matrix_expand__SWIG_0(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_matrix_expand__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_matrix_expand__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'matrix_expand'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_matrix_expand(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,casadi::Dict const &)\n"
    "    casadi::casadi_matrix_expand(casadi::MX const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_graph_substitute__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  casadi::MX m1 ;
  std::vector< casadi::MX > m2 ;
  std::vector< casadi::MX > m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = casadi::casadi_graph_substitute((casadi::MX const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_graph_substitute__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  std::vector< casadi::MX > m1 ;
  std::vector< casadi::MX > m2 ;
  std::vector< casadi::MX > m3 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "MX" "]" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  {
    try {
      result = casadi::casadi_graph_substitute((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg1,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_graph_substitute(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "graph_substitute", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          return _wrap_graph_substitute__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::vector<casadi::MX> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          return _wrap_graph_substitute__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'graph_substitute'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_graph_substitute(casadi::MX const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n"
    "    casadi::casadi_graph_substitute(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_bspline__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::DM *arg2 = 0 ;
  std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  casadi_int arg5 ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  casadi::MX m1 ;
  casadi::Matrix< double > m2 ;
  std::vector< std::vector< double > > m3 ;
  std::vector< casadi_int > m4 ;
  std::map< std::string,casadi::GenericType > m6 ;
  casadi::MX result;
  
  if ((nobjs < 5) || (nobjs > 6)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "float" "]" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_bspline((casadi::MX const &)*arg1,(casadi::Matrix< double > const &)*arg2,(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,arg5,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_bspline__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *arg3 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg4 = 0 ;
  casadi_int arg5 ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  std::vector< std::vector< double > > m3 ;
  std::vector< casadi_int > m4 ;
  std::map< std::string,casadi::GenericType > m6 ;
  casadi::MX result;
  
  if ((nobjs < 5) || (nobjs > 6)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "[" "float" "]" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "int" "]" "'.");
  if (!casadi::to_val(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "int" "'.");
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_bspline((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &)*arg3,(std::vector< long long,std::allocator< long long > > const &)*arg4,arg5,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_bspline(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[7] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "bspline", 0, 6, argv))) SWIG_fail;
  --argc;
  if ((argc >= 5) && (argc <= 6)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector<double> > **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              if (argc <= 5) {
                return _wrap_bspline__SWIG_0(self, argc, argv);
              }
              _v = casadi::to_ptr(argv[5], static_cast< std::map<std::string,casadi::GenericType> **>(0));
              if (_v) {
                return _wrap_bspline__SWIG_0(self, argc, argv);
              }
            }
          }
        }
      }
    }
  }
  if ((argc >= 5) && (argc <= 6)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::vector<double> > **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi_int> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi_int **>(0));
            if (_v) {
              if (argc <= 5) {
                return _wrap_bspline__SWIG_1(self, argc, argv);
              }
              _v = casadi::to_ptr(argv[5], static_cast< std::map<std::string,casadi::GenericType> **>(0));
              if (_v) {
                return _wrap_bspline__SWIG_1(self, argc, argv);
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'bspline'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::casadi_bspline(casadi::MX const &,casadi::DM const &,std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi_int,casadi::Dict const &)\n"
    "    casadi::casadi_bspline(casadi::MX const &,casadi::MX const &,std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &,std::vector< casadi_int,std::allocator< casadi_int > > const &,casadi_int,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_convexify(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::Dict const &arg2_defvalue = casadi::Dict() ;
  casadi::Dict *arg2 = (casadi::Dict *) &arg2_defvalue ;
  casadi::MX m1 ;
  std::map< std::string,casadi::GenericType > m2 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "convexify", 1, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::casadi_convexify((casadi::MX const &)*arg1,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Importer_type_name", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::Importer::type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Importer__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::Importer *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::Importer *)new casadi::Importer();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Importer, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Importer__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  std::string m1 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  casadi::Importer *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::Importer *)new casadi::Importer((std::string const &)*arg1,(std::string const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Importer, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_test_cast(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SharedObjectInternal *arg1 = (casadi::SharedObjectInternal *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SharedObjectInternal, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_test_cast" "', argument " "1"" of type '" "casadi::SharedObjectInternal const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SharedObjectInternal * >(argp1);
  {
    try {
      result = (bool)casadi::Importer::test_cast((casadi::SharedObjectInternal const *)arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_has_plugin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (bool)casadi::Importer::has_plugin((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_load_plugin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::Importer::load_plugin((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_doc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::Importer::doc((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_plugin_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = (casadi::Importer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Importer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_plugin_name" "', argument " "1"" of type '" "casadi::Importer const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  {
    try {
      result = ((casadi::Importer const *)arg1)->plugin_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_has_function(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = (casadi::Importer *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Importer_has_function", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Importer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_has_function" "', argument " "1"" of type '" "casadi::Importer const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (bool)((casadi::Importer const *)arg1)->has_function((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_has_meta(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = (casadi::Importer *) 0 ;
  std::string *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Importer_has_meta", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Importer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_has_meta" "', argument " "1"" of type '" "casadi::Importer const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (bool)((casadi::Importer const *)arg1)->has_meta((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_get_meta(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = (casadi::Importer *) 0 ;
  std::string *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) -1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Importer_get_meta", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Importer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_get_meta" "', argument " "1"" of type '" "casadi::Importer const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = ((casadi::Importer const *)arg1)->get_meta((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_inlined(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = (casadi::Importer *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Importer_inlined", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Importer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_inlined" "', argument " "1"" of type '" "casadi::Importer const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (bool)((casadi::Importer const *)arg1)->inlined((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_body(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = (casadi::Importer *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Importer_body", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Importer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_body" "', argument " "1"" of type '" "casadi::Importer const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::Importer const *)arg1)->body((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_library(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = (casadi::Importer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Importer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_library" "', argument " "1"" of type '" "casadi::Importer const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  {
    try {
      result = ((casadi::Importer const *)arg1)->library();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_serialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = (casadi::Importer *) 0 ;
  casadi::SerializingStream *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Importer_serialize", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Importer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_serialize" "', argument " "1"" of type '" "casadi::Importer const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__SerializingStream,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Importer_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Importer_serialize" "', argument " "2"" of type '" "casadi::SerializingStream &""'"); 
  }
  arg2 = reinterpret_cast< casadi::SerializingStream * >(argp2);
  {
    try {
      ((casadi::Importer const *)arg1)->serialize(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Importer_deserialize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializingStream *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Importer result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__DeserializingStream,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Importer_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "Importer_deserialize" "', argument " "1"" of type '" "casadi::DeserializingStream &""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializingStream * >(argp1);
  {
    try {
      result = casadi::Importer::deserialize(*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::Importer(static_cast< const casadi::Importer& >(result))), SWIGTYPE_p_casadi__Importer, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Importer__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Importer *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__Importer,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Importer" "', argument " "1"" of type '" "casadi::Importer const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Importer" "', argument " "1"" of type '" "casadi::Importer const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  {
    result = (casadi::Importer *)new casadi::Importer((casadi::Importer const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Importer, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Importer(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Importer", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_Importer__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__Importer, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Importer__SWIG_2(self, argc, argv);
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_new_Importer__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_new_Importer__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Importer'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Importer::Importer()\n"
    "    casadi::Importer::Importer(std::string const &,std::string const &,casadi::Dict const &)\n"
    "    casadi::Importer::Importer(casadi::Importer const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Importer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Importer *arg1 = (casadi::Importer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Importer, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Importer" "', argument " "1"" of type '" "casadi::Importer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Importer * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Importer_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__Importer, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Importer_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_Callback_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_type_name", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::Callback::type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Callback__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  casadi::Callback *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = swig_obj[0];
  {
    try {
      if ( arg1 != Py_None ) {
        /* subclassed */
        result = (casadi::Callback *)new SwigDirector_Callback(arg1); 
      } else {
        result = (casadi::Callback *)new casadi::Callback(); 
      }
      
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Callback, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Callback__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  casadi::Callback *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  casadi::Callback *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = swig_obj[0];
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__Callback,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_Callback" "', argument " "2"" of type '" "casadi::Callback const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Callback" "', argument " "2"" of type '" "casadi::Callback const &""'"); 
  }
  arg2 = reinterpret_cast< casadi::Callback * >(argp2);
  {
    try {
      if ( arg1 != Py_None ) {
        /* subclassed */
        result = (casadi::Callback *)new SwigDirector_Callback(arg1,(casadi::Callback const &)*arg2); 
      } else {
        result = (casadi::Callback *)new casadi::Callback((casadi::Callback const &)*arg2); 
      }
      
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Callback, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Callback(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Callback", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      return _wrap_new_Callback__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_casadi__Callback, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_Callback__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Callback'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Callback::Callback()\n"
    "    casadi::Callback::Callback(PyObject *,casadi::Callback const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Callback" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_construct(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_construct", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_construct" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      (arg1)->construct((std::string const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_init(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_init" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          (arg1)->casadi::Callback::init();
        } else {
          (arg1)->init();
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_finalize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_finalize" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          (arg1)->casadi::Callback::finalize();
        } else {
          (arg1)->finalize();
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_eval(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< double > > m2 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  std::vector< casadi::DM,std::allocator< casadi::DM > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_eval", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_eval" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = ((casadi::Callback const *)arg1)->casadi::Callback::eval((std::vector< casadi::DM,std::allocator< casadi::DM > > const &)*arg2);
        } else {
          result = ((casadi::Callback const *)arg1)->eval((std::vector< casadi::DM,std::allocator< casadi::DM > > const &)*arg2);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_eval_buffer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  double **arg2 = (double **) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg3 = 0 ;
  double **arg4 = (double **) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  std::vector< casadi_int > m3 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  std::vector< casadi_int > m5 ;
  PyObject *swig_obj[5] ;
  Swig::Director *director = 0;
  bool upcall = false;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_eval_buffer", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_eval_buffer" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Callback_eval_buffer" "', argument " "2"" of type '" "double const **""'"); 
  }
  arg2 = reinterpret_cast< double ** >(argp2);
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "int" "]" "'.");
  res4 = SWIG_ConvertPtr(swig_obj[3], &argp4,SWIGTYPE_p_p_double, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "Callback_eval_buffer" "', argument " "4"" of type '" "double **""'"); 
  }
  arg4 = reinterpret_cast< double ** >(argp4);
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "int" "]" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (int)((casadi::Callback const *)arg1)->casadi::Callback::eval_buffer((double const **)arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,arg4,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg5);
        } else {
          result = (int)((casadi::Callback const *)arg1)->eval_buffer((double const **)arg2,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg3,arg4,(std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg5);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_has_eval_buffer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_has_eval_buffer" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (bool)((casadi::Callback const *)arg1)->casadi::Callback::has_eval_buffer();
        } else {
          result = (bool)((casadi::Callback const *)arg1)->has_eval_buffer();
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_n_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_n_in" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (casadi_int)(arg1)->casadi::Callback::get_n_in();
        } else {
          result = (casadi_int)(arg1)->get_n_in();
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_n_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_n_out" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (casadi_int)(arg1)->casadi::Callback::get_n_out();
        } else {
          result = (casadi_int)(arg1)->get_n_out();
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_sparsity_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_get_sparsity_in", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_sparsity_in" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (arg1)->casadi::Callback::get_sparsity_in(arg2);
        } else {
          result = (arg1)->get_sparsity_in(arg2);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_sparsity_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  casadi::Sparsity result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_get_sparsity_out", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_sparsity_out" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (arg1)->casadi::Callback::get_sparsity_out(arg2);
        } else {
          result = (arg1)->get_sparsity_out(arg2);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_name_in(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_get_name_in", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_name_in" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (arg1)->casadi::Callback::get_name_in(arg2);
        } else {
          result = (arg1)->get_name_in(arg2);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_name_out(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_get_name_out", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_name_out" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (arg1)->casadi::Callback::get_name_out(arg2);
        } else {
          result = (arg1)->get_name_out(arg2);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_uses_output(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_uses_output" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (bool)((casadi::Callback const *)arg1)->casadi::Callback::uses_output();
        } else {
          result = (bool)((casadi::Callback const *)arg1)->uses_output();
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_has_jacobian(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_has_jacobian" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (bool)((casadi::Callback const *)arg1)->casadi::Callback::has_jacobian();
        } else {
          result = (bool)((casadi::Callback const *)arg1)->has_jacobian();
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_jacobian(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  casadi::Dict *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< std::string > m3 ;
  std::vector< std::string > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  PyObject *swig_obj[5] ;
  Swig::Director *director = 0;
  bool upcall = false;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_get_jacobian", 5, 5, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_jacobian" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = ((casadi::Callback const *)arg1)->casadi::Callback::get_jacobian((std::string const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(casadi::Dict const &)*arg5);
        } else {
          result = ((casadi::Callback const *)arg1)->get_jacobian((std::string const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(casadi::Dict const &)*arg5);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_has_forward(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_has_forward", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_has_forward" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (bool)((casadi::Callback const *)arg1)->casadi::Callback::has_forward(arg2);
        } else {
          result = (bool)((casadi::Callback const *)arg1)->has_forward(arg2);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_forward(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  casadi_int arg2 ;
  std::string *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
  casadi::Dict *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m3 ;
  std::vector< std::string > m4 ;
  std::vector< std::string > m5 ;
  std::map< std::string,casadi::GenericType > m6 ;
  PyObject *swig_obj[6] ;
  Swig::Director *director = 0;
  bool upcall = false;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_get_forward", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_forward" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "str" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = ((casadi::Callback const *)arg1)->casadi::Callback::get_forward(arg2,(std::string const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(casadi::Dict const &)*arg6);
        } else {
          result = ((casadi::Callback const *)arg1)->get_forward(arg2,(std::string const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(casadi::Dict const &)*arg6);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_has_reverse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_has_reverse", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_has_reverse" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (bool)((casadi::Callback const *)arg1)->casadi::Callback::has_reverse(arg2);
        } else {
          result = (bool)((casadi::Callback const *)arg1)->has_reverse(arg2);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_reverse(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  casadi_int arg2 ;
  std::string *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
  casadi::Dict *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m3 ;
  std::vector< std::string > m4 ;
  std::vector< std::string > m5 ;
  std::map< std::string,casadi::GenericType > m6 ;
  PyObject *swig_obj[6] ;
  Swig::Director *director = 0;
  bool upcall = false;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "Callback_get_reverse", 6, 6, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_reverse" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "str" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = ((casadi::Callback const *)arg1)->casadi::Callback::get_reverse(arg2,(std::string const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(casadi::Dict const &)*arg6);
        } else {
          result = ((casadi::Callback const *)arg1)->get_reverse(arg2,(std::string const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(casadi::Dict const &)*arg6);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_has_jacobian_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_has_jacobian_sparsity" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = (bool)((casadi::Callback const *)arg1)->casadi::Callback::has_jacobian_sparsity();
        } else {
          result = (bool)((casadi::Callback const *)arg1)->has_jacobian_sparsity();
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Callback_get_jacobian_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Swig::Director *director = 0;
  bool upcall = false;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Callback_get_jacobian_sparsity" "', argument " "1"" of type '" "casadi::Callback const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          result = ((casadi::Callback const *)arg1)->casadi::Callback::get_jacobian_sparsity();
        } else {
          result = ((casadi::Callback const *)arg1)->get_jacobian_sparsity();
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_disown_Callback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Callback *arg1 = (casadi::Callback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Callback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disown_Callback" "', argument " "1"" of type '" "casadi::Callback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Callback * >(argp1);
  {
    Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
    if (director) director->swig_disown();
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Callback_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__Callback, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Callback_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_GlobalOptions_setSimplificationOnTheFly(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "bool" "'.");
  {
    try {
      casadi::GlobalOptions::setSimplificationOnTheFly(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalOptions_getSimplificationOnTheFly(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "GlobalOptions_getSimplificationOnTheFly", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (bool)casadi::GlobalOptions::getSimplificationOnTheFly();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalOptions_setHierarchicalSparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "bool" "'.");
  {
    try {
      casadi::GlobalOptions::setHierarchicalSparsity(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalOptions_getHierarchicalSparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "GlobalOptions_getHierarchicalSparsity", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (bool)casadi::GlobalOptions::getHierarchicalSparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalOptions_setCasadiPath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::GlobalOptions::setCasadiPath((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalOptions_getCasadiPath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "GlobalOptions_getCasadiPath", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::GlobalOptions::getCasadiPath();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalOptions_setCasadiIncludePath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::GlobalOptions::setCasadiIncludePath((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalOptions_getCasadiIncludePath(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "GlobalOptions_getCasadiIncludePath", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::GlobalOptions::getCasadiIncludePath();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalOptions_setMaxNumDir(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  {
    try {
      casadi::GlobalOptions::setMaxNumDir(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_GlobalOptions_getMaxNumDir(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int result;
  
  if (!SWIG_Python_UnpackTuple(args, "GlobalOptions_getMaxNumDir", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (casadi_int)casadi::GlobalOptions::getMaxNumDir();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_GlobalOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GlobalOptions *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::GlobalOptions *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__GlobalOptions,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_GlobalOptions" "', argument " "1"" of type '" "casadi::GlobalOptions const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_GlobalOptions" "', argument " "1"" of type '" "casadi::GlobalOptions const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::GlobalOptions * >(argp1);
  {
    result = (casadi::GlobalOptions *)new casadi::GlobalOptions((casadi::GlobalOptions const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__GlobalOptions, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_GlobalOptions(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::GlobalOptions *arg1 = (casadi::GlobalOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__GlobalOptions, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_GlobalOptions" "', argument " "1"" of type '" "casadi::GlobalOptions *""'"); 
  }
  arg1 = reinterpret_cast< casadi::GlobalOptions * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *GlobalOptions_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__GlobalOptions, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *GlobalOptions_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_CasadiMeta_version(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_version", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::version();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_git_revision(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_git_revision", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::git_revision();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_git_describe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_git_describe", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::git_describe();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_feature_list(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_feature_list", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::feature_list();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_build_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_build_type", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::build_type();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_compiler_id(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_compiler_id", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::compiler_id();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_compiler(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_compiler", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::compiler();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_compiler_flags(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_compiler_flags", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::compiler_flags();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_modules(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_modules", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::modules();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_plugins(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_plugins", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::plugins();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CasadiMeta_install_prefix(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  char *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "CasadiMeta_install_prefix", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = (char *)casadi::CasadiMeta::install_prefix();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_FromCharPtr((const char *)result);
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_CasadiMeta(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::CasadiMeta *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::CasadiMeta *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__CasadiMeta,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_CasadiMeta" "', argument " "1"" of type '" "casadi::CasadiMeta const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_CasadiMeta" "', argument " "1"" of type '" "casadi::CasadiMeta const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::CasadiMeta * >(argp1);
  {
    result = (casadi::CasadiMeta *)new casadi::CasadiMeta((casadi::CasadiMeta const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__CasadiMeta, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CasadiMeta(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::CasadiMeta *arg1 = (casadi::CasadiMeta *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__CasadiMeta, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CasadiMeta" "', argument " "1"" of type '" "casadi::CasadiMeta *""'"); 
  }
  arg1 = reinterpret_cast< casadi::CasadiMeta * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *CasadiMeta_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__CasadiMeta, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *CasadiMeta_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_collocation_points(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi_int arg1 ;
  std::string const &arg2_defvalue = "radau" ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  std::vector< double,std::allocator< double > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "collocation_points", 1, 2, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "int" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  {
    try {
      result = casadi::collocation_points(arg1,(std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_collocation_interpolators(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< double,std::allocator< double > > *arg1 = 0 ;
  std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  std::vector< double > m1 ;
  std::vector< std::vector< double > > m2 ;
  std::vector< double > m3 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &m2;
  arg3 = &m3;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "float" "]" "'.");
  {
    try {
      casadi::collocation_interpolators((std::vector< double,std::allocator< double > > const &)*arg1,*arg2,*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_collocation_coeff(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::vector< double,std::allocator< double > > *arg1 = 0 ;
  casadi::DM *arg2 = 0 ;
  casadi::DM *arg3 = 0 ;
  casadi::DM *arg4 = 0 ;
  std::vector< double > m1 ;
  casadi::Matrix< double > m2 ;
  casadi::Matrix< double > m3 ;
  casadi::Matrix< double > m4 ;
  PyObject *swig_obj[1] ;
  
  arg2 = &m2;
  arg3 = &m3;
  arg4 = &m4;
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "[" "float" "]" "'.");
  {
    try {
      casadi::collocation_coeff((std::vector< double,std::allocator< double > > const &)*arg1,*arg2,*arg3,*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg2));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg3));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg4));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_simpleRK(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function arg1 ;
  casadi_int arg2 = (casadi_int) 10 ;
  casadi_int arg3 = (casadi_int) 4 ;
  PyObject *swig_obj[3] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "simpleRK", 1, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = casadi::simpleRK(arg1,arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_simpleIRK(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function arg1 ;
  casadi_int arg2 = (casadi_int) 10 ;
  casadi_int arg3 = (casadi_int) 4 ;
  std::string const &arg4_defvalue = "radau" ;
  std::string *arg4 = (std::string *) &arg4_defvalue ;
  std::string const &arg5_defvalue = "newton" ;
  std::string *arg5 = (std::string *) &arg5_defvalue ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  std::string m4 ;
  std::string m5 ;
  std::map< std::string,casadi::GenericType > m6 ;
  PyObject *swig_obj[6] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "simpleIRK", 1, 6, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "str" "'.");
  }
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "str" "'.");
  }
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::simpleIRK(arg1,arg2,arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_simpleIntegrator(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Function arg1 ;
  std::string const &arg2_defvalue = "cvodes" ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  PyObject *swig_obj[3] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "simpleIntegrator", 1, 3, swig_obj)) SWIG_fail;
  if (!casadi::to_val(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "Function" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      result = casadi::simpleIntegrator(arg1,(std::string const &)*arg2,(std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_detect_simple_bounds__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SX *arg1 = 0 ;
  casadi::SX *arg2 = 0 ;
  casadi::SX *arg3 = 0 ;
  casadi::SX *arg4 = 0 ;
  casadi::SX *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  casadi::SX *arg7 = 0 ;
  casadi::SX *arg8 = 0 ;
  casadi::Function *arg9 = 0 ;
  casadi::Function *arg10 = 0 ;
  casadi::Matrix< casadi::SXElem > m1 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  casadi::Matrix< casadi::SXElem > m3 ;
  casadi::Matrix< casadi::SXElem > m4 ;
  casadi::Matrix< casadi::SXElem > m5 ;
  std::vector< casadi_int > m6 ;
  casadi::Matrix< casadi::SXElem > m7 ;
  casadi::Matrix< casadi::SXElem > m8 ;
  casadi::Function m9 ;
  casadi::Function m10 ;
  
  arg6 = &m6;
  arg7 = &m7;
  arg8 = &m8;
  arg9 = &m9;
  arg10 = &m10;
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "SX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "SX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "SX" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "SX" "'.");
  {
    try {
      casadi::detect_simple_bounds((casadi::Matrix< casadi::SXElem > const &)*arg1,(casadi::Matrix< casadi::SXElem > const &)*arg2,(casadi::Matrix< casadi::SXElem > const &)*arg3,(casadi::Matrix< casadi::SXElem > const &)*arg4,(casadi::Matrix< casadi::SXElem > const &)*arg5,*arg6,*arg7,*arg8,*arg9,*arg10);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg6));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg7));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg8));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg9));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg10));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_detect_simple_bounds__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX *arg4 = 0 ;
  casadi::MX *arg5 = 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg6 = 0 ;
  casadi::MX *arg7 = 0 ;
  casadi::MX *arg8 = 0 ;
  casadi::Function *arg9 = 0 ;
  casadi::Function *arg10 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  casadi::MX m4 ;
  casadi::MX m5 ;
  std::vector< casadi_int > m6 ;
  casadi::MX m7 ;
  casadi::MX m8 ;
  casadi::Function m9 ;
  casadi::Function m10 ;
  
  arg6 = &m6;
  arg7 = &m7;
  arg8 = &m8;
  arg9 = &m9;
  arg10 = &m10;
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "MX" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "MX" "'.");
  {
    try {
      casadi::detect_simple_bounds((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3,(casadi::MX const &)*arg4,(casadi::MX const &)*arg5,*arg6,*arg7,*arg8,*arg9,*arg10);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg6));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg7));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg8));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg9));
  resultobj = SWIG_Python_AppendOutput(resultobj, casadi::from_ptr(arg10));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_detect_simple_bounds(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "detect_simple_bounds", 0, 5, argv))) SWIG_fail;
  --argc;
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
            if (_v) {
              return _wrap_detect_simple_bounds__SWIG_0(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if (argc == 5) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< casadi::MX **>(0));
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::MX **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< casadi::MX **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< casadi::MX **>(0));
            if (_v) {
              return _wrap_detect_simple_bounds__SWIG_1(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'detect_simple_bounds'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::detect_simple_bounds(casadi::SX const &,casadi::SX const &,casadi::SX const &,casadi::SX const &,casadi::SX const &,std::vector< casadi_int,std::allocator< casadi_int > > &,casadi::SX &,casadi::SX &,casadi::Function &,casadi::Function &)\n"
    "    casadi::detect_simple_bounds(casadi::MX const &,casadi::MX const &,casadi::MX const &,casadi::MX const &,casadi::MX const &,std::vector< casadi_int,std::allocator< casadi_int > > &,casadi::MX &,casadi::MX &,casadi::Function &,casadi::Function &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_x_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_x_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->x);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_f_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_f_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (casadi::MX *) & ((arg1)->f);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_g_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_g_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->g);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_x_lb_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_x_lb_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (std::vector< double,std::allocator< double > > *) & ((arg1)->x_lb);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_x_ub_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_x_ub_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (std::vector< double,std::allocator< double > > *) & ((arg1)->x_ub);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_g_lb_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_g_lb_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (std::vector< double,std::allocator< double > > *) & ((arg1)->g_lb);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_g_ub_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_g_ub_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (std::vector< double,std::allocator< double > > *) & ((arg1)->g_ub);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_x_init_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_x_init_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (std::vector< double,std::allocator< double > > *) & ((arg1)->x_init);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_lambda_init_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_lambda_init_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (std::vector< double,std::allocator< double > > *) & ((arg1)->lambda_init);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_discrete_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< bool,std::allocator< bool > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_discrete_get" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  result = (std::vector< bool,std::allocator< bool > > *) & ((arg1)->discrete);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "bool" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_import_nl(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "NlpBuilder_import_nl", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_import_nl" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  {
    try {
      (arg1)->import_nl((std::string const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_type_name" "', argument " "1"" of type '" "casadi::NlpBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  {
    try {
      result = ((casadi::NlpBuilder const *)arg1)->type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "NlpBuilder_disp", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_disp" "', argument " "1"" of type '" "casadi::NlpBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::NlpBuilder const *)arg1)->disp(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_NlpBuilder_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "NlpBuilder_str", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NlpBuilder_str" "', argument " "1"" of type '" "casadi::NlpBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::NlpBuilder const *)arg1)->get_str(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NlpBuilder__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::NlpBuilder *)new casadi::NlpBuilder();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__NlpBuilder, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NlpBuilder__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::NlpBuilder *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__NlpBuilder,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_NlpBuilder" "', argument " "1"" of type '" "casadi::NlpBuilder const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_NlpBuilder" "', argument " "1"" of type '" "casadi::NlpBuilder const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  {
    result = (casadi::NlpBuilder *)new casadi::NlpBuilder((casadi::NlpBuilder const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__NlpBuilder, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_NlpBuilder(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_NlpBuilder", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_NlpBuilder__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__NlpBuilder, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_NlpBuilder__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_NlpBuilder'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::NlpBuilder::NlpBuilder()\n"
    "    casadi::NlpBuilder::NlpBuilder(casadi::NlpBuilder const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_NlpBuilder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::NlpBuilder *arg1 = (casadi::NlpBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__NlpBuilder, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_NlpBuilder" "', argument " "1"" of type '" "casadi::NlpBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::NlpBuilder * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *NlpBuilder_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__NlpBuilder, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *NlpBuilder_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Variable__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::Variable *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::Variable *)new casadi::Variable();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Variable, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Variable__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Sparsity const &arg2_defvalue = casadi::Sparsity::scalar() ;
  casadi::Sparsity *arg2 = (casadi::Sparsity *) &arg2_defvalue ;
  std::string m1 ;
  casadi::Sparsity m2 ;
  casadi::Variable *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 2)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  }
  {
    try {
      result = (casadi::Variable *)new casadi::Variable((std::string const &)*arg1,(casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Variable, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_name" "', argument " "1"" of type '" "casadi::Variable const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  {
    try {
      result = ((casadi::Variable const *)arg1)->name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_v_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_v_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (casadi::MX *) & ((arg1)->v);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_d_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_d_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (casadi::MX *) & ((arg1)->d);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_nominal_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_nominal_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (double) ((arg1)->nominal);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_start_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_start_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (double) ((arg1)->start);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_min_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_min_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (double) ((arg1)->min);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_max_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_max_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (double) ((arg1)->max);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_guess_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_guess_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (double) ((arg1)->guess);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_derivative_start_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_derivative_start_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (double) ((arg1)->derivative_start);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_variability_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Variability result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_variability_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (casadi::Variability) ((arg1)->variability);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_causality_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Causality result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_causality_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (casadi::Causality) ((arg1)->causality);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_category_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Category result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_category_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (casadi::Category) ((arg1)->category);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_alias_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Alias result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_alias_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (casadi::Alias) ((arg1)->alias);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_description_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_description_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (std::string *) & ((arg1)->description);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_valueReference_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_valueReference_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (casadi_int) ((arg1)->valueReference);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_unit_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_unit_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (std::string *) & ((arg1)->unit);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_display_unit_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_display_unit_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (std::string *) & ((arg1)->display_unit);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_free_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_free_get" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  result = (bool) ((arg1)->free);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_type_name" "', argument " "1"" of type '" "casadi::Variable const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  {
    try {
      result = ((casadi::Variable const *)arg1)->type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "Variable_disp", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_disp" "', argument " "1"" of type '" "casadi::Variable const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Variable const *)arg1)->disp(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Variable_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Variable_str", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Variable_str" "', argument " "1"" of type '" "casadi::Variable const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Variable const *)arg1)->get_str(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Variable__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Variable *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__Variable,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Variable" "', argument " "1"" of type '" "casadi::Variable const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Variable" "', argument " "1"" of type '" "casadi::Variable const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  {
    result = (casadi::Variable *)new casadi::Variable((casadi::Variable const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Variable, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Variable(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Variable", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_Variable__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__Variable, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Variable__SWIG_2(self, argc, argv);
    }
  }
  if ((argc >= 1) && (argc <= 2)) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      if (argc <= 1) {
        return _wrap_new_Variable__SWIG_1(self, argc, argv);
      }
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_new_Variable__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Variable'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Variable::Variable()\n"
    "    casadi::Variable::Variable(std::string const &,casadi::Sparsity const &)\n"
    "    casadi::Variable::Variable(casadi::Variable const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Variable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Variable *arg1 = (casadi::Variable *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Variable, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Variable" "', argument " "1"" of type '" "casadi::Variable *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Variable * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Variable_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__Variable, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Variable_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_DaeBuilder__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::DaeBuilder *)new casadi::DaeBuilder();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__DaeBuilder, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_t_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_t_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (casadi::MX *) & ((arg1)->t);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_x_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_x_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->x);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_ode_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_ode_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->ode);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_lam_ode_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_lam_ode_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->lam_ode);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_s_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_s_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->s);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_sdot_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_sdot_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->sdot);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_dae_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_dae_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->dae);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_lam_dae_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_lam_dae_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->lam_dae);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_z_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_z_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->z);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_alg_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_alg_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->alg);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_lam_alg_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_lam_alg_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->lam_alg);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_q_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_q_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->q);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_quad_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_quad_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->quad);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_lam_quad_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_lam_quad_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->lam_quad);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_w_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_w_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->w);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_wdef_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_wdef_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->wdef);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_lam_wdef_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_lam_wdef_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->lam_wdef);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_y_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_y_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->y);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_ydef_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_ydef_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->ydef);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_lam_ydef_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_lam_ydef_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->lam_ydef);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_u_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_u_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->u);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_p_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_p_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->p);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_c_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_c_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->c);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_cdef_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_cdef_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->cdef);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_d_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_d_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->d);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_ddef_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_ddef_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->ddef);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_lam_ddef_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_lam_ddef_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->lam_ddef);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_aux_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_aux_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->aux);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_init_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_init_get" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  result = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) & ((arg1)->init);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_p(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string const &arg2_defvalue = std::string() ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  casadi_int arg3 = (casadi_int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_p", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_p" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (arg1)->add_p((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_u(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string const &arg2_defvalue = std::string() ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  casadi_int arg3 = (casadi_int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_u", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_u" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (arg1)->add_u((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_x(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string const &arg2_defvalue = std::string() ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  casadi_int arg3 = (casadi_int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_x", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_x" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (arg1)->add_x((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_s(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string const &arg2_defvalue = std::string() ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  casadi_int arg3 = (casadi_int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  std::pair< casadi::MX,casadi::MX > result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_s", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_s" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (arg1)->add_s((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "(" "MX" "," "MX" ")" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_z(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string const &arg2_defvalue = std::string() ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  casadi_int arg3 = (casadi_int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_z", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_z" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (arg1)->add_z((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_q(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string const &arg2_defvalue = std::string() ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  casadi_int arg3 = (casadi_int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_q", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_q" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (arg1)->add_q((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_d(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX m3 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_d", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_d" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      result = (arg1)->add_d((std::string const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_y(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX m3 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_y", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_y" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      result = (arg1)->add_y((std::string const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_ode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_ode", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_ode" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      (arg1)->add_ode((std::string const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_dae(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_dae", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_dae" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      (arg1)->add_dae((std::string const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_alg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_alg", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_alg" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      (arg1)->add_alg((std::string const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_quad(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_quad", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_quad" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      (arg1)->add_quad((std::string const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_aux(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string const &arg2_defvalue = std::string() ;
  std::string *arg2 = (std::string *) &arg2_defvalue ;
  casadi_int arg3 = (casadi_int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_aux", 1, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_aux" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (arg1)->add_aux((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_sanity_check(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_sanity_check" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      ((casadi::DaeBuilder const *)arg1)->sanity_check();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_split_dae(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_split_dae" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->split_dae();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_eliminate_alg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_eliminate_alg" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->eliminate_alg();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_make_semi_explicit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_make_semi_explicit" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->make_semi_explicit();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_make_explicit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_make_explicit" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->make_explicit();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_sort_d(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_sort_d" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->sort_d();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_split_d(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_split_d" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->split_d();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_eliminate_d(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_eliminate_d" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->eliminate_d();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_eliminate_quad(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_eliminate_quad" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->eliminate_quad();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_sort_dae(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_sort_dae" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->sort_dae();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_sort_alg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_sort_alg" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->sort_alg();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_scale_variables(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_scale_variables" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->scale_variables();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_scale_equations(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_scale_equations" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      (arg1)->scale_equations();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_fun__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< std::string > m3 ;
  std::vector< std::string > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function result;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_fun" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = (arg1)->add_fun((std::string const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(casadi::Dict const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_fun__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::Function *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Function m2 ;
  casadi::Function result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_fun" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Function" "'.");
  {
    try {
      result = (arg1)->add_fun((casadi::Function const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_fun__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Importer *arg3 = 0 ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  std::map< std::string,casadi::GenericType > m4 ;
  casadi::Function result;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_fun" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_casadi__Importer,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DaeBuilder_add_fun" "', argument " "3"" of type '" "casadi::Importer const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DaeBuilder_add_fun" "', argument " "3"" of type '" "casadi::Importer const &""'"); 
  }
  arg3 = reinterpret_cast< casadi::Importer * >(argp3);
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      result = (arg1)->add_fun((std::string const &)*arg2,(casadi::Importer const &)*arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_fun(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_add_fun", 0, 5, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Function **>(0));
      if (_v) {
        return _wrap_DaeBuilder_add_fun__SWIG_1(self, argc, argv);
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_casadi__Importer, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_add_fun__SWIG_2(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< std::map<std::string,casadi::GenericType> **>(0));
          if (_v) {
            return _wrap_DaeBuilder_add_fun__SWIG_2(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<std::string> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<std::string> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_DaeBuilder_add_fun__SWIG_0(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_DaeBuilder_add_fun__SWIG_0(self, argc, argv);
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_add_fun'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::add_fun(std::string const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &)\n"
    "    casadi::DaeBuilder::add_fun(casadi::Function const &)\n"
    "    casadi::DaeBuilder::add_fun(std::string const &,casadi::Importer const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_has_fun(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_has_fun", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_has_fun" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (bool)((casadi::DaeBuilder const *)arg1)->has_fun((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_fun(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_fun", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_fun" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->fun((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_parse_fmi(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_parse_fmi", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_parse_fmi" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      (arg1)->parse_fmi((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_lc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< std::string > m3 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_add_lc", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_lc" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  {
    try {
      result = (arg1)->add_lc((std::string const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_create(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< std::string > m3 ;
  std::vector< std::string > m4 ;
  PyObject *swig_obj[4] ;
  casadi::Function result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_create", 4, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_create" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "str" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->create((std::string const &)*arg2,(std::vector< std::string,std::allocator< std::string > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_var(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_var", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_var" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->var((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder___call__(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder___call__", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder___call__" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->operator ()((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_der__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_der" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->der((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_der__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_der" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->der((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_der(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_der", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_DaeBuilder_der__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_DaeBuilder_der__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_der'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::der(std::string const &) const\n"
    "    casadi::DaeBuilder::der(casadi::MX const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_nominal__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_nominal" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (double)((casadi::DaeBuilder const *)arg1)->nominal((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_nominal__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double,std::allocator< double > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_nominal" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->nominal((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_nominal(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_nominal", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_DaeBuilder_nominal__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_DaeBuilder_nominal__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_nominal'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::nominal(std::string const &) const\n"
    "    casadi::DaeBuilder::nominal(casadi::MX const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_nominal__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_nominal" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "float" "'.");
  {
    try {
      (arg1)->set_nominal((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_nominal__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double > m3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_nominal" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  {
    try {
      (arg1)->set_nominal((casadi::MX const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_nominal(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_set_nominal", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<double> **>(0));
        if (_v) {
          return _wrap_DaeBuilder_set_nominal__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< double **>(0));
        if (_v) {
          return _wrap_DaeBuilder_set_nominal__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_set_nominal'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::set_nominal(std::string const &,double)\n"
    "    casadi::DaeBuilder::set_nominal(casadi::MX const &,std::vector< double,std::allocator< double > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_min__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_min" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = (double)((casadi::DaeBuilder const *)arg1)->min((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_min__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double,std::allocator< double > > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_min" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->min((casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_min(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_min", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_min__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_min__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_min__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_min__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_min'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::min(std::string const &,bool) const\n"
    "    casadi::DaeBuilder::min(casadi::MX const &,bool) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_min__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  double arg3 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_min" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "float" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_min((std::string const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_min__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_min" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_min((casadi::MX const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_min(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_set_min", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_min__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_min__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< double **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_min__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_min__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_set_min'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::set_min(std::string const &,double,bool)\n"
    "    casadi::DaeBuilder::set_min(casadi::MX const &,std::vector< double,std::allocator< double > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_max__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_max" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = (double)((casadi::DaeBuilder const *)arg1)->max((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_max__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double,std::allocator< double > > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_max" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->max((casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_max(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_max", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_max__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_max__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_max__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_max__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_max'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::max(std::string const &,bool) const\n"
    "    casadi::DaeBuilder::max(casadi::MX const &,bool) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_max__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  double arg3 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_max" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "float" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_max((std::string const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_max__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_max" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_max((casadi::MX const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_max(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_set_max", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_max__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_max__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< double **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_max__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_max__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_set_max'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::set_max(std::string const &,double,bool)\n"
    "    casadi::DaeBuilder::set_max(casadi::MX const &,std::vector< double,std::allocator< double > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_guess__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_guess" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = (double)((casadi::DaeBuilder const *)arg1)->guess((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_guess__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double,std::allocator< double > > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_guess" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->guess((casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_guess(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_guess", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_guess__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_guess__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_guess__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_guess__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_guess'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::guess(std::string const &,bool) const\n"
    "    casadi::DaeBuilder::guess(casadi::MX const &,bool) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_guess__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  double arg3 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_guess" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "float" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_guess((std::string const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_guess__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_guess" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_guess((casadi::MX const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_guess(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_set_guess", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_guess__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_guess__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< double **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_guess__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_guess__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_set_guess'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::set_guess(std::string const &,double,bool)\n"
    "    casadi::DaeBuilder::set_guess(casadi::MX const &,std::vector< double,std::allocator< double > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_start__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_start" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = (double)((casadi::DaeBuilder const *)arg1)->start((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_start__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double,std::allocator< double > > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_start" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->start((casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_start(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_start", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_start__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_start__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_start__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_start__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_start'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::start(std::string const &,bool) const\n"
    "    casadi::DaeBuilder::start(casadi::MX const &,bool) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_start__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  double arg3 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_start" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "float" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_start((std::string const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_start__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_start" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_start((casadi::MX const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_start(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_set_start", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_start__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_start__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< double **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_start__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_start__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_set_start'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::set_start(std::string const &,double,bool)\n"
    "    casadi::DaeBuilder::set_start(casadi::MX const &,std::vector< double,std::allocator< double > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_derivative_start__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  double result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_derivative_start" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = (double)((casadi::DaeBuilder const *)arg1)->derivative_start((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_derivative_start__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double,std::allocator< double > > result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_derivative_start" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->derivative_start((casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_derivative_start(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_derivative_start", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_derivative_start__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_derivative_start__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_derivative_start__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< bool **>(0));
        if (_v) {
          return _wrap_DaeBuilder_derivative_start__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_derivative_start'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::derivative_start(std::string const &,bool) const\n"
    "    casadi::DaeBuilder::derivative_start(casadi::MX const &,bool) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_derivative_start__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  double arg3 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_derivative_start" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "float" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_derivative_start((std::string const &)*arg2,arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_derivative_start__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< double,std::allocator< double > > *arg3 = 0 ;
  bool arg4 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< double > m3 ;
  
  if ((nobjs < 3) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_derivative_start" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "float" "]" "'.");
  if (swig_obj[3]) {
    if (!casadi::to_val(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->set_derivative_start((casadi::MX const &)*arg2,(std::vector< double,std::allocator< double > > const &)*arg3,arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_derivative_start(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_set_derivative_start", 0, 4, argv))) SWIG_fail;
  --argc;
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<double> **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_derivative_start__SWIG_1(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_derivative_start__SWIG_1(self, argc, argv);
          }
        }
      }
    }
  }
  if ((argc >= 3) && (argc <= 4)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< double **>(0));
        if (_v) {
          if (argc <= 3) {
            return _wrap_DaeBuilder_set_derivative_start__SWIG_0(self, argc, argv);
          }
          _v = casadi::to_ptr(argv[3], static_cast< bool **>(0));
          if (_v) {
            return _wrap_DaeBuilder_set_derivative_start__SWIG_0(self, argc, argv);
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_set_derivative_start'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::set_derivative_start(std::string const &,double,bool)\n"
    "    casadi::DaeBuilder::set_derivative_start(casadi::MX const &,std::vector< double,std::allocator< double > > const &,bool)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_unit__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_unit" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->unit((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_unit__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::string result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_unit" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->unit((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_unit(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_unit", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_DaeBuilder_unit__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_DaeBuilder_unit__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_unit'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::unit(std::string const &) const\n"
    "    casadi::DaeBuilder::unit(casadi::MX const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_set_unit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::string m3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_set_unit", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_set_unit" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "str" "'.");
  {
    try {
      (arg1)->set_unit((std::string const &)*arg2,(std::string const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_type_name" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_disp", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_disp" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::DaeBuilder const *)arg1)->disp(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "DaeBuilder_str", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_str" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::DaeBuilder const *)arg1)->get_str(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_variable__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Variable *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_variable" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_casadi__Variable,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "DaeBuilder_add_variable" "', argument " "3"" of type '" "casadi::Variable const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DaeBuilder_add_variable" "', argument " "3"" of type '" "casadi::Variable const &""'"); 
  }
  arg3 = reinterpret_cast< casadi::Variable * >(argp3);
  {
    try {
      (arg1)->add_variable((std::string const &)*arg2,(casadi::Variable const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_variable__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi_int arg3 = (casadi_int) 1 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::MX result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_variable" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = (arg1)->add_variable((std::string const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_variable__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Sparsity *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::Sparsity m3 ;
  casadi::MX result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_add_variable" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "Sparsity" "'.");
  {
    try {
      result = (arg1)->add_variable((std::string const &)*arg2,(casadi::Sparsity const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_add_variable(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_add_variable", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_DaeBuilder_add_variable__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< casadi_int **>(0));
        if (_v) {
          return _wrap_DaeBuilder_add_variable__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        int res = SWIG_ConvertPtr(argv[2], 0, SWIGTYPE_p_casadi__Variable, SWIG_POINTER_NO_NULL | 0);
        _v = SWIG_CheckState(res);
        if (_v) {
          return _wrap_DaeBuilder_add_variable__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Sparsity **>(0));
        if (_v) {
          return _wrap_DaeBuilder_add_variable__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_add_variable'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::add_variable(std::string const &,casadi::Variable const &)\n"
    "    casadi::DaeBuilder::add_variable(std::string const &,casadi_int)\n"
    "    casadi::DaeBuilder::add_variable(std::string const &,casadi::Sparsity const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_variable__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::Variable *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_variable" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi::Variable *) &(arg1)->variable((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Variable, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_variable__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  casadi::Variable *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DaeBuilder_variable" "', argument " "1"" of type '" "casadi::DaeBuilder const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      result = (casadi::Variable *) &((casadi::DaeBuilder const *)arg1)->variable((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Variable, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DaeBuilder_variable(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "DaeBuilder_variable", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_DaeBuilder_variable__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__DaeBuilder, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_DaeBuilder_variable__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'DaeBuilder_variable'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::variable(std::string const &)\n"
    "    casadi::DaeBuilder::variable(std::string const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_new_DaeBuilder__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::DaeBuilder *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__DaeBuilder,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_DaeBuilder" "', argument " "1"" of type '" "casadi::DaeBuilder const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_DaeBuilder" "', argument " "1"" of type '" "casadi::DaeBuilder const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    result = (casadi::DaeBuilder *)new casadi::DaeBuilder((casadi::DaeBuilder const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__DaeBuilder, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_DaeBuilder(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_DaeBuilder", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_DaeBuilder__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__DaeBuilder, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_DaeBuilder__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_DaeBuilder'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::DaeBuilder::DaeBuilder()\n"
    "    casadi::DaeBuilder::DaeBuilder(casadi::DaeBuilder const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_DaeBuilder(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DaeBuilder *arg1 = (casadi::DaeBuilder *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DaeBuilder, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DaeBuilder" "', argument " "1"" of type '" "casadi::DaeBuilder *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DaeBuilder * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DaeBuilder_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__DaeBuilder, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *DaeBuilder_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_XmlFile_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "XmlFile_type_name", 0, 0, 0)) SWIG_fail;
  {
    try {
      result = casadi::XmlFile::type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XmlFile__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::XmlFile *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::XmlFile *)new casadi::XmlFile();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__XmlFile, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XmlFile__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  casadi::XmlFile *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (casadi::XmlFile *)new casadi::XmlFile((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__XmlFile, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_XmlFile(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::XmlFile *arg1 = (casadi::XmlFile *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__XmlFile, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_XmlFile" "', argument " "1"" of type '" "casadi::XmlFile *""'"); 
  }
  arg1 = reinterpret_cast< casadi::XmlFile * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XmlFile_load_plugin(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      casadi::XmlFile::load_plugin((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_XmlFile_doc(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = casadi::XmlFile::doc((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XmlFile__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::XmlFile *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::XmlFile *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__XmlFile,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_XmlFile" "', argument " "1"" of type '" "casadi::XmlFile const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_XmlFile" "', argument " "1"" of type '" "casadi::XmlFile const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::XmlFile * >(argp1);
  {
    result = (casadi::XmlFile *)new casadi::XmlFile((casadi::XmlFile const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__XmlFile, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_XmlFile(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_XmlFile", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_XmlFile__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__XmlFile, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_XmlFile__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      return _wrap_new_XmlFile__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_XmlFile'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::XmlFile::XmlFile()\n"
    "    casadi::XmlFile::XmlFile(std::string const &)\n"
    "    casadi::XmlFile::XmlFile(casadi::XmlFile const &)\n");
  return 0;
}


SWIGINTERN PyObject *XmlFile_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__XmlFile, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *XmlFile_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_delete_SerializerBase(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_SerializerBase" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  casadi::Sparsity *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Sparsity m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Sparsity" "'.");
  {
    try {
      (arg1)->pack((casadi::Sparsity const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      (arg1)->pack((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  casadi::Matrix< double > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  {
    try {
      (arg1)->pack((casadi::Matrix< double > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_3(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  casadi::Matrix< casadi::SXElem > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  {
    try {
      (arg1)->pack((casadi::Matrix< casadi::SXElem > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_4(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  casadi::Linsol *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__Linsol,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SerializerBase_pack" "', argument " "2"" of type '" "casadi::Linsol const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SerializerBase_pack" "', argument " "2"" of type '" "casadi::Linsol const &""'"); 
  }
  arg2 = reinterpret_cast< casadi::Linsol * >(argp2);
  {
    try {
      (arg1)->pack((casadi::Linsol const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_5(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  casadi::Function *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Function m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "Function" "'.");
  {
    try {
      (arg1)->pack((casadi::Function const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_6(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  casadi::GenericType *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::GenericType m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "GenericType" "'.");
  {
    try {
      (arg1)->pack((casadi::GenericType const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_7(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  casadi_int *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi_int m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      (arg1)->pack((casadi_int const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_8(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  double *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  {
    try {
      (arg1)->pack((double const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_9(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      (arg1)->pack((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_10(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Sparsity > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "Sparsity" "]" "'.");
  {
    try {
      (arg1)->pack((std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_11(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  {
    try {
      (arg1)->pack((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_12(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< double > > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "DM" "]" "'.");
  {
    try {
      (arg1)->pack((std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_13(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Matrix< casadi::SXElem > > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "SX" "]" "'.");
  {
    try {
      (arg1)->pack((std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_14(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SerializerBase_pack" "', argument " "2"" of type '" "std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SerializerBase_pack" "', argument " "2"" of type '" "std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > const &""'"); 
  }
  arg2 = reinterpret_cast< std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > * >(argp2);
  {
    try {
      (arg1)->pack((std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_15(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< casadi::Function,std::allocator< casadi::Function > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::Function > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "Function" "]" "'.");
  {
    try {
      (arg1)->pack((std::vector< casadi::Function,std::allocator< casadi::Function > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_16(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< casadi::GenericType,std::allocator< casadi::GenericType > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::GenericType > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "GenericType" "]" "'.");
  {
    try {
      (arg1)->pack((std::vector< casadi::GenericType,std::allocator< casadi::GenericType > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_17(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< casadi_int,std::allocator< casadi_int > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi_int > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "int" "]" "'.");
  {
    try {
      (arg1)->pack((std::vector< casadi_int,std::allocator< casadi_int > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_18(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< double,std::allocator< double > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< double > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "float" "]" "'.");
  {
    try {
      (arg1)->pack((std::vector< double,std::allocator< double > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack__SWIG_19(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< std::string > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_pack" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "str" "]" "'.");
  {
    try {
      (arg1)->pack((std::vector< std::string,std::allocator< std::string > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_pack(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "SerializerBase_pack", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_casadi__Linsol, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_4(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_14(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi_int **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_7(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< double **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_8(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Sparsity> **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_10(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Sparsity **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<double> **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_18(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi_int> **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_17(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<std::string> **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_19(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_2(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<double> > **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_12(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_3(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector< casadi::Matrix<casadi::SXElem> > **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_13(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_11(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_9(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::Function> **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_15(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Function **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_5(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::GenericType> **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_16(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__SerializerBase, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::GenericType **>(0));
      if (_v) {
        return _wrap_SerializerBase_pack__SWIG_6(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'SerializerBase_pack'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::SerializerBase::pack(casadi::Sparsity const &)\n"
    "    casadi::SerializerBase::pack(casadi::MX const &)\n"
    "    casadi::SerializerBase::pack(casadi::Matrix< double > const &)\n"
    "    casadi::SerializerBase::pack(casadi::Matrix< casadi::SXElem > const &)\n"
    "    casadi::SerializerBase::pack(casadi::Linsol const &)\n"
    "    casadi::SerializerBase::pack(casadi::Function const &)\n"
    "    casadi::SerializerBase::pack(casadi::GenericType const &)\n"
    "    casadi::SerializerBase::pack(casadi_int const &)\n"
    "    casadi::SerializerBase::pack(double const &)\n"
    "    casadi::SerializerBase::pack(std::string const &)\n"
    "    casadi::SerializerBase::pack(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const &)\n"
    "    casadi::SerializerBase::pack(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n"
    "    casadi::SerializerBase::pack(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const &)\n"
    "    casadi::SerializerBase::pack(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const &)\n"
    "    casadi::SerializerBase::pack(std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > const &)\n"
    "    casadi::SerializerBase::pack(std::vector< casadi::Function,std::allocator< casadi::Function > > const &)\n"
    "    casadi::SerializerBase::pack(std::vector< casadi::GenericType,std::allocator< casadi::GenericType > > const &)\n"
    "    casadi::SerializerBase::pack(std::vector< casadi_int,std::allocator< casadi_int > > const &)\n"
    "    casadi::SerializerBase::pack(std::vector< double,std::allocator< double > > const &)\n"
    "    casadi::SerializerBase::pack(std::vector< std::string,std::allocator< std::string > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_SerializerBase_type_to_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SerializerBase::SerializationType arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "SerializerBase_type_to_string" "', argument " "1"" of type '" "casadi::SerializerBase::SerializationType""'");
  } 
  arg1 = static_cast< casadi::SerializerBase::SerializationType >(val1);
  {
    try {
      result = casadi::SerializerBase::type_to_string(arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_connect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  casadi::DeserializerBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "SerializerBase_connect", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_connect" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__DeserializerBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "SerializerBase_connect" "', argument " "2"" of type '" "casadi::DeserializerBase &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "SerializerBase_connect" "', argument " "2"" of type '" "casadi::DeserializerBase &""'"); 
  }
  arg2 = reinterpret_cast< casadi::DeserializerBase * >(argp2);
  {
    try {
      (arg1)->connect(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_SerializerBase_reset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::SerializerBase *arg1 = (casadi::SerializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__SerializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SerializerBase_reset" "', argument " "1"" of type '" "casadi::SerializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::SerializerBase * >(argp1);
  {
    try {
      (arg1)->reset();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *SerializerBase_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__SerializerBase, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_delete_DeserializerBase(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DeserializerBase" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase__pop_type(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::SerializerBase::SerializationType result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase__pop_type" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (casadi::SerializerBase::SerializationType)(arg1)->pop_type();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_sparsity" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_sparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_mx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_mx" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_mx();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_dm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< double > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_dm" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_dm();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_sx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_sx" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_sx();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_linsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Linsol result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_linsol" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_linsol();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::Linsol(static_cast< const casadi::Linsol& >(result))), SWIGTYPE_p_casadi__Linsol, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_function(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Function result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_function" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_function();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_generictype(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::GenericType result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_generictype" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_generictype();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "GenericType" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_int(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_int" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (casadi_int)(arg1)->blind_unpack_int();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_double(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_double" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (double)(arg1)->blind_unpack_double();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_string" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_string();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_sparsity_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_sparsity_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_sparsity_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_mx_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_mx_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_mx_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_dm_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_dm_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_dm_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_sx_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_sx_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_sx_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_linsol_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_linsol_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_linsol_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new std::vector< casadi::Linsol,std::allocator< casadi::Linsol > >(static_cast< const std::vector< casadi::Linsol,std::allocator< casadi::Linsol > >& >(result))), SWIGTYPE_p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_function_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Function,std::allocator< casadi::Function > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_function_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_function_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Function" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_generictype_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::GenericType,std::allocator< casadi::GenericType > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_generictype_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_generictype_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "GenericType" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_int_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_int_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_int_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_double_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_double_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_double_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_blind_unpack_string_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_blind_unpack_string_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->blind_unpack_string_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_sparsity(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Sparsity result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_sparsity" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_sparsity();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Sparsity" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_mx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_mx" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_mx();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_dm(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< double > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_dm" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_dm();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_sx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Matrix< casadi::SXElem > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_sx" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_sx();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "SX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_linsol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Linsol result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_linsol" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_linsol();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::Linsol(static_cast< const casadi::Linsol& >(result))), SWIGTYPE_p_casadi__Linsol, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_function(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Function result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_function" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_function();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_generictype(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::GenericType result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_generictype" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_generictype();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "GenericType" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_int(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_int" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (casadi_int)(arg1)->unpack_int();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_double(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_double" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (double)(arg1)->unpack_double();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "float" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_string(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_string" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_string();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_sparsity_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_sparsity_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_sparsity_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Sparsity" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_mx_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_mx_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_mx_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_dm_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_dm_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_dm_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_sx_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_sx_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_sx_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "SX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_linsol_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_linsol_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_linsol_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new std::vector< casadi::Linsol,std::allocator< casadi::Linsol > >(static_cast< const std::vector< casadi::Linsol,std::allocator< casadi::Linsol > >& >(result))), SWIGTYPE_p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_function_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::Function,std::allocator< casadi::Function > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_function_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_function_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "Function" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_generictype_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::GenericType,std::allocator< casadi::GenericType > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_generictype_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_generictype_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "GenericType" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_int_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi_int,std::allocator< casadi_int > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_int_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_int_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "int" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_double_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< double,std::allocator< double > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_double_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_double_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "float" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_unpack_string_vector(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< std::string,std::allocator< std::string > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_unpack_string_vector" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      result = (arg1)->unpack_string_vector();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "str" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_connect(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  casadi::SerializerBase *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "DeserializerBase_connect", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_connect" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__SerializerBase,  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "DeserializerBase_connect" "', argument " "2"" of type '" "casadi::SerializerBase &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "DeserializerBase_connect" "', argument " "2"" of type '" "casadi::SerializerBase &""'"); 
  }
  arg2 = reinterpret_cast< casadi::SerializerBase * >(argp2);
  {
    try {
      (arg1)->connect(*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DeserializerBase_reset(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::DeserializerBase *arg1 = (casadi::DeserializerBase *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__DeserializerBase, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DeserializerBase_reset" "', argument " "1"" of type '" "casadi::DeserializerBase *""'"); 
  }
  arg1 = reinterpret_cast< casadi::DeserializerBase * >(argp1);
  {
    try {
      (arg1)->reset();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *DeserializerBase_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__DeserializerBase, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *_wrap_new_StringSerializer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Dict const &arg1_defvalue = casadi::Dict() ;
  casadi::Dict *arg1 = (casadi::Dict *) &arg1_defvalue ;
  std::map< std::string,casadi::GenericType > m1 ;
  PyObject *swig_obj[1] ;
  casadi::StringSerializer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_StringSerializer", 0, 1, swig_obj)) SWIG_fail;
  if (swig_obj[0]) {
    arg1 = &m1;
    if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::StringSerializer *)new casadi::StringSerializer((casadi::Dict const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__StringSerializer, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StringSerializer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::StringSerializer *arg1 = (casadi::StringSerializer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__StringSerializer, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StringSerializer" "', argument " "1"" of type '" "casadi::StringSerializer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::StringSerializer * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StringSerializer_encode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::StringSerializer *arg1 = (casadi::StringSerializer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__StringSerializer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringSerializer_encode" "', argument " "1"" of type '" "casadi::StringSerializer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::StringSerializer * >(argp1);
  {
    try {
      result = (arg1)->encode();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *StringSerializer_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__StringSerializer, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *StringSerializer_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_FileSerializer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  casadi::Dict const &arg2_defvalue = casadi::Dict() ;
  casadi::Dict *arg2 = (casadi::Dict *) &arg2_defvalue ;
  std::string m1 ;
  std::map< std::string,casadi::GenericType > m2 ;
  PyObject *swig_obj[2] ;
  casadi::FileSerializer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args, "new_FileSerializer", 1, 2, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  if (swig_obj[1]) {
    arg2 = &m2;
    if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" "'.");
  }
  {
    try {
      result = (casadi::FileSerializer *)new casadi::FileSerializer((std::string const &)*arg1,(casadi::Dict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__FileSerializer, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_FileSerializer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::FileSerializer *arg1 = (casadi::FileSerializer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__FileSerializer, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FileSerializer" "', argument " "1"" of type '" "casadi::FileSerializer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::FileSerializer * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *FileSerializer_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__FileSerializer, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *FileSerializer_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_StringDeserializer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  casadi::StringDeserializer *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (casadi::StringDeserializer *)new casadi::StringDeserializer((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__StringDeserializer, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_StringDeserializer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::StringDeserializer *arg1 = (casadi::StringDeserializer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__StringDeserializer, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_StringDeserializer" "', argument " "1"" of type '" "casadi::StringDeserializer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::StringDeserializer * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StringDeserializer_decode(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::StringDeserializer *arg1 = (casadi::StringDeserializer *) 0 ;
  std::string *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "StringDeserializer_decode", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__StringDeserializer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StringDeserializer_decode" "', argument " "1"" of type '" "casadi::StringDeserializer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::StringDeserializer * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  {
    try {
      (arg1)->decode((std::string const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *StringDeserializer_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__StringDeserializer, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *StringDeserializer_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_FileDeserializer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  std::string *arg1 = 0 ;
  std::string m1 ;
  PyObject *swig_obj[1] ;
  casadi::FileDeserializer *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  {
    try {
      result = (casadi::FileDeserializer *)new casadi::FileDeserializer((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__FileDeserializer, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_FileDeserializer(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::FileDeserializer *arg1 = (casadi::FileDeserializer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__FileDeserializer, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FileDeserializer" "', argument " "1"" of type '" "casadi::FileDeserializer *""'"); 
  }
  arg1 = reinterpret_cast< casadi::FileDeserializer * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *FileDeserializer_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__FileDeserializer, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *FileDeserializer_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_Opti__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  std::string const &arg1_defvalue = "nlp" ;
  std::string *arg1 = (std::string *) &arg1_defvalue ;
  std::string m1 ;
  casadi::Opti *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 1)) SWIG_fail;
  if (swig_obj[0]) {
    arg1 = &m1;
    if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "str" "'.");
  }
  {
    try {
      result = (casadi::Opti *)new casadi::Opti((std::string const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Opti, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__variable(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) 1 ;
  std::string const &arg4_defvalue = "full" ;
  std::string *arg4 = (std::string *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m4 ;
  PyObject *swig_obj[4] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "Opti__variable", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__variable" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "str" "'.");
  }
  {
    try {
      result = (arg1)->variable(arg2,arg3,(std::string const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__parameter(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi_int arg2 = (casadi_int) 1 ;
  casadi_int arg3 = (casadi_int) 1 ;
  std::string const &arg4_defvalue = "full" ;
  std::string *arg4 = (std::string *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m4 ;
  PyObject *swig_obj[4] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "Opti__parameter", 1, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__parameter" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  }
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "str" "'.");
  }
  {
    try {
      result = (arg1)->parameter(arg2,arg3,(std::string const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_minimize(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Opti_minimize", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_minimize" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      (arg1)->minimize((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__subject_to__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__subject_to" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      (arg1)->subject_to((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__subject_to__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__subject_to" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  {
    try {
      (arg1)->subject_to((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__subject_to__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__subject_to" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      (arg1)->subject_to();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__subject_to(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Opti__subject_to", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Opti__subject_to__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_Opti__subject_to__SWIG_0(self, argc, argv);
      }
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        return _wrap_Opti__subject_to__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Opti__subject_to'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Opti::subject_to(casadi::MX const &)\n"
    "    casadi::Opti::subject_to(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n"
    "    casadi::Opti::subject_to()\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Opti_solver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  std::string *arg2 = 0 ;
  casadi::Dict const &arg3_defvalue = casadi::Dict() ;
  casadi::Dict *arg3 = (casadi::Dict *) &arg3_defvalue ;
  casadi::Dict const &arg4_defvalue = casadi::Dict() ;
  casadi::Dict *arg4 = (casadi::Dict *) &arg4_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  std::map< std::string,casadi::GenericType > m4 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args, "Opti_solver", 2, 4, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_solver" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  }
  if (swig_obj[3]) {
    arg4 = &m4;
    if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "dict" "'.");
  }
  {
    try {
      (arg1)->solver((std::string const &)*arg2,(casadi::Dict const &)*arg3,(casadi::Dict const &)*arg4);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_set_initial__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::DM *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< double > m3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_set_initial" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      (arg1)->set_initial((casadi::MX const &)*arg2,(casadi::DM const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_set_initial__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_set_initial" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  {
    try {
      (arg1)->set_initial((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_set_initial(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Opti_set_initial", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        return _wrap_Opti_set_initial__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          return _wrap_Opti_set_initial__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Opti_set_initial'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Opti::set_initial(casadi::MX const &,casadi::DM const &)\n"
    "    casadi::Opti::set_initial(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Opti_set_value__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::DM *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  casadi::Matrix< double > m3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_set_value" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "DM" "'.");
  {
    try {
      (arg1)->set_value((casadi::MX const &)*arg2,(casadi::DM const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_set_value__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_set_value" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  {
    try {
      (arg1)->set_value((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_set_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Opti_set_value", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        return _wrap_Opti_set_value__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< casadi::Matrix<double> **>(0));
        if (_v) {
          return _wrap_Opti_set_value__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Opti_set_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Opti::set_value(casadi::MX const &,casadi::DM const &)\n"
    "    casadi::Opti::set_value(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Opti_solve(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< casadi::OptiSol > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_solve" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = (arg1)->solve();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::OptiSol(static_cast< const casadi::OptiSol& >(result))), SWIGTYPE_p_casadi__OptiSol, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_solve_limited(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< casadi::OptiSol > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_solve_limited" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = (arg1)->solve_limited();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::OptiSol(static_cast< const casadi::OptiSol& >(result))), SWIGTYPE_p_casadi__OptiSol, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_value__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > const &arg3_defvalue = std::vector< casadi::MX >() ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< casadi::MX > m3 ;
  casadi::native_DM result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_value" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  }
  {
    try {
      result = ((casadi::Opti const *)arg1)->value((casadi::MX const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = full_or_sparse(result, true))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type 'double'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_value__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::DM *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > const &arg3_defvalue = std::vector< casadi::MX >() ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  std::vector< casadi::MX > m3 ;
  casadi::native_DM result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_value" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  }
  {
    try {
      result = ((casadi::Opti const *)arg1)->value((casadi::DM const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = full_or_sparse(result, true))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type 'double'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_value__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::SX *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > const &arg3_defvalue = std::vector< casadi::MX >() ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  std::vector< casadi::MX > m3 ;
  casadi::native_DM result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_value" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  }
  {
    try {
      result = ((casadi::Opti const *)arg1)->value((casadi::SX const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = full_or_sparse(result, true))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type 'double'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Opti_value", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Opti_value__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          return _wrap_Opti_value__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Opti_value__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          return _wrap_Opti_value__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_Opti_value__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          return _wrap_Opti_value__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Opti_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Opti::value(casadi::MX const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &) const\n"
    "    casadi::Opti::value(casadi::DM const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &) const\n"
    "    casadi::Opti::value(casadi::SX const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Opti_stats(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_stats" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->stats();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_return_status(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_return_status" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->return_status();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_initial(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_initial" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->initial();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_value_variables(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_value_variables" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->value_variables();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_value_parameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_value_parameters" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->value_parameters();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_dual(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "Opti_dual", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_dual" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::Opti const *)arg1)->dual((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__nx(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__nx" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Opti const *)arg1)->nx();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__np(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__np" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Opti const *)arg1)->np();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__ng(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__ng" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::Opti const *)arg1)->ng();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__x(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__x" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->x();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__p(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__p" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->p();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__g(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__g" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->g();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__f(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__f" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->f();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__lbg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__lbg" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->lbg();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__ubg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__ubg" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->ubg();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__lam_g(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__lam_g" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->lam_g();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_to_function__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg4 = 0 ;
  casadi::Dict const &arg5_defvalue = casadi::Dict() ;
  casadi::Dict *arg5 = (casadi::Dict *) &arg5_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< casadi::MX > m3 ;
  std::vector< casadi::MX > m4 ;
  std::map< std::string,casadi::GenericType > m5 ;
  casadi::Function result;
  
  if ((nobjs < 4) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_to_function" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "MX" "]" "'.");
  if (swig_obj[4]) {
    arg5 = &m5;
    if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "dict" "'.");
  }
  {
    try {
      result = (arg1)->to_function((std::string const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg4,(casadi::Dict const &)*arg5);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_to_function__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg4 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg6 = 0 ;
  casadi::Dict const &arg7_defvalue = casadi::Dict() ;
  casadi::Dict *arg7 = (casadi::Dict *) &arg7_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::vector< casadi::MX > m3 ;
  std::vector< casadi::MX > m4 ;
  std::vector< std::string > m5 ;
  std::vector< std::string > m6 ;
  std::map< std::string,casadi::GenericType > m7 ;
  casadi::Function result;
  
  if ((nobjs < 6) || (nobjs > 7)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_to_function" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "MX" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "str" "]" "'.");
  arg6 = &m6;
  if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "[" "str" "]" "'.");
  if (swig_obj[6]) {
    arg7 = &m7;
    if (!casadi::to_ptr(swig_obj[6], &arg7)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 7 to type '" "dict" "'.");
  }
  {
    try {
      result = (arg1)->to_function((std::string const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(std::vector< std::string,std::allocator< std::string > > const &)*arg6,(casadi::Dict const &)*arg7);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_to_function__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  std::string *arg2 = 0 ;
  std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > *arg3 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg4 = 0 ;
  std::vector< std::string,std::allocator< std::string > > *arg5 = 0 ;
  casadi::Dict const &arg6_defvalue = casadi::Dict() ;
  casadi::Dict *arg6 = (casadi::Dict *) &arg6_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::string m2 ;
  std::map< std::string,casadi::MX > m3 ;
  std::vector< std::string > m4 ;
  std::vector< std::string > m5 ;
  std::map< std::string,casadi::GenericType > m6 ;
  casadi::Function result;
  
  if ((nobjs < 5) || (nobjs > 6)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_to_function" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "str" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" ":" "MX" "'.");
  arg4 = &m4;
  if (!casadi::to_ptr(swig_obj[3], &arg4)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 4 to type '" "[" "str" "]" "'.");
  arg5 = &m5;
  if (!casadi::to_ptr(swig_obj[4], &arg5)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 5 to type '" "[" "str" "]" "'.");
  if (swig_obj[5]) {
    arg6 = &m6;
    if (!casadi::to_ptr(swig_obj[5], &arg6)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 6 to type '" "dict" "'.");
  }
  {
    try {
      result = (arg1)->to_function((std::string const &)*arg2,(std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const &)*arg3,(std::vector< std::string,std::allocator< std::string > > const &)*arg4,(std::vector< std::string,std::allocator< std::string > > const &)*arg5,(casadi::Dict const &)*arg6);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_to_function(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[8] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Opti_to_function", 0, 7, argv))) SWIG_fail;
  --argc;
  if ((argc >= 4) && (argc <= 5)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi::MX> **>(0));
          if (_v) {
            if (argc <= 4) {
              return _wrap_Opti_to_function__SWIG_0(self, argc, argv);
            }
            _v = casadi::to_ptr(argv[4], static_cast< std::map<std::string,casadi::GenericType> **>(0));
            if (_v) {
              return _wrap_Opti_to_function__SWIG_0(self, argc, argv);
            }
          }
        }
      }
    }
  }
  if ((argc >= 5) && (argc <= 6)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::MX> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<std::string> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<std::string> **>(0));
            if (_v) {
              if (argc <= 5) {
                return _wrap_Opti_to_function__SWIG_2(self, argc, argv);
              }
              _v = casadi::to_ptr(argv[5], static_cast< std::map<std::string,casadi::GenericType> **>(0));
              if (_v) {
                return _wrap_Opti_to_function__SWIG_2(self, argc, argv);
              }
            }
          }
        }
      }
    }
  }
  if ((argc >= 6) && (argc <= 7)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::string **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          _v = casadi::to_ptr(argv[3], static_cast< std::vector<casadi::MX> **>(0));
          if (_v) {
            _v = casadi::to_ptr(argv[4], static_cast< std::vector<std::string> **>(0));
            if (_v) {
              _v = casadi::to_ptr(argv[5], static_cast< std::vector<std::string> **>(0));
              if (_v) {
                if (argc <= 6) {
                  return _wrap_Opti_to_function__SWIG_1(self, argc, argv);
                }
                _v = casadi::to_ptr(argv[6], static_cast< std::map<std::string,casadi::GenericType> **>(0));
                if (_v) {
                  return _wrap_Opti_to_function__SWIG_1(self, argc, argv);
                }
              }
            }
          }
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Opti_to_function'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Opti::to_function(std::string const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,casadi::Dict const &)\n"
    "    casadi::Opti::to_function(std::string const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &)\n"
    "    casadi::Opti::to_function(std::string const &,std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const &,std::vector< std::string,std::allocator< std::string > > const &,std::vector< std::string,std::allocator< std::string > > const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Opti_bounded(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MX *arg1 = 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MX *arg3 = 0 ;
  casadi::MX m1 ;
  casadi::MX m2 ;
  casadi::MX m3 ;
  PyObject *swig_obj[3] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "Opti_bounded", 3, 3, swig_obj)) SWIG_fail;
  arg1 = &m1;
  if (!casadi::to_ptr(swig_obj[0], &arg1)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 1 to type '" "MX" "'.");
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "MX" "'.");
  {
    try {
      result = casadi::Opti::bounded((casadi::MX const &)*arg1,(casadi::MX const &)*arg2,(casadi::MX const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__debug(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< casadi::OptiAdvanced > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__debug" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->debug();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::OptiAdvanced(static_cast< const casadi::OptiAdvanced& >(result))), SWIGTYPE_p_casadi__OptiAdvanced, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti__advanced(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< casadi::OptiAdvanced > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti__advanced" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->advanced();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::OptiAdvanced(static_cast< const casadi::OptiAdvanced& >(result))), SWIGTYPE_p_casadi__OptiAdvanced, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Opti result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_copy" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->copy();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::Opti(static_cast< const casadi::Opti& >(result))), SWIGTYPE_p_casadi__Opti, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_update_user_dict__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::Dict *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_update_user_dict" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  {
    try {
      (arg1)->update_user_dict((casadi::MX const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_update_user_dict__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg2 = 0 ;
  casadi::Dict *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX > m2 ;
  std::map< std::string,casadi::GenericType > m3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_update_user_dict" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "[" "MX" "]" "'.");
  arg3 = &m3;
  if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "dict" "'.");
  {
    try {
      (arg1)->update_user_dict((std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg2,(casadi::Dict const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_update_user_dict(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Opti_update_user_dict", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_Opti_update_user_dict__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::vector<casadi::MX> **>(0));
      if (_v) {
        _v = casadi::to_ptr(argv[2], static_cast< std::map<std::string,casadi::GenericType> **>(0));
        if (_v) {
          return _wrap_Opti_update_user_dict__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Opti_update_user_dict'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Opti::update_user_dict(casadi::MX const &,casadi::Dict const &)\n"
    "    casadi::Opti::update_user_dict(std::vector< casadi::MX,std::allocator< casadi::MX > > const &,casadi::Dict const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_Opti_user_dict(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  casadi::Dict result;
  
  if (!SWIG_Python_UnpackTuple(args, "Opti_user_dict", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_user_dict" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::Opti const *)arg1)->user_dict((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_type_name" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = ((casadi::Opti const *)arg1)->type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "Opti_disp", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_disp" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::Opti const *)arg1)->disp(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "Opti_str", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_str" "', argument " "1"" of type '" "casadi::Opti const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::Opti const *)arg1)->get_str(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_callback_class__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  casadi::OptiCallback *arg2 = (casadi::OptiCallback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_callback_class" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2,SWIGTYPE_p_casadi__OptiCallback, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Opti_callback_class" "', argument " "2"" of type '" "casadi::OptiCallback *""'"); 
  }
  arg2 = reinterpret_cast< casadi::OptiCallback * >(argp2);
  {
    try {
      (arg1)->callback_class(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_callback_class__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Opti_callback_class" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      (arg1)->callback_class();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_Opti_callback_class(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "Opti_callback_class", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_Opti_callback_class__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__Opti, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_casadi__OptiCallback, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_Opti_callback_class__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'Opti_callback_class'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Opti::callback_class(casadi::OptiCallback *)\n"
    "    casadi::Opti::callback_class()\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_new_Opti__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Opti *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__Opti,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_Opti" "', argument " "1"" of type '" "casadi::Opti const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_Opti" "', argument " "1"" of type '" "casadi::Opti const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    result = (casadi::Opti *)new casadi::Opti((casadi::Opti const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__Opti, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_Opti(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_Opti", 0, 1, argv))) SWIG_fail;
  --argc;
  if ((argc >= 0) && (argc <= 1)) {
    int _v;
    if (argc <= 0) {
      return _wrap_new_Opti__SWIG_0(self, argc, argv);
    }
    _v = casadi::to_ptr(argv[0], static_cast< std::string **>(0));
    if (_v) {
      return _wrap_new_Opti__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__Opti, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_Opti__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_Opti'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::Opti::Opti(std::string const &)\n"
    "    casadi::Opti::Opti(casadi::Opti const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_Opti(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = (casadi::Opti *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__Opti, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_Opti" "', argument " "1"" of type '" "casadi::Opti *""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *Opti_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__Opti, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *Opti_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_IndexAbstraction__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::IndexAbstraction *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::IndexAbstraction *)new casadi::IndexAbstraction();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__IndexAbstraction, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IndexAbstraction_start_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::IndexAbstraction *arg1 = (casadi::IndexAbstraction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__IndexAbstraction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexAbstraction_start_get" "', argument " "1"" of type '" "casadi::IndexAbstraction *""'"); 
  }
  arg1 = reinterpret_cast< casadi::IndexAbstraction * >(argp1);
  result = (casadi_int) ((arg1)->start);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_IndexAbstraction_stop_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::IndexAbstraction *arg1 = (casadi::IndexAbstraction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__IndexAbstraction, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "IndexAbstraction_stop_get" "', argument " "1"" of type '" "casadi::IndexAbstraction *""'"); 
  }
  arg1 = reinterpret_cast< casadi::IndexAbstraction * >(argp1);
  result = (casadi_int) ((arg1)->stop);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_IndexAbstraction__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::IndexAbstraction *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::IndexAbstraction *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__IndexAbstraction,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_IndexAbstraction" "', argument " "1"" of type '" "casadi::IndexAbstraction const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_IndexAbstraction" "', argument " "1"" of type '" "casadi::IndexAbstraction const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::IndexAbstraction * >(argp1);
  {
    result = (casadi::IndexAbstraction *)new casadi::IndexAbstraction((casadi::IndexAbstraction const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__IndexAbstraction, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_IndexAbstraction(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_IndexAbstraction", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_IndexAbstraction__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__IndexAbstraction, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_IndexAbstraction__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_IndexAbstraction'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::IndexAbstraction::IndexAbstraction()\n"
    "    casadi::IndexAbstraction::IndexAbstraction(casadi::IndexAbstraction const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_IndexAbstraction(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::IndexAbstraction *arg1 = (casadi::IndexAbstraction *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__IndexAbstraction, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_IndexAbstraction" "', argument " "1"" of type '" "casadi::IndexAbstraction *""'"); 
  }
  arg1 = reinterpret_cast< casadi::IndexAbstraction * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *IndexAbstraction_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__IndexAbstraction, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *IndexAbstraction_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_MetaCon__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::MetaCon *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    try {
      result = (casadi::MetaCon *)new casadi::MetaCon();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MetaCon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_original_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_original_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (casadi::MX *) & ((arg1)->original);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_canon_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_canon_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (casadi::MX *) & ((arg1)->canon);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_type_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::ConstraintType result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_type_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (casadi::ConstraintType) ((arg1)->type);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_lb_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_lb_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (casadi::MX *) & ((arg1)->lb);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_ub_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_ub_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (casadi::MX *) & ((arg1)->ub);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_n_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_n_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (casadi_int) ((arg1)->n);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_flipped_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_flipped_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (bool) ((arg1)->flipped);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_dual_canon_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_dual_canon_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (casadi::MX *) & ((arg1)->dual_canon);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_dual_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_dual_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (casadi::MX *) & ((arg1)->dual);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaCon_extra_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaCon_extra_get" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  result = (casadi::Dict *) & ((arg1)->extra);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MetaCon__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MetaCon *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__MetaCon,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MetaCon" "', argument " "1"" of type '" "casadi::MetaCon const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MetaCon" "', argument " "1"" of type '" "casadi::MetaCon const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  {
    result = (casadi::MetaCon *)new casadi::MetaCon((casadi::MetaCon const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MetaCon, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MetaCon(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_MetaCon", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_MetaCon__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__MetaCon, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MetaCon__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_MetaCon'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MetaCon::MetaCon()\n"
    "    casadi::MetaCon::MetaCon(casadi::MetaCon const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_MetaCon(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaCon *arg1 = (casadi::MetaCon *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaCon, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MetaCon" "', argument " "1"" of type '" "casadi::MetaCon *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaCon * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MetaCon_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__MetaCon, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MetaCon_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_MetaVar_attribute_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = (casadi::MetaVar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaVar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaVar_attribute_get" "', argument " "1"" of type '" "casadi::MetaVar *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  result = (std::string *) & ((arg1)->attribute);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaVar_n_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = (casadi::MetaVar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaVar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaVar_n_get" "', argument " "1"" of type '" "casadi::MetaVar *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  result = (casadi_int) ((arg1)->n);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaVar_m_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = (casadi::MetaVar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaVar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaVar_m_get" "', argument " "1"" of type '" "casadi::MetaVar *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  result = (casadi_int) ((arg1)->m);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaVar_type_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = (casadi::MetaVar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::VariableType result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaVar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaVar_type_get" "', argument " "1"" of type '" "casadi::MetaVar *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  result = (casadi::VariableType) ((arg1)->type);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaVar_count_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = (casadi::MetaVar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaVar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaVar_count_get" "', argument " "1"" of type '" "casadi::MetaVar *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  result = (casadi_int) ((arg1)->count);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaVar_i_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = (casadi::MetaVar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaVar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaVar_i_get" "', argument " "1"" of type '" "casadi::MetaVar *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  result = (casadi_int) ((arg1)->i);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaVar_active_i_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = (casadi::MetaVar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaVar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaVar_active_i_get" "', argument " "1"" of type '" "casadi::MetaVar *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  result = (casadi_int) ((arg1)->active_i);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MetaVar_extra_get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = (casadi::MetaVar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaVar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MetaVar_extra_get" "', argument " "1"" of type '" "casadi::MetaVar *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  result = (casadi::Dict *) & ((arg1)->extra);
  if(!(resultobj = casadi::from_ptr(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MetaVar__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  casadi::MetaVar *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  {
    result = (casadi::MetaVar *)new casadi::MetaVar();
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MetaVar, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MetaVar__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MetaVar *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__MetaVar,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_MetaVar" "', argument " "1"" of type '" "casadi::MetaVar const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_MetaVar" "', argument " "1"" of type '" "casadi::MetaVar const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  {
    result = (casadi::MetaVar *)new casadi::MetaVar((casadi::MetaVar const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__MetaVar, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_MetaVar(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_MetaVar", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_MetaVar__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__MetaVar, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_MetaVar__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_MetaVar'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::MetaVar::MetaVar()\n"
    "    casadi::MetaVar::MetaVar(casadi::MetaVar const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_MetaVar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::MetaVar *arg1 = (casadi::MetaVar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__MetaVar, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_MetaVar" "', argument " "1"" of type '" "casadi::MetaVar *""'"); 
  }
  arg1 = reinterpret_cast< casadi::MetaVar * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *MetaVar_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__MetaVar, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *MetaVar_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_OptiCallback__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  casadi::OptiCallback *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  arg1 = swig_obj[0];
  {
    try {
      if ( arg1 != Py_None ) {
        /* subclassed */
        result = (casadi::OptiCallback *)new SwigDirector_OptiCallback(arg1); 
      } else {
        result = (casadi::OptiCallback *)new casadi::OptiCallback(); 
      }
      
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__OptiCallback, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_OptiCallback__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  PyObject *arg1 = (PyObject *) 0 ;
  casadi::OptiCallback *arg2 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  casadi::OptiCallback *result = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  arg1 = swig_obj[0];
  res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_casadi__OptiCallback,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_OptiCallback" "', argument " "2"" of type '" "casadi::OptiCallback const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OptiCallback" "', argument " "2"" of type '" "casadi::OptiCallback const &""'"); 
  }
  arg2 = reinterpret_cast< casadi::OptiCallback * >(argp2);
  {
    try {
      if ( arg1 != Py_None ) {
        /* subclassed */
        result = (casadi::OptiCallback *)new SwigDirector_OptiCallback(arg1,(casadi::OptiCallback const &)*arg2); 
      } else {
        result = (casadi::OptiCallback *)new casadi::OptiCallback((casadi::OptiCallback const &)*arg2); 
      }
      
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__OptiCallback, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_OptiCallback(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_OptiCallback", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      return _wrap_new_OptiCallback__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    _v = (argv[0] != 0);
    if (_v) {
      int res = SWIG_ConvertPtr(argv[1], 0, SWIGTYPE_p_casadi__OptiCallback, SWIG_POINTER_NO_NULL | 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_OptiCallback__SWIG_1(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_OptiCallback'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::OptiCallback::OptiCallback()\n"
    "    casadi::OptiCallback::OptiCallback(PyObject *,casadi::OptiCallback const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_OptiCallback_call(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiCallback *arg1 = (casadi::OptiCallback *) 0 ;
  casadi_int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  Swig::Director *director = 0;
  bool upcall = false;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiCallback_call", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiCallback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiCallback_call" "', argument " "1"" of type '" "casadi::OptiCallback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiCallback * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  director = SWIG_DIRECTOR_CAST(arg1);
  upcall = (director && (director->swig_get_self()==swig_obj[0]));
  try {
    {
      try {
        if (upcall) {
          (arg1)->casadi::OptiCallback::call(arg2);
        } else {
          (arg1)->call(arg2);
        }
      } catch(const std::exception& e) {
        SWIG_exception(SWIG_RuntimeError, e.what());
      }
    }
  } catch (Swig::DirectorException&) {
    SWIG_fail;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptiCallback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiCallback *arg1 = (casadi::OptiCallback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiCallback, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptiCallback" "', argument " "1"" of type '" "casadi::OptiCallback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiCallback * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_disown_OptiCallback(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiCallback *arg1 = (casadi::OptiCallback *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiCallback, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disown_OptiCallback" "', argument " "1"" of type '" "casadi::OptiCallback *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiCallback * >(argp1);
  {
    Swig::Director *director = SWIG_DIRECTOR_CAST(arg1);
    if (director) director->swig_disown();
  }
  
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *OptiCallback_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__OptiCallback, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *OptiCallback_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_new_OptiAdvanced__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::Opti *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::OptiAdvanced *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__Opti,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_OptiAdvanced" "', argument " "1"" of type '" "casadi::Opti const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OptiAdvanced" "', argument " "1"" of type '" "casadi::Opti const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::Opti * >(argp1);
  {
    try {
      result = (casadi::OptiAdvanced *)new casadi::OptiAdvanced((casadi::Opti const &)*arg1);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__OptiAdvanced, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_OptiAdvanced(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptiAdvanced" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      delete arg1;
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced__casadi_solver(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Function result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced__casadi_solver" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->casadi_solver();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "Function" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_is_parametric(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_is_parametric", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_is_parametric" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = (bool)((casadi::OptiAdvanced const *)arg1)->is_parametric((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_symvar__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_symvar" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->symvar();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_symvar__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_symvar" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->symvar((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_symvar__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::VariableType arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  int val3 ;
  int ecode3 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_symvar" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "OptiAdvanced_symvar" "', argument " "3"" of type '" "casadi::VariableType""'");
  } 
  arg3 = static_cast< casadi::VariableType >(val3);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->symvar((casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_symvar(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "OptiAdvanced_symvar", 0, 3, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__OptiAdvanced, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OptiAdvanced_symvar__SWIG_0(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__OptiAdvanced, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        return _wrap_OptiAdvanced_symvar__SWIG_1(self, argc, argv);
      }
    }
  }
  if (argc == 3) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__OptiAdvanced, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        {
          int res = SWIG_AsVal_int(argv[2], NULL);
          _v = SWIG_CheckState(res);
        }
        if (_v) {
          return _wrap_OptiAdvanced_symvar__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'OptiAdvanced_symvar'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::OptiAdvanced::symvar() const\n"
    "    casadi::OptiAdvanced::symvar(casadi::MX const &) const\n"
    "    casadi::OptiAdvanced::symvar(casadi::MX const &,casadi::VariableType) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_canon_expr(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  casadi::MetaCon result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_canon_expr", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_canon_expr" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->canon_expr((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::MetaCon(static_cast< const casadi::MetaCon& >(result))), SWIGTYPE_p_casadi__MetaCon, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_get_meta(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  casadi::MetaVar result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_get_meta", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_get_meta" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->get_meta((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::MetaVar(static_cast< const casadi::MetaVar& >(result))), SWIGTYPE_p_casadi__MetaVar, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_get_meta_con(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  casadi::MetaCon result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_get_meta_con", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_get_meta_con" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->get_meta_con((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::MetaCon(static_cast< const casadi::MetaCon& >(result))), SWIGTYPE_p_casadi__MetaCon, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_set_meta(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MetaVar *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_set_meta", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_set_meta" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_casadi__MetaVar,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OptiAdvanced_set_meta" "', argument " "3"" of type '" "casadi::MetaVar const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OptiAdvanced_set_meta" "', argument " "3"" of type '" "casadi::MetaVar const &""'"); 
  }
  arg3 = reinterpret_cast< casadi::MetaVar * >(argp3);
  {
    try {
      (arg1)->set_meta((casadi::MX const &)*arg2,(casadi::MetaVar const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_set_meta_con(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  casadi::MetaCon *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_set_meta_con", 3, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_set_meta_con" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_casadi__MetaCon,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "OptiAdvanced_set_meta_con" "', argument " "3"" of type '" "casadi::MetaCon const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "OptiAdvanced_set_meta_con" "', argument " "3"" of type '" "casadi::MetaCon const &""'"); 
  }
  arg3 = reinterpret_cast< casadi::MetaCon * >(argp3);
  {
    try {
      (arg1)->set_meta_con((casadi::MX const &)*arg2,(casadi::MetaCon const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_assert_active_symbol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_assert_active_symbol", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_assert_active_symbol" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  {
    try {
      ((casadi::OptiAdvanced const *)arg1)->assert_active_symbol((casadi::MX const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_active_symvar(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::VariableType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_active_symvar", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_active_symvar" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OptiAdvanced_active_symvar" "', argument " "2"" of type '" "casadi::VariableType""'");
  } 
  arg2 = static_cast< casadi::VariableType >(val2);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->active_symvar(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_active_values(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::VariableType arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  std::vector< casadi::DM,std::allocator< casadi::DM > > result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_active_values", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_active_values" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "OptiAdvanced_active_values" "', argument " "2"" of type '" "casadi::VariableType""'");
  } 
  arg2 = static_cast< casadi::VariableType >(val2);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->active_values(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "DM" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_x_lookup(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi_index arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_x_lookup", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_x_lookup" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->x_lookup(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_g_lookup(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi_index arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  casadi::MX result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_g_lookup", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_g_lookup" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->g_lookup(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_x_describe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi_index arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_x_describe", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_x_describe" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->x_describe(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_g_describe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi_index arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_g_describe", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_g_describe" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "int" "'.");
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->g_describe(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_describe(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::MX *arg2 = 0 ;
  casadi_index arg3 = (casadi_index) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  PyObject *swig_obj[3] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_describe", 2, 3, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_describe" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    if (!casadi::to_val(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "int" "'.");
  }
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->describe((casadi::MX const &)*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_show_infeasibilities(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  double arg2 = (double) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_show_infeasibilities", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_show_infeasibilities" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "float" "'.");
  }
  {
    try {
      ((casadi::OptiAdvanced const *)arg1)->show_infeasibilities(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_solve_prepare(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_solve_prepare" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      (arg1)->solve_prepare();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_solve_actual(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::DMDict *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::Matrix< double > > m2 ;
  PyObject *swig_obj[2] ;
  casadi::DMDict result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_solve_actual", 2, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_solve_actual" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "DM" "'.");
  {
    try {
      result = (arg1)->solve_actual((casadi::DMDict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" ":" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_arg(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::DMDict result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_arg" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->arg();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" ":" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_res__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  casadi::DMDict *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  std::map< std::string,casadi::Matrix< double > > m2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_res" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "dict" ":" "DM" "'.");
  {
    try {
      (arg1)->res((casadi::DMDict const &)*arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_res__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::DMDict result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_res" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->res();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" ":" "DM" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_res(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "OptiAdvanced_res", 0, 2, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__OptiAdvanced, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_OptiAdvanced_res__SWIG_1(self, argc, argv);
    }
  }
  if (argc == 2) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__OptiAdvanced, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< std::map<std::string,casadi::Matrix<double> > **>(0));
      if (_v) {
        return _wrap_OptiAdvanced_res__SWIG_0(self, argc, argv);
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'OptiAdvanced_res'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::OptiAdvanced::res(casadi::DMDict const &)\n"
    "    casadi::OptiAdvanced::res() const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_constraints(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_constraints" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->constraints();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_objective(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::MX result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_objective" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->objective();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "MX" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_baked_copy(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SwigValueWrapper< casadi::OptiAdvanced > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_baked_copy" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = ((casadi::OptiAdvanced const *)arg1)->baked_copy();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::OptiAdvanced(static_cast< const casadi::OptiAdvanced& >(result))), SWIGTYPE_p_casadi__OptiAdvanced, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_assert_empty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_assert_empty" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      ((casadi::OptiAdvanced const *)arg1)->assert_empty();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_bake(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_bake" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      (arg1)->bake();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_problem_dirty__get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_problem_dirty__get" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  result = (bool) ((arg1)->problem_dirty_);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_mark_problem_dirty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  bool arg2 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_mark_problem_dirty", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_mark_problem_dirty" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->mark_problem_dirty(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_problem_dirty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_problem_dirty" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = (bool)((casadi::OptiAdvanced const *)arg1)->problem_dirty();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_solver_dirty__get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_solver_dirty__get" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  result = (bool) ((arg1)->solver_dirty_);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_mark_solver_dirty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  bool arg2 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_mark_solver_dirty", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_mark_solver_dirty" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->mark_solver_dirty(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_solver_dirty(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_solver_dirty" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = (bool)((casadi::OptiAdvanced const *)arg1)->solver_dirty();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_solved__get(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_solved__get" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  result = (bool) ((arg1)->solved_);
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_mark_solved(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  bool arg2 = (bool) true ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiAdvanced_mark_solved", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_mark_solved" "', argument " "1"" of type '" "casadi::OptiAdvanced *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      (arg1)->mark_solved(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_solved(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_solved" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = (bool)((casadi::OptiAdvanced const *)arg1)->solved();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "bool" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_assert_solved(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_assert_solved" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      ((casadi::OptiAdvanced const *)arg1)->assert_solved();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_assert_baked(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_assert_baked" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      ((casadi::OptiAdvanced const *)arg1)->assert_baked();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiAdvanced_instance_number(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = (casadi::OptiAdvanced *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi_int result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiAdvanced, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiAdvanced_instance_number" "', argument " "1"" of type '" "casadi::OptiAdvanced const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    try {
      result = (casadi_int)((casadi::OptiAdvanced const *)arg1)->instance_number();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "int" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_OptiAdvanced__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiAdvanced *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::OptiAdvanced *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__OptiAdvanced,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_OptiAdvanced" "', argument " "1"" of type '" "casadi::OptiAdvanced const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OptiAdvanced" "', argument " "1"" of type '" "casadi::OptiAdvanced const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiAdvanced * >(argp1);
  {
    result = (casadi::OptiAdvanced *)new casadi::OptiAdvanced((casadi::OptiAdvanced const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__OptiAdvanced, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_OptiAdvanced(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_OptiAdvanced", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__OptiAdvanced, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OptiAdvanced__SWIG_2(self, argc, argv);
    }
  }
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__Opti, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OptiAdvanced__SWIG_0(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_OptiAdvanced'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::OptiAdvanced::OptiAdvanced(casadi::Opti const &)\n"
    "    casadi::OptiAdvanced::OptiAdvanced(casadi::OptiAdvanced const &)\n");
  return 0;
}


SWIGINTERN PyObject *OptiAdvanced_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__OptiAdvanced, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *OptiAdvanced_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

SWIGINTERN PyObject *_wrap_OptiSol_type_name(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::string result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol_type_name" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  {
    try {
      result = ((casadi::OptiSol const *)arg1)->type_name();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiSol_disp(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  std::ostream *arg2 = 0 ;
  bool arg3 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  arg2 = &casadi::uout();
  if (!SWIG_Python_UnpackTuple(args, "OptiSol_disp", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol_disp" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "bool" "'.");
  }
  {
    try {
      ((casadi::OptiSol const *)arg1)->disp(*arg2,arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiSol_str(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  bool arg2 = (bool) false ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  std::string result;
  
  if (!SWIG_Python_UnpackTuple(args, "OptiSol_str", 1, 2, swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol_str" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  if (swig_obj[1]) {
    if (!casadi::to_val(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "bool" "'.");
  }
  {
    try {
      result = ((casadi::OptiSol const *)arg1)->get_str(arg2);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "str" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiSol_value__SWIG_0(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  casadi::MX *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > const &arg3_defvalue = std::vector< casadi::MX >() ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::MX m2 ;
  std::vector< casadi::MX > m3 ;
  casadi::native_DM result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol_value" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "MX" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  }
  {
    try {
      result = ((casadi::OptiSol const *)arg1)->value((casadi::MX const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = full_or_sparse(result, true))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type 'double'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiSol_value__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  casadi::DM *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > const &arg3_defvalue = std::vector< casadi::MX >() ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< double > m2 ;
  std::vector< casadi::MX > m3 ;
  casadi::native_DM result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol_value" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "DM" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  }
  {
    try {
      result = ((casadi::OptiSol const *)arg1)->value((casadi::DM const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = full_or_sparse(result, true))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type 'double'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiSol_value__SWIG_2(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  casadi::SX *arg2 = 0 ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > const &arg3_defvalue = std::vector< casadi::MX >() ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > *arg3 = (std::vector< casadi::MX,std::allocator< casadi::MX > > *) &arg3_defvalue ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::Matrix< casadi::SXElem > m2 ;
  std::vector< casadi::MX > m3 ;
  casadi::native_DM result;
  
  if ((nobjs < 2) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol_value" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  arg2 = &m2;
  if (!casadi::to_ptr(swig_obj[1], &arg2)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 2 to type '" "SX" "'.");
  if (swig_obj[2]) {
    arg3 = &m3;
    if (!casadi::to_ptr(swig_obj[2], &arg3)) SWIG_exception_fail(SWIG_TypeError,"Failed to convert input 3 to type '" "[" "MX" "]" "'.");
  }
  {
    try {
      result = ((casadi::OptiSol const *)arg1)->value((casadi::SX const &)*arg2,(std::vector< casadi::MX,std::allocator< casadi::MX > > const &)*arg3);
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = full_or_sparse(result, true))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type 'double'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiSol_value(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "OptiSol_value", 0, 3, argv))) SWIG_fail;
  --argc;
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__OptiSol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<double> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_OptiSol_value__SWIG_1(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          return _wrap_OptiSol_value__SWIG_1(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__OptiSol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::Matrix<casadi::SXElem> **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_OptiSol_value__SWIG_2(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          return _wrap_OptiSol_value__SWIG_2(self, argc, argv);
        }
      }
    }
  }
  if ((argc >= 2) && (argc <= 3)) {
    int _v;
    void *vptr = 0;
    int res = SWIG_ConvertPtr(argv[0], &vptr, SWIGTYPE_p_casadi__OptiSol, 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      _v = casadi::to_ptr(argv[1], static_cast< casadi::MX **>(0));
      if (_v) {
        if (argc <= 2) {
          return _wrap_OptiSol_value__SWIG_0(self, argc, argv);
        }
        _v = casadi::to_ptr(argv[2], static_cast< std::vector<casadi::MX> **>(0));
        if (_v) {
          return _wrap_OptiSol_value__SWIG_0(self, argc, argv);
        }
      }
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'OptiSol_value'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::OptiSol::value(casadi::MX const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &) const\n"
    "    casadi::OptiSol::value(casadi::DM const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &) const\n"
    "    casadi::OptiSol::value(casadi::SX const &,std::vector< casadi::MX,std::allocator< casadi::MX > > const &) const\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_OptiSol_value_variables(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol_value_variables" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  {
    try {
      result = ((casadi::OptiSol const *)arg1)->value_variables();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiSol_value_parameters(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  std::vector< casadi::MX,std::allocator< casadi::MX > > result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol_value_parameters" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  {
    try {
      result = ((casadi::OptiSol const *)arg1)->value_parameters();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "[" "MX" "]" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiSol_stats(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Dict result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol_stats" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  {
    try {
      result = ((casadi::OptiSol const *)arg1)->stats();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  if(!(resultobj = casadi::from_ref(result))) SWIG_exception_fail(SWIG_TypeError,"Failed to convert output to type '" "dict" "'.");
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_OptiSol__opti(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  casadi::Opti result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OptiSol__opti" "', argument " "1"" of type '" "casadi::OptiSol const *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  {
    try {
      result = ((casadi::OptiSol const *)arg1)->opti();
    } catch(const std::exception& e) {
      SWIG_exception(SWIG_RuntimeError, e.what());
    }
  }
  resultobj = SWIG_NewPointerObj((new casadi::Opti(static_cast< const casadi::Opti& >(result))), SWIGTYPE_p_casadi__Opti, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_OptiSol__SWIG_1(PyObject *SWIGUNUSEDPARM(self), Py_ssize_t nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  casadi::OptiSol *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_casadi__OptiSol,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_OptiSol" "', argument " "1"" of type '" "casadi::OptiSol const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_OptiSol" "', argument " "1"" of type '" "casadi::OptiSol const &""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  {
    result = (casadi::OptiSol *)new casadi::OptiSol((casadi::OptiSol const &)*arg1);
  }
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_casadi__OptiSol, SWIG_POINTER_NEW |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_new_OptiSol(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args, "new_OptiSol", 0, 1, argv))) SWIG_fail;
  --argc;
  if (argc == 1) {
    int _v;
    int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_casadi__OptiSol, SWIG_POINTER_NO_NULL | 0);
    _v = SWIG_CheckState(res);
    if (_v) {
      return _wrap_new_OptiSol__SWIG_1(self, argc, argv);
    }
  }
  
fail:
  SWIG_Python_RaiseOrModifyTypeError("Wrong number or type of arguments for overloaded function 'new_OptiSol'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    casadi::OptiSol::OptiSol(casadi::OptiSol const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_OptiSol(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  casadi::OptiSol *arg1 = (casadi::OptiSol *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1,SWIGTYPE_p_casadi__OptiSol, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OptiSol" "', argument " "1"" of type '" "casadi::OptiSol *""'"); 
  }
  arg1 = reinterpret_cast< casadi::OptiSol * >(argp1);
  {
    delete arg1;
  }
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *OptiSol_swigregister(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *obj;
  if (!SWIG_Python_UnpackTuple(args, "swigregister", 1, 1, &obj)) return NULL;
  SWIG_TypeNewClientData(SWIGTYPE_p_casadi__OptiSol, SWIG_NewClientData(obj));
  return SWIG_Py_Void();
}

SWIGINTERN PyObject *OptiSol_swiginit(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  return SWIG_Python_InitShadowInstance(args);
}

static PyMethodDef SwigMethods[] = {
	 { "SWIG_PyInstanceMethod_New", SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { "delete_SwigPyIterator", _wrap_delete_SwigPyIterator, METH_O, "delete_SwigPyIterator(SwigPyIterator self)"},
	 { "SwigPyIterator_value", _wrap_SwigPyIterator_value, METH_O, "SwigPyIterator_value(SwigPyIterator self) -> PyObject *"},
	 { "SwigPyIterator_incr", _wrap_SwigPyIterator_incr, METH_VARARGS, "SwigPyIterator_incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"},
	 { "SwigPyIterator_decr", _wrap_SwigPyIterator_decr, METH_VARARGS, "SwigPyIterator_decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"},
	 { "SwigPyIterator_distance", _wrap_SwigPyIterator_distance, METH_VARARGS, "SwigPyIterator_distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"},
	 { "SwigPyIterator_equal", _wrap_SwigPyIterator_equal, METH_VARARGS, "SwigPyIterator_equal(SwigPyIterator self, SwigPyIterator x) -> bool"},
	 { "SwigPyIterator_copy", _wrap_SwigPyIterator_copy, METH_O, "SwigPyIterator_copy(SwigPyIterator self) -> SwigPyIterator"},
	 { "SwigPyIterator_next", _wrap_SwigPyIterator_next, METH_O, "SwigPyIterator_next(SwigPyIterator self) -> PyObject *"},
	 { "SwigPyIterator___next__", _wrap_SwigPyIterator___next__, METH_O, "SwigPyIterator___next__(SwigPyIterator self) -> PyObject *"},
	 { "SwigPyIterator_previous", _wrap_SwigPyIterator_previous, METH_O, "SwigPyIterator_previous(SwigPyIterator self) -> PyObject *"},
	 { "SwigPyIterator_advance", _wrap_SwigPyIterator_advance, METH_VARARGS, "SwigPyIterator_advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { "SwigPyIterator___eq__", _wrap_SwigPyIterator___eq__, METH_VARARGS, "SwigPyIterator___eq__(SwigPyIterator self, SwigPyIterator x) -> bool"},
	 { "SwigPyIterator___ne__", _wrap_SwigPyIterator___ne__, METH_VARARGS, "SwigPyIterator___ne__(SwigPyIterator self, SwigPyIterator x) -> bool"},
	 { "SwigPyIterator___iadd__", _wrap_SwigPyIterator___iadd__, METH_VARARGS, "SwigPyIterator___iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { "SwigPyIterator___isub__", _wrap_SwigPyIterator___isub__, METH_VARARGS, "SwigPyIterator___isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { "SwigPyIterator___add__", _wrap_SwigPyIterator___add__, METH_VARARGS, "SwigPyIterator___add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"},
	 { "SwigPyIterator___sub__", _wrap_SwigPyIterator___sub__, METH_VARARGS, "\n"
		"SwigPyIterator___sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator\n"
		"SwigPyIterator___sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t\n"
		""},
	 { "SwigPyIterator_swigregister", SwigPyIterator_swigregister, METH_O, NULL},
	 { "new_PrintableCommon", _wrap_new_PrintableCommon, METH_VARARGS, "\n"
		"PrintableCommon()\n"
		"new_PrintableCommon(PrintableCommon other) -> PrintableCommon\n"
		""},
	 { "delete_PrintableCommon", _wrap_delete_PrintableCommon, METH_O, "delete_PrintableCommon(PrintableCommon self)"},
	 { "PrintableCommon_swigregister", PrintableCommon_swigregister, METH_O, NULL},
	 { "PrintableCommon_swiginit", PrintableCommon_swiginit, METH_VARARGS, NULL},
	 { "SharedObject_class_name", _wrap_SharedObject_class_name, METH_O, "\n"
		"SharedObject_class_name(SharedObject self) -> std::string\n"
		"\n"
		"\n"
		"Get class name.\n"
		"\n"
		"\n"
		""},
	 { "SharedObject_disp", _wrap_SharedObject_disp, METH_VARARGS, "\n"
		"SharedObject_disp(SharedObject self, bool more=False)\n"
		"\n"
		"\n"
		"Print a description of the object.\n"
		"\n"
		"\n"
		""},
	 { "SharedObject_str", _wrap_SharedObject_str, METH_VARARGS, "\n"
		"SharedObject_str(SharedObject self, bool more=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation.\n"
		"\n"
		"\n"
		""},
	 { "SharedObject_print_ptr", _wrap_SharedObject_print_ptr, METH_O, "\n"
		"SharedObject_print_ptr(SharedObject self)\n"
		"\n"
		"\n"
		"[INTERNAL]  Print the pointer to the internal class\n"
		"\n"
		"\n"
		""},
	 { "SharedObject_is_null", _wrap_SharedObject_is_null, METH_O, "\n"
		"SharedObject_is_null(SharedObject self) -> bool\n"
		"\n"
		"\n"
		"Is a null pointer?\n"
		"\n"
		"\n"
		""},
	 { "SharedObject___hash__", _wrap_SharedObject___hash__, METH_O, "\n"
		"SharedObject___hash__(SharedObject self) -> casadi_int\n"
		"\n"
		"\n"
		"Returns a number that is unique for a given Node. If the Object does not\n"
		"point to any node, \"0\" is returned.\n"
		"\n"
		"\n"
		""},
	 { "new_SharedObject", _wrap_new_SharedObject, METH_VARARGS, "\n"
		"SharedObject()\n"
		"new_SharedObject(SharedObject other) -> SharedObject\n"
		""},
	 { "delete_SharedObject", _wrap_delete_SharedObject, METH_O, "delete_SharedObject(SharedObject self)"},
	 { "SharedObject_swigregister", SharedObject_swigregister, METH_O, NULL},
	 { "SharedObject_swiginit", SharedObject_swiginit, METH_VARARGS, NULL},
	 { "WeakRef_shared", _wrap_WeakRef_shared, METH_O, "\n"
		"WeakRef_shared(WeakRef self) -> SharedObject\n"
		"\n"
		"\n"
		"Get a shared (owning) reference.\n"
		"\n"
		"\n"
		""},
	 { "WeakRef_alive", _wrap_WeakRef_alive, METH_O, "\n"
		"WeakRef_alive(WeakRef self) -> bool\n"
		"\n"
		"\n"
		"Check if alive.\n"
		"\n"
		"\n"
		""},
	 { "new_WeakRef", _wrap_new_WeakRef, METH_VARARGS, "\n"
		"WeakRef(int dummy=0)\n"
		"WeakRef(SharedObject shared)\n"
		"new_WeakRef(WeakRef other) -> WeakRef\n"
		"\n"
		"\n"
		"Construct from a shared object (also implicit type conversion)\n"
		"\n"
		"\n"
		""},
	 { "delete_WeakRef", _wrap_delete_WeakRef, METH_O, "delete_WeakRef(WeakRef self)"},
	 { "WeakRef_swigregister", WeakRef_swigregister, METH_O, NULL},
	 { "WeakRef_swiginit", WeakRef_swiginit, METH_VARARGS, NULL},
	 { "complement", _wrap_complement, METH_VARARGS, "\n"
		"complement(std::vector< casadi_int,std::allocator< casadi_int > > const & v, casadi_int size) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Returns the list of all i in [0, size[ not found in supplied list.\n"
		"\n"
		"The supplied vector may contain duplicates and may be non-monotonous The\n"
		"supplied vector will be checked for bounds The result vector is guaranteed\n"
		"to be monotonously increasing\n"
		"\n"
		"\n"
		""},
	 { "lookupvector", _wrap_lookupvector, METH_VARARGS, "\n"
		"lookupvector(std::vector< casadi_int,std::allocator< casadi_int > > const & v, casadi_int size) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"lookupvector(std::vector< casadi_int,std::allocator< casadi_int > > const & v) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Returns a vector for quickly looking up entries of supplied list.\n"
		"\n"
		"lookupvector[i]!=-1 <=> v contains i v[lookupvector[i]] == i <=> v contains\n"
		"i\n"
		"\n"
		"Duplicates are treated by looking up last occurrence\n"
		"\n"
		"\n"
		""},
	 { "temporary_file", _wrap_temporary_file, METH_VARARGS, "temporary_file(std::string const & prefix, std::string const & suffix) -> std::string"},
	 { "normalized_setup", _wrap_normalized_setup, METH_VARARGS, "\n"
		"normalized_setup(std::istream & stream)\n"
		"normalized_setup()\n"
		""},
	 { "normalized_out", _wrap_normalized_out, METH_O, "normalized_out(double val)"},
	 { "normalized_in", _wrap_normalized_in, METH_VARARGS, "normalized_in(std::istream & stream, double & ret) -> int"},
	 { "GenericType_serialize", _wrap_GenericType_serialize, METH_VARARGS, "\n"
		"GenericType_serialize(GenericType self, casadi::SerializingStream & s)\n"
		"\n"
		"\n"
		"Serialize an object.\n"
		"\n"
		"\n"
		""},
	 { "GenericType_deserialize", _wrap_GenericType_deserialize, METH_O, "GenericType_deserialize(casadi::DeserializingStream & s) -> GenericType"},
	 { "new_GenericType", _wrap_new_GenericType, METH_VARARGS, "\n"
		"GenericType()\n"
		"new_GenericType(GenericType other) -> GenericType\n"
		""},
	 { "delete_GenericType", _wrap_delete_GenericType, METH_O, "delete_GenericType(GenericType self)"},
	 { "GenericType_swigregister", GenericType_swigregister, METH_O, NULL},
	 { "GenericType_swiginit", GenericType_swiginit, METH_VARARGS, NULL},
	 { "new_SparsityInterfaceCommon", _wrap_new_SparsityInterfaceCommon, METH_VARARGS, "\n"
		"SparsityInterfaceCommon()\n"
		"new_SparsityInterfaceCommon(SparsityInterfaceCommon other) -> SparsityInterfaceCommon\n"
		""},
	 { "delete_SparsityInterfaceCommon", _wrap_delete_SparsityInterfaceCommon, METH_O, "delete_SparsityInterfaceCommon(SparsityInterfaceCommon self)"},
	 { "SparsityInterfaceCommon_swigregister", SparsityInterfaceCommon_swigregister, METH_O, NULL},
	 { "SparsityInterfaceCommon_swiginit", SparsityInterfaceCommon_swiginit, METH_VARARGS, NULL},
	 { "Sparsity_scalar", _wrap_Sparsity_scalar, METH_VARARGS, "\n"
		"Sparsity_scalar(bool dense_scalar=True) -> Sparsity\n"
		"\n"
		"\n"
		"Create a scalar sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_dense", _wrap_Sparsity_dense, METH_VARARGS, "\n"
		"Sparsity_dense(casadi_int nrow, casadi_int ncol=1) -> Sparsity\n"
		"Sparsity_dense(std::pair< casadi_int,casadi_int > const & rc) -> Sparsity\n"
		"\n"
		"\n"
		"Create a dense rectangular sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_unit", _wrap_Sparsity_unit, METH_VARARGS, "\n"
		"Sparsity_unit(casadi_int n, casadi_int el) -> Sparsity\n"
		"\n"
		"\n"
		"Create the sparsity pattern for a unit vector of length n and a nonzero on\n"
		"position el.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_upper", _wrap_Sparsity_upper, METH_O, "Sparsity_upper(casadi_int n) -> Sparsity"},
	 { "Sparsity_lower", _wrap_Sparsity_lower, METH_O, "Sparsity_lower(casadi_int n) -> Sparsity"},
	 { "Sparsity_diag", _wrap_Sparsity_diag, METH_VARARGS, "\n"
		"Sparsity_diag(casadi_int nrow) -> Sparsity\n"
		"Sparsity_diag(casadi_int nrow, casadi_int ncol) -> Sparsity\n"
		"Sparsity_diag(std::pair< casadi_int,casadi_int > const & rc) -> Sparsity\n"
		"\n"
		"\n"
		"Create diagonal sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_band", _wrap_Sparsity_band, METH_VARARGS, "Sparsity_band(casadi_int n, casadi_int p) -> Sparsity"},
	 { "Sparsity_banded", _wrap_Sparsity_banded, METH_VARARGS, "Sparsity_banded(casadi_int n, casadi_int p) -> Sparsity"},
	 { "Sparsity_rowcol", _wrap_Sparsity_rowcol, METH_VARARGS, "Sparsity_rowcol(std::vector< casadi_int,std::allocator< casadi_int > > const & row, std::vector< casadi_int,std::allocator< casadi_int > > const & col, casadi_int nrow, casadi_int ncol) -> Sparsity"},
	 { "Sparsity_triplet", _wrap_Sparsity_triplet, METH_VARARGS, "\n"
		"Sparsity_triplet(casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & row, std::vector< casadi_int,std::allocator< casadi_int > > const & col, bool invert_mapping) -> Sparsity\n"
		"Sparsity_triplet(casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & row, std::vector< casadi_int,std::allocator< casadi_int > > const & col) -> Sparsity\n"
		""},
	 { "Sparsity_nonzeros", _wrap_Sparsity_nonzeros, METH_VARARGS, "Sparsity_nonzeros(casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & nz, bool ind1=False) -> Sparsity"},
	 { "Sparsity_compressed", _wrap_Sparsity_compressed, METH_VARARGS, "\n"
		"Sparsity_compressed(std::vector< casadi_int,std::allocator< casadi_int > > const & v, bool order_rows=False) -> Sparsity\n"
		"\n"
		"\n"
		"Create from a single vector containing the pattern in compressed column\n"
		"storage format: The format: The first two entries are the number of rows\n"
		"(nrow) and columns (ncol) The next ncol+1 entries are the column offsets\n"
		"(colind). Note that the last element, colind[ncol], gives the number of\n"
		"nonzeros The last colind[ncol] entries are the row indices\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_get_diag", _wrap_Sparsity_get_diag, METH_O, "\n"
		"Sparsity_get_diag(Sparsity self) -> Sparsity\n"
		"\n"
		"\n"
		"Get the diagonal of the matrix/create a diagonal matrix (mapping will\n"
		"contain the nonzero mapping) When the input is square, the diagonal elements\n"
		"are returned. If the input is vector-like, a diagonal matrix is constructed\n"
		"with it.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_compress", _wrap_Sparsity_compress, METH_O, "\n"
		"Sparsity_compress(Sparsity self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Compress a sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_equal", _wrap_Sparsity_is_equal, METH_VARARGS, "\n"
		"Sparsity_is_equal(Sparsity self, Sparsity y) -> bool\n"
		"Sparsity_is_equal(Sparsity self, casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & colind, std::vector< casadi_int,std::allocator< casadi_int > > const & row) -> bool\n"
		""},
	 { "Sparsity___eq__", _wrap_Sparsity___eq__, METH_VARARGS, "Sparsity___eq__(Sparsity self, Sparsity y) -> bool"},
	 { "Sparsity___ne__", _wrap_Sparsity___ne__, METH_VARARGS, "Sparsity___ne__(Sparsity self, Sparsity y) -> bool"},
	 { "Sparsity_is_stacked", _wrap_Sparsity_is_stacked, METH_VARARGS, "\n"
		"Sparsity_is_stacked(Sparsity self, Sparsity y, casadi_int n) -> bool\n"
		"\n"
		"\n"
		"Check if pattern is horizontal repeat of another.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_size1", _wrap_Sparsity_size1, METH_O, "\n"
		"Sparsity_size1(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of rows.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_rows", _wrap_Sparsity_rows, METH_O, "\n"
		"Sparsity_rows(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of rows, Octave-style syntax.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_size2", _wrap_Sparsity_size2, METH_O, "\n"
		"Sparsity_size2(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of columns.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_columns", _wrap_Sparsity_columns, METH_O, "\n"
		"Sparsity_columns(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of columns, Octave-style syntax.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_numel", _wrap_Sparsity_numel, METH_O, "\n"
		"Sparsity_numel(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"The total number of elements, including structural zeros, i.e.\n"
		"size2()*size1() Beware of overflow.\n"
		"\n"
		"See:   nnz()\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_density", _wrap_Sparsity_density, METH_O, "\n"
		"Sparsity_density(Sparsity self) -> double\n"
		"\n"
		"\n"
		"The percentage of nonzero Equivalent to (100.0 * nnz())/numel(), but avoids\n"
		"overflow.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_empty", _wrap_Sparsity_is_empty, METH_VARARGS, "\n"
		"Sparsity_is_empty(Sparsity self, bool both=False) -> bool\n"
		"\n"
		"\n"
		"Check if the sparsity is empty.\n"
		"\n"
		"A sparsity is considered empty if one of the dimensions is zero (or\n"
		"optionally both dimensions)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_nnz", _wrap_Sparsity_nnz, METH_O, "\n"
		"Sparsity_nnz(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of (structural) non-zeros.\n"
		"\n"
		"See:   numel()\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_nnz_upper", _wrap_Sparsity_nnz_upper, METH_VARARGS, "\n"
		"Sparsity_nnz_upper(Sparsity self, bool strictly=False) -> casadi_int\n"
		"\n"
		"\n"
		"Number of non-zeros in the upper triangular half, i.e. the number of\n"
		"elements (i, j) with j>=i.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_nnz_lower", _wrap_Sparsity_nnz_lower, METH_VARARGS, "\n"
		"Sparsity_nnz_lower(Sparsity self, bool strictly=False) -> casadi_int\n"
		"\n"
		"\n"
		"Number of non-zeros in the lower triangular half, i.e. the number of\n"
		"elements (i, j) with j<=i.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_nnz_diag", _wrap_Sparsity_nnz_diag, METH_O, "\n"
		"Sparsity_nnz_diag(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Number of non-zeros on the diagonal, i.e. the number of elements (i, j) with\n"
		"j==i.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_bw_upper", _wrap_Sparsity_bw_upper, METH_O, "\n"
		"Sparsity_bw_upper(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Upper half-bandwidth.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_bw_lower", _wrap_Sparsity_bw_lower, METH_O, "\n"
		"Sparsity_bw_lower(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Lower half-bandwidth.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_size", _wrap_Sparsity_size, METH_VARARGS, "\n"
		"Sparsity_size(Sparsity self) -> std::pair< casadi_int,casadi_int >\n"
		"Sparsity_size(Sparsity self, casadi_int axis) -> casadi_int\n"
		"\n"
		"\n"
		"Get the shape.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_info", _wrap_Sparsity_info, METH_O, "\n"
		"Sparsity_info(Sparsity self) -> casadi::Dict\n"
		"\n"
		"\n"
		"Obtain information about sparsity\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_to_file", _wrap_Sparsity_to_file, METH_VARARGS, "\n"
		"Sparsity_to_file(Sparsity self, std::string const & filename, std::string const & format_hint=\"\")\n"
		"\n"
		"\n"
		"Export sparsity pattern to file\n"
		"\n"
		"Supported formats: .mtx Matrix Market\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_from_file", _wrap_Sparsity_from_file, METH_VARARGS, "Sparsity_from_file(std::string const & filename, std::string const & format_hint=\"\") -> Sparsity"},
	 { "Sparsity_serialize", _wrap_Sparsity_serialize, METH_VARARGS, "\n"
		"Sparsity_serialize(Sparsity self) -> std::string\n"
		"Sparsity_serialize(Sparsity self, casadi::SerializingStream & s)\n"
		"\n"
		"\n"
		"Serialize.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_deserialize", _wrap_Sparsity_deserialize, METH_VARARGS, "\n"
		"Sparsity_deserialize(std::istream & stream) -> Sparsity\n"
		"Sparsity_deserialize(std::string const & s) -> Sparsity\n"
		"Sparsity_deserialize(casadi::DeserializingStream & s) -> Sparsity\n"
		""},
	 { "Sparsity_colind", _wrap_Sparsity_colind, METH_VARARGS, "\n"
		"Sparsity_colind(Sparsity self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"Sparsity_colind(Sparsity self, casadi_int cc) -> casadi_int\n"
		"\n"
		"\n"
		"Get the column index for each column Together with the row-vector, one\n"
		"obtains the sparsity pattern in the column compressed format.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_row", _wrap_Sparsity_row, METH_VARARGS, "\n"
		"Sparsity_row(Sparsity self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"Sparsity_row(Sparsity self, casadi_int el) -> casadi_int\n"
		"\n"
		"\n"
		"Get the row for each non-zero entry Together with the column-vector, this\n"
		"vector gives the sparsity of the matrix in sparse triplet format, and\n"
		"together with the colind vector, one obtains the sparsity in column\n"
		"compressed format.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_get_col", _wrap_Sparsity_get_col, METH_O, "\n"
		"Sparsity_get_col(Sparsity self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Get the column for each non-zero entry Together with the row-vector, this\n"
		"vector gives the sparsity of the matrix in sparse triplet format, i.e. the\n"
		"column and row for each non-zero elements.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_resize", _wrap_Sparsity_resize, METH_VARARGS, "\n"
		"Sparsity_resize(Sparsity self, casadi_int nrow, casadi_int ncol)\n"
		"\n"
		"\n"
		"Resize.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_add_nz", _wrap_Sparsity_add_nz, METH_VARARGS, "\n"
		"Sparsity_add_nz(Sparsity self, casadi_int rr, casadi_int cc) -> casadi_int\n"
		"\n"
		"\n"
		"Get the index of a non-zero element Add the element if it does not exist and\n"
		"copy object if it's not unique.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_has_nz", _wrap_Sparsity_has_nz, METH_VARARGS, "\n"
		"Sparsity_has_nz(Sparsity self, casadi_int rr, casadi_int cc) -> bool\n"
		"\n"
		"\n"
		"Returns true if the pattern has a non-zero at location rr, cc.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_get_nz", _wrap_Sparsity_get_nz, METH_VARARGS, "\n"
		"Sparsity_get_nz(Sparsity self, casadi_int rr, casadi_int cc) -> casadi_int\n"
		"Sparsity_get_nz(Sparsity self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"Sparsity_get_nz(Sparsity self, std::vector< casadi_int,std::allocator< casadi_int > > & INOUT)\n"
		"\n"
		"\n"
		"Get a set of non-zero element return -1 if the element does not exist.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_get_lower", _wrap_Sparsity_get_lower, METH_O, "\n"
		"Sparsity_get_lower(Sparsity self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Get nonzeros in lower triangular part.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_get_upper", _wrap_Sparsity_get_upper, METH_O, "\n"
		"Sparsity_get_upper(Sparsity self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Get nonzeros in upper triangular part.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_get_ccs", _wrap_Sparsity_get_ccs, METH_O, "\n"
		"Sparsity_get_ccs(Sparsity self)\n"
		"\n"
		"\n"
		"Get the sparsity in compressed column storage (CCS) format.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_get_crs", _wrap_Sparsity_get_crs, METH_O, "\n"
		"Sparsity_get_crs(Sparsity self)\n"
		"\n"
		"\n"
		"Get the sparsity in compressed row storage (CRS) format.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_get_triplet", _wrap_Sparsity_get_triplet, METH_O, "\n"
		"Sparsity_get_triplet(Sparsity self)\n"
		"\n"
		"\n"
		"Get the sparsity in sparse triplet format.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_sub", _wrap_Sparsity_sub, METH_VARARGS, "\n"
		"Sparsity_sub(Sparsity self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False) -> Sparsity\n"
		"Sparsity_sub(Sparsity self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, Sparsity sp, bool ind1=False) -> Sparsity\n"
		"\n"
		"\n"
		"Get a submatrix.\n"
		"\n"
		"Returns the sparsity of the submatrix, with a mapping such that submatrix[k]\n"
		"= originalmatrix[mapping[k]]\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_transpose", _wrap_Sparsity_transpose, METH_VARARGS, "\n"
		"Sparsity_transpose(Sparsity self, bool invert_mapping=False) -> Sparsity\n"
		"\n"
		"\n"
		"Transpose the matrix and get the reordering of the non-zero entries.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"mapping:  the non-zeros of the original matrix for each non-zero of the new\n"
		"matrix\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_transpose", _wrap_Sparsity_is_transpose, METH_VARARGS, "\n"
		"Sparsity_is_transpose(Sparsity self, Sparsity y) -> bool\n"
		"\n"
		"\n"
		"Check if the sparsity is the transpose of another.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_reshape", _wrap_Sparsity_is_reshape, METH_VARARGS, "\n"
		"Sparsity_is_reshape(Sparsity self, Sparsity y) -> bool\n"
		"\n"
		"\n"
		"Check if the sparsity is a reshape of another.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_combine", _wrap_Sparsity_combine, METH_VARARGS, "\n"
		"Sparsity_combine(Sparsity self, Sparsity y, bool f0x_is_zero, bool function0_is_zero) -> Sparsity\n"
		"\n"
		"\n"
		"Combine two sparsity patterns Returns the new sparsity pattern as well as a\n"
		"mapping with the same length as the number of non-zero elements The mapping\n"
		"matrix contains the arguments for each nonzero, the first bit indicates if\n"
		"the first argument is nonzero, the second bit indicates if the second\n"
		"argument is nonzero (note that none of, one of or both of the arguments can\n"
		"be nonzero)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_unite", _wrap_Sparsity_unite, METH_VARARGS, "\n"
		"Sparsity_unite(Sparsity self, Sparsity y) -> Sparsity\n"
		"\n"
		"\n"
		"Union of two sparsity patterns.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity___add__", _wrap_Sparsity___add__, METH_VARARGS, "Sparsity___add__(Sparsity self, Sparsity b) -> Sparsity"},
	 { "Sparsity_intersect", _wrap_Sparsity_intersect, METH_VARARGS, "\n"
		"Sparsity_intersect(Sparsity self, Sparsity y) -> Sparsity\n"
		"\n"
		"\n"
		"Intersection of two sparsity patterns Returns the new sparsity pattern as\n"
		"well as a mapping with the same length as the number of non-zero elements\n"
		"The value is 1 if the non-zero comes from the first (i.e. this) object, 2 if\n"
		"it is from the second and 3 (i.e. 1 | 2) if from both.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity___mul__", _wrap_Sparsity___mul__, METH_VARARGS, "Sparsity___mul__(Sparsity self, Sparsity b) -> Sparsity"},
	 { "Sparsity_is_subset", _wrap_Sparsity_is_subset, METH_VARARGS, "\n"
		"Sparsity_is_subset(Sparsity self, Sparsity rhs) -> bool\n"
		"\n"
		"\n"
		"Is subset?\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_pattern_inverse", _wrap_Sparsity_pattern_inverse, METH_O, "\n"
		"Sparsity_pattern_inverse(Sparsity self) -> Sparsity\n"
		"\n"
		"\n"
		"Take the inverse of a sparsity pattern; flip zeros and non-zeros.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_enlarge", _wrap_Sparsity_enlarge, METH_VARARGS, "\n"
		"Sparsity_enlarge(Sparsity self, casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False)\n"
		"\n"
		"\n"
		"Enlarge matrix Make the matrix larger by inserting empty rows and columns,\n"
		"keeping the existing non-zeros.\n"
		"\n"
		"For the matrices A to B A(m, n) length(jj)=m , length(ii)=n B(nrow, ncol)\n"
		"\n"
		"A=enlarge(m, n, ii, jj) makes sure that\n"
		"\n"
		"B[jj, ii] == A\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_enlargeRows", _wrap_Sparsity_enlargeRows, METH_VARARGS, "\n"
		"Sparsity_enlargeRows(Sparsity self, casadi_int nrow, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, bool ind1=False)\n"
		"\n"
		"\n"
		"Enlarge the matrix along the first dimension (i.e. insert rows)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_enlargeColumns", _wrap_Sparsity_enlargeColumns, METH_VARARGS, "\n"
		"Sparsity_enlargeColumns(Sparsity self, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False)\n"
		"\n"
		"\n"
		"Enlarge the matrix along the second dimension (i.e. insert columns)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_makeDense", _wrap_Sparsity_makeDense, METH_O, "\n"
		"Sparsity_makeDense(Sparsity self) -> Sparsity\n"
		"\n"
		"\n"
		"Make a patten dense.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_erase", _wrap_Sparsity_erase, METH_VARARGS, "\n"
		"Sparsity_erase(Sparsity self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"Sparsity_erase(Sparsity self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, bool ind1=False) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Erase rows and/or columns of a matrix.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_append", _wrap_Sparsity_append, METH_VARARGS, "\n"
		"Sparsity_append(Sparsity self, Sparsity sp)\n"
		"\n"
		"\n"
		"Append another sparsity patten vertically (NOTE: only efficient if vector)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_appendColumns", _wrap_Sparsity_appendColumns, METH_VARARGS, "\n"
		"Sparsity_appendColumns(Sparsity self, Sparsity sp)\n"
		"\n"
		"\n"
		"Append another sparsity patten horizontally.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_scalar", _wrap_Sparsity_is_scalar, METH_VARARGS, "\n"
		"Sparsity_is_scalar(Sparsity self, bool scalar_and_dense=False) -> bool\n"
		"\n"
		"\n"
		"Is scalar?\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_dense", _wrap_Sparsity_is_dense, METH_O, "\n"
		"Sparsity_is_dense(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Is dense?\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_row", _wrap_Sparsity_is_row, METH_O, "\n"
		"Sparsity_is_row(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Check if the pattern is a row vector (i.e. size1()==1)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_column", _wrap_Sparsity_is_column, METH_O, "\n"
		"Sparsity_is_column(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Check if the pattern is a column vector (i.e. size2()==1)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_vector", _wrap_Sparsity_is_vector, METH_O, "\n"
		"Sparsity_is_vector(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Check if the pattern is a row or column vector.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_diag", _wrap_Sparsity_is_diag, METH_O, "\n"
		"Sparsity_is_diag(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Is diagonal?\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_square", _wrap_Sparsity_is_square, METH_O, "\n"
		"Sparsity_is_square(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Is square?\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_symmetric", _wrap_Sparsity_is_symmetric, METH_O, "\n"
		"Sparsity_is_symmetric(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Is symmetric?\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_triu", _wrap_Sparsity_is_triu, METH_O, "\n"
		"Sparsity_is_triu(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Is upper triangular?\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_tril", _wrap_Sparsity_is_tril, METH_O, "\n"
		"Sparsity_is_tril(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Is lower triangular?\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_is_singular", _wrap_Sparsity_is_singular, METH_O, "\n"
		"Sparsity_is_singular(Sparsity self) -> bool\n"
		"\n"
		"\n"
		"Check whether the sparsity-pattern indicates structural singularity.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_rowsSequential", _wrap_Sparsity_rowsSequential, METH_VARARGS, "\n"
		"Sparsity_rowsSequential(Sparsity self, bool strictly=True) -> bool\n"
		"\n"
		"\n"
		"Do the rows appear sequentially on each column.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"strictly:  if true, then do not allow multiple entries\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_removeDuplicates", _wrap_Sparsity_removeDuplicates, METH_VARARGS, "\n"
		"Sparsity_removeDuplicates(Sparsity self, std::vector< casadi_int,std::allocator< casadi_int > > & INOUT)\n"
		"\n"
		"\n"
		"Remove duplicate entries.\n"
		"\n"
		"The same indices will be removed from the mapping vector, which must have\n"
		"the same length as the number of nonzeros\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_etree", _wrap_Sparsity_etree, METH_VARARGS, "\n"
		"Sparsity_etree(Sparsity self, bool ata=False) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Calculate the elimination tree See Direct Methods for Sparse Linear Systems\n"
		"by Davis (2006). If the parameter ata is false, the algorithm is equivalent\n"
		"to MATLAB's etree(A), except that the indices are zero- based. If ata is\n"
		"true, the algorithm is equivalent to MATLAB's etree(A, 'col').\n"
		"\n"
		"The implementation is a modified version of cs_etree in CSparse Copyright(c)\n"
		"Timothy A. Davis, 2006-2009 Licensed as a derivative work under the GNU LGPL\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_ldl", _wrap_Sparsity_ldl, METH_VARARGS, "\n"
		"Sparsity_ldl(Sparsity self, bool amd=True) -> Sparsity\n"
		"\n"
		"\n"
		"Symbolic LDL factorization Returns the sparsity pattern of L^T.\n"
		"\n"
		"The implementation is a modified version of LDL Copyright(c) Timothy A.\n"
		"Davis, 2005-2013 Licensed as a derivative work under the GNU LGPL\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_qr_sparse", _wrap_Sparsity_qr_sparse, METH_VARARGS, "\n"
		"Sparsity_qr_sparse(Sparsity self, bool amd=True)\n"
		"\n"
		"\n"
		"Symbolic QR factorization Returns the sparsity pattern of V (compact\n"
		"representation of Q) and R as well as vectors needed for the numerical\n"
		"factorization and solution. The implementation is a modified version of\n"
		"CSparse Copyright(c) Timothy A. Davis, 2006-2009 Licensed as a derivative\n"
		"work under the GNU LGPL.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_dfs", _wrap_Sparsity_dfs, METH_VARARGS, "\n"
		"Sparsity_dfs(Sparsity self, casadi_int j, casadi_int top, std::vector< casadi_int,std::allocator< casadi_int > > & arg4, std::vector< casadi_int,std::allocator< casadi_int > > & arg5, std::vector< casadi_int,std::allocator< casadi_int > > const & pinv, std::vector< bool,std::allocator< bool > > & arg7) -> casadi_int\n"
		"\n"
		"\n"
		"Depth-first search on the adjacency graph of the sparsity See Direct Methods\n"
		"for Sparse Linear Systems by Davis (2006).\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_scc", _wrap_Sparsity_scc, METH_O, "\n"
		"Sparsity_scc(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Find the strongly connected components of the bigraph defined by the\n"
		"sparsity pattern of a square matrix.\n"
		"\n"
		"See Direct Methods for Sparse Linear Systems by Davis (2006). Returns:\n"
		"Number of components\n"
		"\n"
		"Offset for each components (length: 1 + number of components)\n"
		"\n"
		"Indices for each components, component i has indices index[offset[i]], ...,\n"
		"index[offset[i+1]]\n"
		"\n"
		"In the case that the matrix is symmetric, the result has a particular\n"
		"interpretation: Given a symmetric matrix A and n = A.scc(p, r)\n"
		"\n"
		"=> A[p, p] will appear block-diagonal with n blocks and with the indices of\n"
		"the block boundaries to be found in r.\n"
		"\n"
		"The implementation is a modified version of cs_scc in CSparse Copyright(c)\n"
		"Timothy A. Davis, 2006-2009 Licensed as a derivative work under the GNU LGPL\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_btf", _wrap_Sparsity_btf, METH_O, "\n"
		"Sparsity_btf(Sparsity self) -> casadi_int\n"
		"\n"
		"\n"
		"Calculate the block triangular form (BTF) See Direct Methods for Sparse\n"
		"Linear Systems by Davis (2006).\n"
		"\n"
		"The function computes the Dulmage-Mendelsohn decomposition, which allows you\n"
		"to reorder the rows and columns of a matrix to bring it into block\n"
		"triangular form (BTF).\n"
		"\n"
		"It will not consider the distance of off-diagonal elements to the diagonal:\n"
		"there is no guarantee you will get a block-diagonal matrix if you supply a\n"
		"randomly permuted block-diagonal matrix.\n"
		"\n"
		"If your matrix is symmetrical, this method is of limited use; permutation\n"
		"can make it non-symmetric.\n"
		"\n"
		"See:   scc  The implementation is a modified version of cs_dmperm in CSparse\n"
		"Copyright(c) Timothy A. Davis, 2006-2009 Licensed as a derivative work under\n"
		"the GNU LGPL\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_amd", _wrap_Sparsity_amd, METH_O, "\n"
		"Sparsity_amd(Sparsity self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Approximate minimal degree preordering Fill-reducing ordering applied to the\n"
		"sparsity pattern of a linear system prior to factorization. The system must\n"
		"be symmetric, for an unsymmetric matrix A, first form the square of the\n"
		"pattern, A'*A.\n"
		"\n"
		"The implementation is a modified version of cs_amd in CSparse Copyright(c)\n"
		"Timothy A. Davis, 2006-2009 Licensed as a derivative work under the GNU LGPL\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_find", _wrap_Sparsity_find, METH_VARARGS, "\n"
		"Sparsity_find(Sparsity self, bool ind1=False) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Get the location of all non-zero elements as they would appear in a Dense\n"
		"matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-\n"
		"zeros.\n"
		"\n"
		"k = A.find() A[k] will contain the elements of A that are non-zero in B\n"
		"\n"
		"Inverse of nonzeros.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_uni_coloring", _wrap_Sparsity_uni_coloring, METH_VARARGS, "\n"
		"Sparsity_uni_coloring(Sparsity self, Sparsity AT=casadi::Sparsity(), casadi_int cutoff=std::numeric_limits< casadi_int >::max()) -> Sparsity\n"
		"\n"
		"\n"
		"Perform a unidirectional coloring: A greedy distance-2 coloring algorithm\n"
		"(Algorithm 3.1 in A. H. GEBREMEDHIN, F. MANNE, A. POTHEN)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_star_coloring", _wrap_Sparsity_star_coloring, METH_VARARGS, "\n"
		"Sparsity_star_coloring(Sparsity self, casadi_int ordering=1, casadi_int cutoff=std::numeric_limits< casadi_int >::max()) -> Sparsity\n"
		"\n"
		"\n"
		"Perform a star coloring of a symmetric matrix: A greedy distance-2 coloring\n"
		"algorithm Algorithm 4.1 in What Color Is Your Jacobian? Graph Coloring for\n"
		"Computing Derivatives A. H. GEBREMEDHIN, F. MANNE, A. POTHEN SIAM Rev.,\n"
		"47(4), 629705 (2006)\n"
		"\n"
		"Ordering options: None (0), largest first (1)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_star_coloring2", _wrap_Sparsity_star_coloring2, METH_VARARGS, "\n"
		"Sparsity_star_coloring2(Sparsity self, casadi_int ordering=1, casadi_int cutoff=std::numeric_limits< casadi_int >::max()) -> Sparsity\n"
		"\n"
		"\n"
		"Perform a star coloring of a symmetric matrix: A new greedy distance-2\n"
		"coloring algorithm Algorithm 4.1 in NEW ACYCLIC AND STAR COLORING ALGORITHMS\n"
		"WITH APPLICATION TO COMPUTING HESSIANS A. H. GEBREMEDHIN, A. TARAFDAR, F.\n"
		"MANNE, A. POTHEN SIAM J. SCI. COMPUT. Vol. 29, No. 3, pp. 10421072 (2007)\n"
		"\n"
		"Ordering options: None (0), largest first (1)\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_largest_first", _wrap_Sparsity_largest_first, METH_O, "\n"
		"Sparsity_largest_first(Sparsity self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Order the columns by decreasing degree.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_pmult", _wrap_Sparsity_pmult, METH_VARARGS, "\n"
		"Sparsity_pmult(Sparsity self, std::vector< casadi_int,std::allocator< casadi_int > > const & p, bool permute_rows=True, bool permute_columns=True, bool invert_permutation=False) -> Sparsity\n"
		"\n"
		"\n"
		"Permute rows and/or columns Multiply the sparsity with a permutation matrix\n"
		"from the left and/or from the right P * A * trans(P), A * trans(P) or A *\n"
		"trans(P) with P defined by an index vector containing the row for each col.\n"
		"As an alternative, P can be transposed (inverted).\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_dim", _wrap_Sparsity_dim, METH_VARARGS, "\n"
		"Sparsity_dim(Sparsity self, bool with_nz=False) -> std::string\n"
		"\n"
		"\n"
		"Get the dimension as a string.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_postfix_dim", _wrap_Sparsity_postfix_dim, METH_O, "\n"
		"Sparsity_postfix_dim(Sparsity self) -> std::string\n"
		"\n"
		"\n"
		"Dimension string as a postfix to a name Rules:\n"
		"\n"
		"Dense and scalar: \"\"\n"
		"\n"
		"0-by-0: \"[]\"\n"
		"\n"
		"Dense column vector: \"[5]\"\n"
		"\n"
		"Dense matrix: \"[5x10]\"\n"
		"\n"
		"Otherwise: \"[5x10,3nz]\"\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_repr_el", _wrap_Sparsity_repr_el, METH_VARARGS, "\n"
		"Sparsity_repr_el(Sparsity self, casadi_int k) -> std::string\n"
		"\n"
		"\n"
		"Describe the nonzero location k as a string.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_spy", _wrap_Sparsity_spy, METH_O, "\n"
		"Sparsity_spy(Sparsity self)\n"
		"\n"
		"\n"
		"Print a textual representation of sparsity.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_spy_matlab", _wrap_Sparsity_spy_matlab, METH_VARARGS, "\n"
		"Sparsity_spy_matlab(Sparsity self, std::string const & mfile)\n"
		"\n"
		"\n"
		"Generate a script for Matlab or Octave which visualizes the sparsity using\n"
		"the spy command.\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_export_code", _wrap_Sparsity_export_code, METH_VARARGS, "\n"
		"Sparsity_export_code(Sparsity self, std::string const & lang, casadi::Dict const & options=casadi::Dict())\n"
		"\n"
		"\n"
		"Export matrix in specific language.\n"
		"\n"
		"lang: only 'matlab' supported for now\n"
		"\n"
		"::\n"
		"\n"
		"   * options:\n"
		"   *   inline: Indicates if you want everything on a single line (default: False)\n"
		"   *   name: Name of exported variable (default: 'sp')\n"
		"   *   as_matrix: Matlab does not have a sparsity object. (default: false)\n"
		"  *               With this option true, a numeric matrix will be constructed\n"
		"   * \n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "Sparsity_type_name", _wrap_Sparsity_type_name, METH_NOARGS, "Sparsity_type_name() -> std::string"},
	 { "Sparsity_hash", _wrap_Sparsity_hash, METH_O, "Sparsity_hash(Sparsity self) -> std::size_t"},
	 { "Sparsity_test_cast", _wrap_Sparsity_test_cast, METH_O, "Sparsity_test_cast(casadi::SharedObjectInternal const * ptr) -> bool"},
	 { "Sparsity_kkt", _wrap_Sparsity_kkt, METH_VARARGS, "Sparsity_kkt(Sparsity H, Sparsity J, bool with_x_diag=True, bool with_lam_g_diag=True) -> Sparsity"},
	 { "new_Sparsity", _wrap_new_Sparsity, METH_VARARGS, "\n"
		"Sparsity(casadi_int dummy=0)\n"
		"Sparsity(casadi_int nrow, casadi_int ncol)\n"
		"Sparsity(casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & colind, std::vector< casadi_int,std::allocator< casadi_int > > const & row, bool order_rows=False)\n"
		"Sparsity(std::pair< casadi_int,casadi_int > const & rc)\n"
		"new_Sparsity(Sparsity other) -> Sparsity\n"
		"\n"
		"\n"
		"Create a sparse matrix with all structural zeros.\n"
		"\n"
		"\n"
		""},
	 { "delete_Sparsity", _wrap_delete_Sparsity, METH_O, "delete_Sparsity(Sparsity self)"},
	 { "Sparsity_swigregister", Sparsity_swigregister, METH_O, NULL},
	 { "Sparsity_swiginit", Sparsity_swiginit, METH_VARARGS, NULL},
	 { "hash_combine", _wrap_hash_combine, METH_VARARGS, "\n"
		"hash_combine(std::size_t & seed, casadi_int const * v, std::size_t sz)\n"
		"hash_combine(std::size_t & seed, std::vector< casadi_int,std::allocator< casadi_int > > const & v)\n"
		"\n"
		"\n"
		"Generate a hash value incrementally, array.\n"
		"\n"
		"\n"
		""},
	 { "hash_sparsity", _wrap_hash_sparsity, METH_VARARGS, "\n"
		"hash_sparsity(casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & colind, std::vector< casadi_int,std::allocator< casadi_int > > const & row) -> std::size_t\n"
		"hash_sparsity(casadi_int nrow, casadi_int ncol, casadi_int const * colind, casadi_int const * row) -> std::size_t\n"
		"\n"
		"\n"
		"Hash a sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "Slice_start_get", _wrap_Slice_start_get, METH_O, "Slice_start_get(Slice self) -> casadi_int"},
	 { "Slice_stop_get", _wrap_Slice_stop_get, METH_O, "Slice_stop_get(Slice self) -> casadi_int"},
	 { "Slice_step_get", _wrap_Slice_step_get, METH_O, "Slice_step_get(Slice self) -> casadi_int"},
	 { "Slice_all", _wrap_Slice_all, METH_VARARGS, "\n"
		"Slice_all(Slice self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"Slice_all(Slice self, casadi_int len, bool ind1=False) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"Slice_all(Slice self, Slice outer, casadi_int len) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Get a vector of indices.\n"
		"\n"
		"\n"
		""},
	 { "Slice_size", _wrap_Slice_size, METH_O, "\n"
		"Slice_size(Slice self) -> size_t\n"
		"\n"
		"\n"
		"Get number of elements.\n"
		"\n"
		"\n"
		""},
	 { "Slice_is_empty", _wrap_Slice_is_empty, METH_O, "\n"
		"Slice_is_empty(Slice self) -> bool\n"
		"\n"
		"\n"
		"Check if slice is empty.\n"
		"\n"
		"\n"
		""},
	 { "Slice_is_scalar", _wrap_Slice_is_scalar, METH_VARARGS, "\n"
		"Slice_is_scalar(Slice self, casadi_int len) -> bool\n"
		"\n"
		"\n"
		"Is the slice a scalar.\n"
		"\n"
		"\n"
		""},
	 { "Slice_scalar", _wrap_Slice_scalar, METH_VARARGS, "\n"
		"Slice_scalar(Slice self, casadi_int len) -> casadi_int\n"
		"\n"
		"\n"
		"Get scalar (if is_scalar)\n"
		"\n"
		"\n"
		""},
	 { "Slice___eq__", _wrap_Slice___eq__, METH_VARARGS, "Slice___eq__(Slice self, Slice other) -> bool"},
	 { "Slice___ne__", _wrap_Slice___ne__, METH_VARARGS, "Slice___ne__(Slice self, Slice other) -> bool"},
	 { "Slice_apply", _wrap_Slice_apply, METH_VARARGS, "\n"
		"Slice_apply(Slice self, casadi_int len, bool ind1=False) -> Slice\n"
		"\n"
		"\n"
		"Apply concrete length.\n"
		"\n"
		"\n"
		""},
	 { "Slice___sub__", _wrap_Slice___sub__, METH_VARARGS, "Slice___sub__(Slice self, casadi_int i) -> Slice"},
	 { "Slice___mul__", _wrap_Slice___mul__, METH_VARARGS, "Slice___mul__(Slice self, casadi_int i) -> Slice"},
	 { "Slice_type_name", _wrap_Slice_type_name, METH_O, "\n"
		"Slice_type_name(Slice self) -> std::string\n"
		"\n"
		"\n"
		"Get name of the class.\n"
		"\n"
		"\n"
		""},
	 { "Slice_disp", _wrap_Slice_disp, METH_VARARGS, "\n"
		"Slice_disp(Slice self, bool more=False)\n"
		"\n"
		"\n"
		"Print a description of the object.\n"
		"\n"
		"\n"
		""},
	 { "Slice_str", _wrap_Slice_str, METH_VARARGS, "\n"
		"Slice_str(Slice self, bool more=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation.\n"
		"\n"
		"\n"
		""},
	 { "Slice_info", _wrap_Slice_info, METH_O, "\n"
		"Slice_info(Slice self) -> casadi::Dict\n"
		"\n"
		"\n"
		"Obtain information\n"
		"\n"
		"\n"
		""},
	 { "Slice_serialize", _wrap_Slice_serialize, METH_VARARGS, "\n"
		"Slice_serialize(Slice self, casadi::SerializingStream & s)\n"
		"\n"
		"\n"
		"Serialize an object.\n"
		"\n"
		"\n"
		""},
	 { "Slice_deserialize", _wrap_Slice_deserialize, METH_O, "Slice_deserialize(casadi::DeserializingStream & s) -> Slice"},
	 { "new_Slice", _wrap_new_Slice, METH_VARARGS, "\n"
		"Slice()\n"
		"Slice(casadi_int i, bool ind1=False)\n"
		"Slice(casadi_int start, casadi_int stop, casadi_int step=1)\n"
		"Slice(int start, int stop, int step=1)\n"
		"Slice(int start, casadi_int stop, int step=1)\n"
		"Slice(casadi_int start, int stop, int step=1)\n"
		"new_Slice(Slice other) -> Slice\n"
		""},
	 { "delete_Slice", _wrap_delete_Slice, METH_O, "delete_Slice(Slice self)"},
	 { "Slice_swigregister", Slice_swigregister, METH_O, NULL},
	 { "Slice_swiginit", Slice_swiginit, METH_VARARGS, NULL},
	 { "to_slice", _wrap_to_slice, METH_VARARGS, "\n"
		"to_slice(std::vector< casadi_int,std::allocator< casadi_int > > const & v, bool ind1=False) -> Slice\n"
		"\n"
		"\n"
		"Construct from an index vector (requires is_slice(v) to be true)\n"
		"\n"
		"\n"
		""},
	 { "to_slice2", _wrap_to_slice2, METH_O, "\n"
		"to_slice2(std::vector< casadi_int,std::allocator< casadi_int > > const & v) -> std::pair< casadi::Slice,casadi::Slice >\n"
		"\n"
		"\n"
		"Construct nested slices from an index vector (requires is_slice2(v) to be\n"
		"true)\n"
		"\n"
		"\n"
		""},
	 { "is_slice", _wrap_is_slice, METH_VARARGS, "\n"
		"is_slice(std::vector< casadi_int,std::allocator< casadi_int > > const & v, bool ind1=False) -> bool\n"
		"\n"
		"\n"
		"Check if an index vector can be represented more efficiently as a slice.\n"
		"\n"
		"\n"
		""},
	 { "is_slice2", _wrap_is_slice2, METH_O, "\n"
		"is_slice2(std::vector< casadi_int,std::allocator< casadi_int > > const & v) -> bool\n"
		"\n"
		"\n"
		"Check if an index vector can be represented more efficiently as two nested\n"
		"slices.\n"
		"\n"
		"\n"
		""},
	 { "new_GenericMatrixCommon", _wrap_new_GenericMatrixCommon, METH_VARARGS, "\n"
		"GenericMatrixCommon()\n"
		"new_GenericMatrixCommon(GenericMatrixCommon other) -> GenericMatrixCommon\n"
		""},
	 { "delete_GenericMatrixCommon", _wrap_delete_GenericMatrixCommon, METH_O, "delete_GenericMatrixCommon(GenericMatrixCommon self)"},
	 { "GenericMatrixCommon_swigregister", GenericMatrixCommon_swigregister, METH_O, NULL},
	 { "GenericMatrixCommon_swiginit", GenericMatrixCommon_swiginit, METH_VARARGS, NULL},
	 { "index_interp1d", _wrap_index_interp1d, METH_VARARGS, "index_interp1d(std::vector< double,std::allocator< double > > const & x, double xq, bool equidistant=False) -> double"},
	 { "GenDM_nnz", _wrap_GenDM_nnz, METH_O, "\n"
		"GenDM_nnz(GenDM self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of (structural) non-zero elements.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_nnz_lower", _wrap_GenDM_nnz_lower, METH_O, "\n"
		"GenDM_nnz_lower(GenDM self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of non-zeros in the lower triangular half.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_nnz_upper", _wrap_GenDM_nnz_upper, METH_O, "\n"
		"GenDM_nnz_upper(GenDM self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of non-zeros in the upper triangular half.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_nnz_diag", _wrap_GenDM_nnz_diag, METH_O, "\n"
		"GenDM_nnz_diag(GenDM self) -> casadi_int\n"
		"\n"
		"\n"
		"Get get the number of non-zeros on the diagonal.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_numel", _wrap_GenDM_numel, METH_O, "\n"
		"GenDM_numel(GenDM self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of elements.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_size1", _wrap_GenDM_size1, METH_O, "\n"
		"GenDM_size1(GenDM self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the first dimension (i.e. number of rows)\n"
		"\n"
		"\n"
		""},
	 { "GenDM_rows", _wrap_GenDM_rows, METH_O, "\n"
		"GenDM_rows(GenDM self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of rows, Octave-style syntax.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_size2", _wrap_GenDM_size2, METH_O, "\n"
		"GenDM_size2(GenDM self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the second dimension (i.e. number of columns)\n"
		"\n"
		"\n"
		""},
	 { "GenDM_columns", _wrap_GenDM_columns, METH_O, "\n"
		"GenDM_columns(GenDM self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of columns, Octave-style syntax.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_dim", _wrap_GenDM_dim, METH_VARARGS, "\n"
		"GenDM_dim(GenDM self, bool with_nz=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation of dimensions. The representation is e.g. \"4x5\"\n"
		"or \"4x5,10nz\".\n"
		"\n"
		"\n"
		""},
	 { "GenDM_size", _wrap_GenDM_size, METH_VARARGS, "\n"
		"GenDM_size(GenDM self) -> std::pair< casadi_int,casadi_int >\n"
		"GenDM_size(GenDM self, casadi_int axis) -> casadi_int\n"
		"\n"
		"\n"
		"Get the shape.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_is_empty", _wrap_GenDM_is_empty, METH_VARARGS, "\n"
		"GenDM_is_empty(GenDM self, bool both=False) -> bool\n"
		"\n"
		"\n"
		"Check if the sparsity is empty, i.e. if one of the dimensions is zero (or\n"
		"optionally both dimensions)\n"
		"\n"
		"\n"
		""},
	 { "GenDM_is_dense", _wrap_GenDM_is_dense, METH_O, "\n"
		"GenDM_is_dense(GenDM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix expression is dense.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_is_scalar", _wrap_GenDM_is_scalar, METH_VARARGS, "\n"
		"GenDM_is_scalar(GenDM self, bool scalar_and_dense=False) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix expression is scalar.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_is_square", _wrap_GenDM_is_square, METH_O, "\n"
		"GenDM_is_square(GenDM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix expression is square.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_is_vector", _wrap_GenDM_is_vector, METH_O, "\n"
		"GenDM_is_vector(GenDM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is a row or column vector.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_is_row", _wrap_GenDM_is_row, METH_O, "\n"
		"GenDM_is_row(GenDM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is a row vector (i.e. size1()==1)\n"
		"\n"
		"\n"
		""},
	 { "GenDM_is_column", _wrap_GenDM_is_column, METH_O, "\n"
		"GenDM_is_column(GenDM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is a column vector (i.e. size2()==1)\n"
		"\n"
		"\n"
		""},
	 { "GenDM_is_triu", _wrap_GenDM_is_triu, METH_O, "\n"
		"GenDM_is_triu(GenDM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is upper triangular.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_is_tril", _wrap_GenDM_is_tril, METH_O, "\n"
		"GenDM_is_tril(GenDM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is lower triangular.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_row", _wrap_GenDM_row, METH_VARARGS, "\n"
		"GenDM_row(GenDM self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"GenDM_row(GenDM self, casadi_int el) -> casadi_int\n"
		"\n"
		"\n"
		"Get the sparsity pattern. See the Sparsity class for details.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_colind", _wrap_GenDM_colind, METH_VARARGS, "\n"
		"GenDM_colind(GenDM self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"GenDM_colind(GenDM self, casadi_int col) -> casadi_int\n"
		"\n"
		"\n"
		"Get the sparsity pattern. See the Sparsity class for details.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_sparsity", _wrap_GenDM_sparsity, METH_O, "\n"
		"GenDM_sparsity(GenDM self) -> Sparsity\n"
		"\n"
		"\n"
		"Get the sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_sym", _wrap_GenDM_sym, METH_VARARGS, "\n"
		"GenDM_sym(std::string const & name, casadi_int nrow=1, casadi_int ncol=1) -> DM\n"
		"GenDM_sym(std::string const & name, std::pair< casadi_int,casadi_int > const & rc) -> DM\n"
		"GenDM_sym(std::string const & name, Sparsity sp) -> DM\n"
		"GenDM_sym(std::string const & name, Sparsity sp, casadi_int p) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"GenDM_sym(std::string const & name, casadi_int nrow, casadi_int ncol, casadi_int p) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"GenDM_sym(std::string const & name, Sparsity sp, casadi_int p, casadi_int r) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >\n"
		"GenDM_sym(std::string const & name, casadi_int nrow, casadi_int ncol, casadi_int p, casadi_int r) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >\n"
		"\n"
		"\n"
		"Create a vector of length r of vectors of length p with symbolic primitives\n"
		"with given sparsity.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_zeros", _wrap_GenDM_zeros, METH_VARARGS, "\n"
		"GenDM_zeros(casadi_int nrow=1, casadi_int ncol=1) -> DM\n"
		"GenDM_zeros(Sparsity sp) -> DM\n"
		"GenDM_zeros(std::pair< casadi_int,casadi_int > const & rc) -> DM\n"
		"\n"
		"\n"
		"Create a dense matrix or a matrix with specified sparsity with all entries\n"
		"zero.\n"
		"\n"
		"\n"
		""},
	 { "GenDM_ones", _wrap_GenDM_ones, METH_VARARGS, "\n"
		"GenDM_ones(casadi_int nrow=1, casadi_int ncol=1) -> DM\n"
		"GenDM_ones(Sparsity sp) -> DM\n"
		"GenDM_ones(std::pair< casadi_int,casadi_int > const & rc) -> DM\n"
		"\n"
		"\n"
		"Create a dense matrix or a matrix with specified sparsity with all entries\n"
		"one.\n"
		"\n"
		"\n"
		""},
	 { "new_GenDM", _wrap_new_GenDM, METH_VARARGS, "\n"
		"GenDM()\n"
		"new_GenDM(GenDM other) -> GenDM\n"
		""},
	 { "delete_GenDM", _wrap_delete_GenDM, METH_O, "delete_GenDM(GenDM self)"},
	 { "GenDM_swigregister", GenDM_swigregister, METH_O, NULL},
	 { "GenDM_swiginit", GenDM_swiginit, METH_VARARGS, NULL},
	 { "GenSX_nnz", _wrap_GenSX_nnz, METH_O, "\n"
		"GenSX_nnz(GenSX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of (structural) non-zero elements.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_nnz_lower", _wrap_GenSX_nnz_lower, METH_O, "\n"
		"GenSX_nnz_lower(GenSX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of non-zeros in the lower triangular half.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_nnz_upper", _wrap_GenSX_nnz_upper, METH_O, "\n"
		"GenSX_nnz_upper(GenSX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of non-zeros in the upper triangular half.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_nnz_diag", _wrap_GenSX_nnz_diag, METH_O, "\n"
		"GenSX_nnz_diag(GenSX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get get the number of non-zeros on the diagonal.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_numel", _wrap_GenSX_numel, METH_O, "\n"
		"GenSX_numel(GenSX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of elements.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_size1", _wrap_GenSX_size1, METH_O, "\n"
		"GenSX_size1(GenSX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the first dimension (i.e. number of rows)\n"
		"\n"
		"\n"
		""},
	 { "GenSX_rows", _wrap_GenSX_rows, METH_O, "\n"
		"GenSX_rows(GenSX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of rows, Octave-style syntax.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_size2", _wrap_GenSX_size2, METH_O, "\n"
		"GenSX_size2(GenSX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the second dimension (i.e. number of columns)\n"
		"\n"
		"\n"
		""},
	 { "GenSX_columns", _wrap_GenSX_columns, METH_O, "\n"
		"GenSX_columns(GenSX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of columns, Octave-style syntax.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_dim", _wrap_GenSX_dim, METH_VARARGS, "\n"
		"GenSX_dim(GenSX self, bool with_nz=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation of dimensions. The representation is e.g. \"4x5\"\n"
		"or \"4x5,10nz\".\n"
		"\n"
		"\n"
		""},
	 { "GenSX_size", _wrap_GenSX_size, METH_VARARGS, "\n"
		"GenSX_size(GenSX self) -> std::pair< casadi_int,casadi_int >\n"
		"GenSX_size(GenSX self, casadi_int axis) -> casadi_int\n"
		"\n"
		"\n"
		"Get the shape.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_is_empty", _wrap_GenSX_is_empty, METH_VARARGS, "\n"
		"GenSX_is_empty(GenSX self, bool both=False) -> bool\n"
		"\n"
		"\n"
		"Check if the sparsity is empty, i.e. if one of the dimensions is zero (or\n"
		"optionally both dimensions)\n"
		"\n"
		"\n"
		""},
	 { "GenSX_is_dense", _wrap_GenSX_is_dense, METH_O, "\n"
		"GenSX_is_dense(GenSX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix expression is dense.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_is_scalar", _wrap_GenSX_is_scalar, METH_VARARGS, "\n"
		"GenSX_is_scalar(GenSX self, bool scalar_and_dense=False) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix expression is scalar.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_is_square", _wrap_GenSX_is_square, METH_O, "\n"
		"GenSX_is_square(GenSX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix expression is square.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_is_vector", _wrap_GenSX_is_vector, METH_O, "\n"
		"GenSX_is_vector(GenSX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is a row or column vector.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_is_row", _wrap_GenSX_is_row, METH_O, "\n"
		"GenSX_is_row(GenSX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is a row vector (i.e. size1()==1)\n"
		"\n"
		"\n"
		""},
	 { "GenSX_is_column", _wrap_GenSX_is_column, METH_O, "\n"
		"GenSX_is_column(GenSX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is a column vector (i.e. size2()==1)\n"
		"\n"
		"\n"
		""},
	 { "GenSX_is_triu", _wrap_GenSX_is_triu, METH_O, "\n"
		"GenSX_is_triu(GenSX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is upper triangular.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_is_tril", _wrap_GenSX_is_tril, METH_O, "\n"
		"GenSX_is_tril(GenSX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is lower triangular.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_row", _wrap_GenSX_row, METH_VARARGS, "\n"
		"GenSX_row(GenSX self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"GenSX_row(GenSX self, casadi_int el) -> casadi_int\n"
		"\n"
		"\n"
		"Get the sparsity pattern. See the Sparsity class for details.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_colind", _wrap_GenSX_colind, METH_VARARGS, "\n"
		"GenSX_colind(GenSX self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"GenSX_colind(GenSX self, casadi_int col) -> casadi_int\n"
		"\n"
		"\n"
		"Get the sparsity pattern. See the Sparsity class for details.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_sparsity", _wrap_GenSX_sparsity, METH_O, "\n"
		"GenSX_sparsity(GenSX self) -> Sparsity\n"
		"\n"
		"\n"
		"Get the sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_sym", _wrap_GenSX_sym, METH_VARARGS, "\n"
		"GenSX_sym(std::string const & name, casadi_int nrow=1, casadi_int ncol=1) -> SX\n"
		"GenSX_sym(std::string const & name, std::pair< casadi_int,casadi_int > const & rc) -> SX\n"
		"GenSX_sym(std::string const & name, Sparsity sp) -> SX\n"
		"GenSX_sym(std::string const & name, Sparsity sp, casadi_int p) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		"GenSX_sym(std::string const & name, casadi_int nrow, casadi_int ncol, casadi_int p) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		"GenSX_sym(std::string const & name, Sparsity sp, casadi_int p, casadi_int r) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >\n"
		"GenSX_sym(std::string const & name, casadi_int nrow, casadi_int ncol, casadi_int p, casadi_int r) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >\n"
		"\n"
		"\n"
		"Create a vector of length r of vectors of length p with symbolic primitives\n"
		"with given sparsity.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_zeros", _wrap_GenSX_zeros, METH_VARARGS, "\n"
		"GenSX_zeros(casadi_int nrow=1, casadi_int ncol=1) -> SX\n"
		"GenSX_zeros(Sparsity sp) -> SX\n"
		"GenSX_zeros(std::pair< casadi_int,casadi_int > const & rc) -> SX\n"
		"\n"
		"\n"
		"Create a dense matrix or a matrix with specified sparsity with all entries\n"
		"zero.\n"
		"\n"
		"\n"
		""},
	 { "GenSX_ones", _wrap_GenSX_ones, METH_VARARGS, "\n"
		"GenSX_ones(casadi_int nrow=1, casadi_int ncol=1) -> SX\n"
		"GenSX_ones(Sparsity sp) -> SX\n"
		"GenSX_ones(std::pair< casadi_int,casadi_int > const & rc) -> SX\n"
		"\n"
		"\n"
		"Create a dense matrix or a matrix with specified sparsity with all entries\n"
		"one.\n"
		"\n"
		"\n"
		""},
	 { "new_GenSX", _wrap_new_GenSX, METH_VARARGS, "\n"
		"GenSX()\n"
		"new_GenSX(GenSX other) -> GenSX\n"
		""},
	 { "delete_GenSX", _wrap_delete_GenSX, METH_O, "delete_GenSX(GenSX self)"},
	 { "GenSX_swigregister", GenSX_swigregister, METH_O, NULL},
	 { "GenSX_swiginit", GenSX_swiginit, METH_VARARGS, NULL},
	 { "GenMX_nnz", _wrap_GenMX_nnz, METH_O, "\n"
		"GenMX_nnz(GenMX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of (structural) non-zero elements.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_nnz_lower", _wrap_GenMX_nnz_lower, METH_O, "\n"
		"GenMX_nnz_lower(GenMX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of non-zeros in the lower triangular half.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_nnz_upper", _wrap_GenMX_nnz_upper, METH_O, "\n"
		"GenMX_nnz_upper(GenMX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of non-zeros in the upper triangular half.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_nnz_diag", _wrap_GenMX_nnz_diag, METH_O, "\n"
		"GenMX_nnz_diag(GenMX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get get the number of non-zeros on the diagonal.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_numel", _wrap_GenMX_numel, METH_O, "\n"
		"GenMX_numel(GenMX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of elements.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_size1", _wrap_GenMX_size1, METH_O, "\n"
		"GenMX_size1(GenMX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the first dimension (i.e. number of rows)\n"
		"\n"
		"\n"
		""},
	 { "GenMX_rows", _wrap_GenMX_rows, METH_O, "\n"
		"GenMX_rows(GenMX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of rows, Octave-style syntax.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_size2", _wrap_GenMX_size2, METH_O, "\n"
		"GenMX_size2(GenMX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the second dimension (i.e. number of columns)\n"
		"\n"
		"\n"
		""},
	 { "GenMX_columns", _wrap_GenMX_columns, METH_O, "\n"
		"GenMX_columns(GenMX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of columns, Octave-style syntax.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_dim", _wrap_GenMX_dim, METH_VARARGS, "\n"
		"GenMX_dim(GenMX self, bool with_nz=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation of dimensions. The representation is e.g. \"4x5\"\n"
		"or \"4x5,10nz\".\n"
		"\n"
		"\n"
		""},
	 { "GenMX_size", _wrap_GenMX_size, METH_VARARGS, "\n"
		"GenMX_size(GenMX self) -> std::pair< casadi_int,casadi_int >\n"
		"GenMX_size(GenMX self, casadi_int axis) -> casadi_int\n"
		"\n"
		"\n"
		"Get the shape.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_is_empty", _wrap_GenMX_is_empty, METH_VARARGS, "\n"
		"GenMX_is_empty(GenMX self, bool both=False) -> bool\n"
		"\n"
		"\n"
		"Check if the sparsity is empty, i.e. if one of the dimensions is zero (or\n"
		"optionally both dimensions)\n"
		"\n"
		"\n"
		""},
	 { "GenMX_is_dense", _wrap_GenMX_is_dense, METH_O, "\n"
		"GenMX_is_dense(GenMX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix expression is dense.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_is_scalar", _wrap_GenMX_is_scalar, METH_VARARGS, "\n"
		"GenMX_is_scalar(GenMX self, bool scalar_and_dense=False) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix expression is scalar.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_is_square", _wrap_GenMX_is_square, METH_O, "\n"
		"GenMX_is_square(GenMX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix expression is square.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_is_vector", _wrap_GenMX_is_vector, METH_O, "\n"
		"GenMX_is_vector(GenMX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is a row or column vector.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_is_row", _wrap_GenMX_is_row, METH_O, "\n"
		"GenMX_is_row(GenMX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is a row vector (i.e. size1()==1)\n"
		"\n"
		"\n"
		""},
	 { "GenMX_is_column", _wrap_GenMX_is_column, METH_O, "\n"
		"GenMX_is_column(GenMX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is a column vector (i.e. size2()==1)\n"
		"\n"
		"\n"
		""},
	 { "GenMX_is_triu", _wrap_GenMX_is_triu, METH_O, "\n"
		"GenMX_is_triu(GenMX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is upper triangular.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_is_tril", _wrap_GenMX_is_tril, METH_O, "\n"
		"GenMX_is_tril(GenMX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is lower triangular.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_row", _wrap_GenMX_row, METH_VARARGS, "\n"
		"GenMX_row(GenMX self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"GenMX_row(GenMX self, casadi_int el) -> casadi_int\n"
		"\n"
		"\n"
		"Get the sparsity pattern. See the Sparsity class for details.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_colind", _wrap_GenMX_colind, METH_VARARGS, "\n"
		"GenMX_colind(GenMX self) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"GenMX_colind(GenMX self, casadi_int col) -> casadi_int\n"
		"\n"
		"\n"
		"Get the sparsity pattern. See the Sparsity class for details.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_sparsity", _wrap_GenMX_sparsity, METH_O, "\n"
		"GenMX_sparsity(GenMX self) -> Sparsity\n"
		"\n"
		"\n"
		"Get the sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_sym", _wrap_GenMX_sym, METH_VARARGS, "\n"
		"GenMX_sym(std::string const & name, casadi_int nrow=1, casadi_int ncol=1) -> MX\n"
		"GenMX_sym(std::string const & name, std::pair< casadi_int,casadi_int > const & rc) -> MX\n"
		"GenMX_sym(std::string const & name, Sparsity sp) -> MX\n"
		"GenMX_sym(std::string const & name, Sparsity sp, casadi_int p) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"GenMX_sym(std::string const & name, casadi_int nrow, casadi_int ncol, casadi_int p) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"GenMX_sym(std::string const & name, Sparsity sp, casadi_int p, casadi_int r) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >\n"
		"GenMX_sym(std::string const & name, casadi_int nrow, casadi_int ncol, casadi_int p, casadi_int r) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >\n"
		"\n"
		"\n"
		"Create a vector of length r of vectors of length p with symbolic primitives\n"
		"with given sparsity.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_zeros", _wrap_GenMX_zeros, METH_VARARGS, "\n"
		"GenMX_zeros(casadi_int nrow=1, casadi_int ncol=1) -> MX\n"
		"GenMX_zeros(Sparsity sp) -> MX\n"
		"GenMX_zeros(std::pair< casadi_int,casadi_int > const & rc) -> MX\n"
		"\n"
		"\n"
		"Create a dense matrix or a matrix with specified sparsity with all entries\n"
		"zero.\n"
		"\n"
		"\n"
		""},
	 { "GenMX_ones", _wrap_GenMX_ones, METH_VARARGS, "\n"
		"GenMX_ones(casadi_int nrow=1, casadi_int ncol=1) -> MX\n"
		"GenMX_ones(Sparsity sp) -> MX\n"
		"GenMX_ones(std::pair< casadi_int,casadi_int > const & rc) -> MX\n"
		"\n"
		"\n"
		"Create a dense matrix or a matrix with specified sparsity with all entries\n"
		"one.\n"
		"\n"
		"\n"
		""},
	 { "new_GenMX", _wrap_new_GenMX, METH_VARARGS, "\n"
		"GenMX()\n"
		"new_GenMX(GenMX other) -> GenMX\n"
		""},
	 { "delete_GenMX", _wrap_delete_GenMX, METH_O, "delete_GenMX(GenMX self)"},
	 { "GenMX_swigregister", GenMX_swigregister, METH_O, NULL},
	 { "GenMX_swiginit", GenMX_swiginit, METH_VARARGS, NULL},
	 { "new_GenericExpressionCommon", _wrap_new_GenericExpressionCommon, METH_VARARGS, "\n"
		"GenericExpressionCommon()\n"
		"new_GenericExpressionCommon(GenericExpressionCommon other) -> GenericExpressionCommon\n"
		""},
	 { "delete_GenericExpressionCommon", _wrap_delete_GenericExpressionCommon, METH_O, "delete_GenericExpressionCommon(GenericExpressionCommon self)"},
	 { "GenericExpressionCommon_swigregister", GenericExpressionCommon_swigregister, METH_O, NULL},
	 { "GenericExpressionCommon_swiginit", GenericExpressionCommon_swiginit, METH_VARARGS, NULL},
	 { "new_MatrixCommon", _wrap_new_MatrixCommon, METH_VARARGS, "\n"
		"MatrixCommon()\n"
		"new_MatrixCommon(MatrixCommon other) -> MatrixCommon\n"
		"\n"
		"\n"
		"constructors\n"
		"\n"
		"empty 0-by-0 matrix constructor\n"
		"\n"
		"\n"
		""},
	 { "delete_MatrixCommon", _wrap_delete_MatrixCommon, METH_O, "delete_MatrixCommon(MatrixCommon self)"},
	 { "MatrixCommon_swigregister", MatrixCommon_swigregister, METH_O, NULL},
	 { "MatrixCommon_swiginit", MatrixCommon_swiginit, METH_VARARGS, NULL},
	 { "DM_has_nz", _wrap_DM_has_nz, METH_VARARGS, "\n"
		"DM_has_nz(DM self, casadi_int rr, casadi_int cc) -> bool\n"
		"\n"
		"\n"
		"Returns true if the matrix has a non-zero at location rr, cc.\n"
		"\n"
		"\n"
		""},
	 { "DM___nonzero__", _wrap_DM___nonzero__, METH_O, "\n"
		"DM___nonzero__(DM self) -> bool\n"
		"\n"
		"\n"
		"Returns the truth value of a Matrix.\n"
		"\n"
		"\n"
		""},
	 { "DM_get", _wrap_DM_get, METH_VARARGS, "\n"
		"DM_get(DM self, bool ind1, Slice rr)\n"
		"DM_get(DM self, bool ind1, casadi::Matrix< casadi_int > const & rr)\n"
		"DM_get(DM self, bool ind1, Sparsity sp)\n"
		"DM_get(DM self, bool ind1, Slice rr, Slice cc)\n"
		"DM_get(DM self, bool ind1, Slice rr, casadi::Matrix< casadi_int > const & cc)\n"
		"DM_get(DM self, bool ind1, casadi::Matrix< casadi_int > const & rr, Slice cc)\n"
		"DM_get(DM self, bool ind1, casadi::Matrix< casadi_int > const & rr, casadi::Matrix< casadi_int > const & cc)\n"
		""},
	 { "DM_set", _wrap_DM_set, METH_VARARGS, "\n"
		"DM_set(DM self, DM m, bool ind1, Slice rr)\n"
		"DM_set(DM self, DM m, bool ind1, casadi::Matrix< casadi_int > const & rr)\n"
		"DM_set(DM self, DM m, bool ind1, Sparsity sp)\n"
		"DM_set(DM self, DM m, bool ind1, Slice rr, Slice cc)\n"
		"DM_set(DM self, DM m, bool ind1, Slice rr, casadi::Matrix< casadi_int > const & cc)\n"
		"DM_set(DM self, DM m, bool ind1, casadi::Matrix< casadi_int > const & rr, Slice cc)\n"
		"DM_set(DM self, DM m, bool ind1, casadi::Matrix< casadi_int > const & rr, casadi::Matrix< casadi_int > const & cc)\n"
		""},
	 { "DM_get_nz", _wrap_DM_get_nz, METH_VARARGS, "\n"
		"DM_get_nz(DM self, bool ind1, Slice k)\n"
		"DM_get_nz(DM self, bool ind1, casadi::Matrix< casadi_int > const & k)\n"
		""},
	 { "DM_set_nz", _wrap_DM_set_nz, METH_VARARGS, "\n"
		"DM_set_nz(DM self, DM m, bool ind1, Slice k)\n"
		"DM_set_nz(DM self, DM m, bool ind1, casadi::Matrix< casadi_int > const & k)\n"
		""},
	 { "DM___pos__", _wrap_DM___pos__, METH_O, "DM___pos__(DM self) -> DM"},
	 { "DM___neg__", _wrap_DM___neg__, METH_O, "DM___neg__(DM self) -> DM"},
	 { "DM_binary", _wrap_DM_binary, METH_VARARGS, "DM_binary(casadi_int op, DM x, DM y) -> DM"},
	 { "DM_unary", _wrap_DM_unary, METH_VARARGS, "DM_unary(casadi_int op, DM x) -> DM"},
	 { "DM_scalar_matrix", _wrap_DM_scalar_matrix, METH_VARARGS, "DM_scalar_matrix(casadi_int op, DM x, DM y) -> DM"},
	 { "DM_matrix_scalar", _wrap_DM_matrix_scalar, METH_VARARGS, "DM_matrix_scalar(casadi_int op, DM x, DM y) -> DM"},
	 { "DM_matrix_matrix", _wrap_DM_matrix_matrix, METH_VARARGS, "DM_matrix_matrix(casadi_int op, DM x, DM y) -> DM"},
	 { "DM_printme", _wrap_DM_printme, METH_VARARGS, "DM_printme(DM self, DM y) -> DM"},
	 { "DM_set_max_depth", _wrap_DM_set_max_depth, METH_VARARGS, "DM_set_max_depth(casadi_int eq_depth=1)"},
	 { "DM_get_max_depth", _wrap_DM_get_max_depth, METH_NOARGS, "DM_get_max_depth() -> casadi_int"},
	 { "DM_get_input", _wrap_DM_get_input, METH_O, "DM_get_input(Function f) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >"},
	 { "DM_get_free", _wrap_DM_get_free, METH_O, "DM_get_free(Function f) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >"},
	 { "DM_type_name", _wrap_DM_type_name, METH_NOARGS, "DM_type_name() -> std::string"},
	 { "DM_print_split", _wrap_DM_print_split, METH_O, "\n"
		"DM_print_split(DM self)\n"
		"\n"
		"\n"
		"Get strings corresponding to the nonzeros and the interdependencies.\n"
		"\n"
		"\n"
		""},
	 { "DM_disp", _wrap_DM_disp, METH_VARARGS, "\n"
		"DM_disp(DM self, bool more=False)\n"
		"\n"
		"\n"
		"Print a representation of the object.\n"
		"\n"
		"\n"
		""},
	 { "DM_str", _wrap_DM_str, METH_VARARGS, "\n"
		"DM_str(DM self, bool more=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation.\n"
		"\n"
		"\n"
		""},
	 { "DM_print_scalar", _wrap_DM_print_scalar, METH_O, "\n"
		"DM_print_scalar(DM self)\n"
		"\n"
		"\n"
		"Print scalar.\n"
		"\n"
		"\n"
		""},
	 { "DM_print_vector", _wrap_DM_print_vector, METH_VARARGS, "\n"
		"DM_print_vector(DM self, bool truncate=True)\n"
		"\n"
		"\n"
		"Print vector-style.\n"
		"\n"
		"\n"
		""},
	 { "DM_print_dense", _wrap_DM_print_dense, METH_VARARGS, "\n"
		"DM_print_dense(DM self, bool truncate=True)\n"
		"\n"
		"\n"
		"Print dense matrix-stype.\n"
		"\n"
		"\n"
		""},
	 { "DM_print_sparse", _wrap_DM_print_sparse, METH_VARARGS, "\n"
		"DM_print_sparse(DM self, bool truncate=True)\n"
		"\n"
		"\n"
		"Print sparse matrix style.\n"
		"\n"
		"\n"
		""},
	 { "DM_clear", _wrap_DM_clear, METH_O, "DM_clear(DM self)"},
	 { "DM_resize", _wrap_DM_resize, METH_VARARGS, "DM_resize(DM self, casadi_int nrow, casadi_int ncol)"},
	 { "DM_reserve", _wrap_DM_reserve, METH_VARARGS, "\n"
		"DM_reserve(DM self, casadi_int nnz)\n"
		"DM_reserve(DM self, casadi_int nnz, casadi_int ncol)\n"
		""},
	 { "DM_erase", _wrap_DM_erase, METH_VARARGS, "\n"
		"DM_erase(DM self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False)\n"
		"DM_erase(DM self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, bool ind1=False)\n"
		"\n"
		"\n"
		"Erase a submatrix (leaving structural zeros in its place) Erase rows and/or\n"
		"columns of a matrix.\n"
		"\n"
		"\n"
		""},
	 { "DM_remove", _wrap_DM_remove, METH_VARARGS, "\n"
		"DM_remove(DM self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc)\n"
		"\n"
		"\n"
		"Remove columns and rows Remove/delete rows and/or columns of a matrix.\n"
		"\n"
		"\n"
		""},
	 { "DM_enlarge", _wrap_DM_enlarge, METH_VARARGS, "\n"
		"DM_enlarge(DM self, casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False)\n"
		"\n"
		"\n"
		"Enlarge matrix Make the matrix larger by inserting empty rows and columns,\n"
		"keeping the existing non-zeros.\n"
		"\n"
		"\n"
		""},
	 { "DM_sparsity", _wrap_DM_sparsity, METH_O, "\n"
		"DM_sparsity(DM self) -> Sparsity\n"
		"\n"
		"\n"
		"Get an owning reference to the sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "DM_triplet", _wrap_DM_triplet, METH_VARARGS, "\n"
		"DM_triplet(std::vector< casadi_int,std::allocator< casadi_int > > const & row, std::vector< casadi_int,std::allocator< casadi_int > > const & col, DM d) -> DM\n"
		"DM_triplet(std::vector< casadi_int,std::allocator< casadi_int > > const & row, std::vector< casadi_int,std::allocator< casadi_int > > const & col, DM d, casadi_int nrow, casadi_int ncol) -> DM\n"
		"DM_triplet(std::vector< casadi_int,std::allocator< casadi_int > > const & row, std::vector< casadi_int,std::allocator< casadi_int > > const & col, DM d, std::pair< casadi_int,casadi_int > const & rc) -> DM\n"
		""},
	 { "DM_inf", _wrap_DM_inf, METH_VARARGS, "\n"
		"DM_inf(Sparsity sp) -> DM\n"
		"DM_inf(casadi_int nrow=1, casadi_int ncol=1) -> DM\n"
		"DM_inf(std::pair< casadi_int,casadi_int > const & rc) -> DM\n"
		"\n"
		"\n"
		"create a matrix with all inf\n"
		"\n"
		"\n"
		""},
	 { "DM_nan", _wrap_DM_nan, METH_VARARGS, "\n"
		"DM_nan(Sparsity sp) -> DM\n"
		"DM_nan(casadi_int nrow=1, casadi_int ncol=1) -> DM\n"
		"DM_nan(std::pair< casadi_int,casadi_int > const & rc) -> DM\n"
		"\n"
		"\n"
		"create a matrix with all nan\n"
		"\n"
		"\n"
		""},
	 { "DM_eye", _wrap_DM_eye, METH_O, "DM_eye(casadi_int n) -> DM"},
	 { "DM_element_hash", _wrap_DM_element_hash, METH_O, "DM_element_hash(DM self) -> casadi_int"},
	 { "DM_is_regular", _wrap_DM_is_regular, METH_O, "DM_is_regular(DM self) -> bool"},
	 { "DM_is_smooth", _wrap_DM_is_smooth, METH_O, "DM_is_smooth(DM self) -> bool"},
	 { "DM_is_leaf", _wrap_DM_is_leaf, METH_O, "DM_is_leaf(DM self) -> bool"},
	 { "DM_is_commutative", _wrap_DM_is_commutative, METH_O, "DM_is_commutative(DM self) -> bool"},
	 { "DM_is_symbolic", _wrap_DM_is_symbolic, METH_O, "DM_is_symbolic(DM self) -> bool"},
	 { "DM_is_valid_input", _wrap_DM_is_valid_input, METH_O, "DM_is_valid_input(DM self) -> bool"},
	 { "DM_has_duplicates", _wrap_DM_has_duplicates, METH_O, "DM_has_duplicates(DM self) -> bool"},
	 { "DM_reset_input", _wrap_DM_reset_input, METH_O, "DM_reset_input(DM self)"},
	 { "DM_is_constant", _wrap_DM_is_constant, METH_O, "\n"
		"DM_is_constant(DM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is constant (note that false negative answers are\n"
		"possible)\n"
		"\n"
		"\n"
		""},
	 { "DM_is_integer", _wrap_DM_is_integer, METH_O, "\n"
		"DM_is_integer(DM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is integer-valued (note that false negative answers are\n"
		"possible)\n"
		"\n"
		"\n"
		""},
	 { "DM_is_zero", _wrap_DM_is_zero, METH_O, "\n"
		"DM_is_zero(DM self) -> bool\n"
		"\n"
		"\n"
		"check if the matrix is 0 (note that false negative answers are possible)\n"
		"\n"
		"\n"
		""},
	 { "DM_is_one", _wrap_DM_is_one, METH_O, "\n"
		"DM_is_one(DM self) -> bool\n"
		"\n"
		"\n"
		"check if the matrix is 1 (note that false negative answers are possible)\n"
		"\n"
		"\n"
		""},
	 { "DM_is_minus_one", _wrap_DM_is_minus_one, METH_O, "\n"
		"DM_is_minus_one(DM self) -> bool\n"
		"\n"
		"\n"
		"check if the matrix is -1 (note that false negative answers are possible)\n"
		"\n"
		"\n"
		""},
	 { "DM_is_eye", _wrap_DM_is_eye, METH_O, "\n"
		"DM_is_eye(DM self) -> bool\n"
		"\n"
		"\n"
		"check if the matrix is an identity matrix (note that false negative answers\n"
		"are possible)\n"
		"\n"
		"\n"
		""},
	 { "DM_op", _wrap_DM_op, METH_O, "DM_op(DM self) -> casadi_int"},
	 { "DM_is_op", _wrap_DM_is_op, METH_VARARGS, "DM_is_op(DM self, casadi_int op) -> bool"},
	 { "DM_has_zeros", _wrap_DM_has_zeros, METH_O, "\n"
		"DM_has_zeros(DM self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix has any zero entries which are not structural zeros.\n"
		"\n"
		"\n"
		""},
	 { "DM_nonzeros", _wrap_DM_nonzeros, METH_O, "\n"
		"DM_nonzeros(DM self) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Get all nonzeros.\n"
		"\n"
		"Implementation of Matrix::get_nonzeros (in public API)\n"
		"\n"
		"\n"
		""},
	 { "DM_elements", _wrap_DM_elements, METH_O, "\n"
		"DM_elements(DM self) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Get all elements.\n"
		"\n"
		"\n"
		""},
	 { "DM___float__", _wrap_DM___float__, METH_O, "DM___float__(DM self) -> double"},
	 { "DM___int__", _wrap_DM___int__, METH_O, "DM___int__(DM self) -> casadi_int"},
	 { "DM_name", _wrap_DM_name, METH_O, "DM_name(DM self) -> std::string"},
	 { "DM_dep", _wrap_DM_dep, METH_VARARGS, "DM_dep(DM self, casadi_int ch=0) -> DM"},
	 { "DM_n_dep", _wrap_DM_n_dep, METH_O, "DM_n_dep(DM self) -> casadi_int"},
	 { "DM_set_precision", _wrap_DM_set_precision, METH_O, "\n"
		"DM_set_precision(casadi_int precision)\n"
		"\n"
		"\n"
		"Set the 'precision, width & scientific' used in printing and serializing to\n"
		"streams.\n"
		"\n"
		"\n"
		""},
	 { "DM_set_width", _wrap_DM_set_width, METH_O, "\n"
		"DM_set_width(casadi_int width)\n"
		"\n"
		"\n"
		"Set the 'precision, width & scientific' used in printing and serializing to\n"
		"streams.\n"
		"\n"
		"\n"
		""},
	 { "DM_set_scientific", _wrap_DM_set_scientific, METH_O, "\n"
		"DM_set_scientific(bool scientific)\n"
		"\n"
		"\n"
		"Set the 'precision, width & scientific' used in printing and serializing to\n"
		"streams.\n"
		"\n"
		"\n"
		""},
	 { "DM_rng", _wrap_DM_rng, METH_O, "DM_rng(casadi_int seed)"},
	 { "DM_rand", _wrap_DM_rand, METH_VARARGS, "\n"
		"DM_rand(casadi_int nrow=1, casadi_int ncol=1) -> DM\n"
		"DM_rand(Sparsity sp) -> DM\n"
		"DM_rand(std::pair< casadi_int,casadi_int > const & rc) -> DM\n"
		"\n"
		"\n"
		"Create a matrix with uniformly distributed random numbers.\n"
		"\n"
		"\n"
		""},
	 { "DM_export_code", _wrap_DM_export_code, METH_VARARGS, "\n"
		"DM_export_code(DM self, std::string const & lang, casadi::Dict const & options=casadi::Dict())\n"
		"\n"
		"\n"
		"Export matrix in specific language.\n"
		"\n"
		"lang: only 'matlab' supported for now\n"
		"\n"
		"::\n"
		"\n"
		"  * options:\n"
		"  *   inline: Indicates if you want everything on a single line (default: False)\n"
		"  *   name: Name of exported variable (default: 'm')\n"
		"  *   indent_level: Level of indentation (default: 0)\n"
		"  *   spoof_zero: Replace numerical zero by a 1e-200 (default: false)\n"
		"  *               might be needed for matlab sparse construct,\n"
		"  *               which doesn't allow numerical zero\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "DM_info", _wrap_DM_info, METH_O, "DM_info(DM self) -> casadi::Dict"},
	 { "DM_serialize", _wrap_DM_serialize, METH_VARARGS, "\n"
		"DM_serialize(DM self) -> std::string\n"
		"DM_serialize(DM self, casadi::SerializingStream & s)\n"
		"\n"
		"\n"
		"Serialize.\n"
		"\n"
		"\n"
		""},
	 { "DM_deserialize", _wrap_DM_deserialize, METH_VARARGS, "\n"
		"DM_deserialize(std::istream & stream) -> DM\n"
		"DM_deserialize(std::string const & s) -> DM\n"
		"DM_deserialize(casadi::DeserializingStream & s) -> DM\n"
		""},
	 { "DM_to_file", _wrap_DM_to_file, METH_VARARGS, "\n"
		"DM_to_file(DM self, std::string const & filename, std::string const & format=\"\")\n"
		"\n"
		"\n"
		"Export numerical matrix to file\n"
		"\n"
		"Supported formats:\n"
		"\n"
		"\n"
		"\n"
		"::\n"
		"\n"
		"  *   - .mtx   Matrix Market (sparse)\n"
		"  *   - .txt   Ascii full precision representation (sparse)\n"
		"  *            Whitespace separated, aligned.\n"
		"  *            Comments with # % or /\n"
		"  *            Uses C locale\n"
		"  *            Structural zeros represented by 00\n"
		"  *            Does not scale well for large sparse matrices\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "DM_from_file", _wrap_DM_from_file, METH_VARARGS, "\n"
		"DM_from_file(std::string const & filename, std::string const & format_hint=\"\") -> DM\n"
		"\n"
		"\n"
		"Export numerical matrix to file\n"
		"\n"
		"Supported formats:\n"
		"\n"
		"\n"
		"\n"
		"::\n"
		"\n"
		"  *   - .mtx   Matrix Market (sparse)\n"
		"  *   - .txt   Ascii full precision representation (sparse)\n"
		"  *            Whitespace separated, aligned.\n"
		"  *            Comments with # % or /\n"
		"  *            Uses C locale\n"
		"  *            Structural zeros represented by 00\n"
		"  *            Does not scale well for large sparse matrices\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "new_DM", _wrap_new_DM, METH_VARARGS, "\n"
		"DM()\n"
		"DM(DM m)\n"
		"DM(casadi_int nrow, casadi_int ncol)\n"
		"DM(Sparsity sp)\n"
		"DM(Sparsity sp, DM d)\n"
		"DM(double val)\n"
		"DM(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & m)\n"
		"DM(std::vector< casadi::SXElem,std::allocator< casadi::SXElem > > const & x)\n"
		"new_DM(SX x) -> DM\n"
		""},
	 { "DM_assign", _wrap_DM_assign, METH_VARARGS, "DM_assign(DM self, DM rhs)"},
	 { "DM_full", _wrap_DM_full, METH_O, "DM_full(DM self) -> PyObject *"},
	 { "DM_sparse", _wrap_DM_sparse, METH_O, "DM_sparse(DM self) -> PyObject *"},
	 { "delete_DM", _wrap_delete_DM, METH_O, "delete_DM(DM self)"},
	 { "DM_swigregister", DM_swigregister, METH_O, NULL},
	 { "DM_swiginit", DM_swiginit, METH_VARARGS, NULL},
	 { "new_SXElem", _wrap_new_SXElem, METH_VARARGS, "\n"
		"SXElem()\n"
		"new_SXElem(SXElem other) -> SXElem\n"
		""},
	 { "delete_SXElem", _wrap_delete_SXElem, METH_O, "delete_SXElem(SXElem self)"},
	 { "SXElem_swigregister", SXElem_swigregister, METH_O, NULL},
	 { "SXElem_swiginit", SXElem_swiginit, METH_VARARGS, NULL},
	 { "SX_has_nz", _wrap_SX_has_nz, METH_VARARGS, "\n"
		"SX_has_nz(SX self, casadi_int rr, casadi_int cc) -> bool\n"
		"\n"
		"\n"
		"Returns true if the matrix has a non-zero at location rr, cc.\n"
		"\n"
		"\n"
		""},
	 { "SX___nonzero__", _wrap_SX___nonzero__, METH_O, "\n"
		"SX___nonzero__(SX self) -> bool\n"
		"\n"
		"\n"
		"Returns the truth value of a Matrix.\n"
		"\n"
		"\n"
		""},
	 { "SX_get", _wrap_SX_get, METH_VARARGS, "\n"
		"SX_get(SX self, bool ind1, Slice rr)\n"
		"SX_get(SX self, bool ind1, casadi::Matrix< casadi_int > const & rr)\n"
		"SX_get(SX self, bool ind1, Sparsity sp)\n"
		"SX_get(SX self, bool ind1, Slice rr, Slice cc)\n"
		"SX_get(SX self, bool ind1, Slice rr, casadi::Matrix< casadi_int > const & cc)\n"
		"SX_get(SX self, bool ind1, casadi::Matrix< casadi_int > const & rr, Slice cc)\n"
		"SX_get(SX self, bool ind1, casadi::Matrix< casadi_int > const & rr, casadi::Matrix< casadi_int > const & cc)\n"
		""},
	 { "SX_set", _wrap_SX_set, METH_VARARGS, "\n"
		"SX_set(SX self, SX m, bool ind1, Slice rr)\n"
		"SX_set(SX self, SX m, bool ind1, casadi::Matrix< casadi_int > const & rr)\n"
		"SX_set(SX self, SX m, bool ind1, Sparsity sp)\n"
		"SX_set(SX self, SX m, bool ind1, Slice rr, Slice cc)\n"
		"SX_set(SX self, SX m, bool ind1, Slice rr, casadi::Matrix< casadi_int > const & cc)\n"
		"SX_set(SX self, SX m, bool ind1, casadi::Matrix< casadi_int > const & rr, Slice cc)\n"
		"SX_set(SX self, SX m, bool ind1, casadi::Matrix< casadi_int > const & rr, casadi::Matrix< casadi_int > const & cc)\n"
		""},
	 { "SX_get_nz", _wrap_SX_get_nz, METH_VARARGS, "\n"
		"SX_get_nz(SX self, bool ind1, Slice k)\n"
		"SX_get_nz(SX self, bool ind1, casadi::Matrix< casadi_int > const & k)\n"
		""},
	 { "SX_set_nz", _wrap_SX_set_nz, METH_VARARGS, "\n"
		"SX_set_nz(SX self, SX m, bool ind1, Slice k)\n"
		"SX_set_nz(SX self, SX m, bool ind1, casadi::Matrix< casadi_int > const & k)\n"
		""},
	 { "SX___pos__", _wrap_SX___pos__, METH_O, "SX___pos__(SX self) -> SX"},
	 { "SX___neg__", _wrap_SX___neg__, METH_O, "SX___neg__(SX self) -> SX"},
	 { "SX_binary", _wrap_SX_binary, METH_VARARGS, "SX_binary(casadi_int op, SX x, SX y) -> SX"},
	 { "SX_unary", _wrap_SX_unary, METH_VARARGS, "SX_unary(casadi_int op, SX x) -> SX"},
	 { "SX_scalar_matrix", _wrap_SX_scalar_matrix, METH_VARARGS, "SX_scalar_matrix(casadi_int op, SX x, SX y) -> SX"},
	 { "SX_matrix_scalar", _wrap_SX_matrix_scalar, METH_VARARGS, "SX_matrix_scalar(casadi_int op, SX x, SX y) -> SX"},
	 { "SX_matrix_matrix", _wrap_SX_matrix_matrix, METH_VARARGS, "SX_matrix_matrix(casadi_int op, SX x, SX y) -> SX"},
	 { "SX_printme", _wrap_SX_printme, METH_VARARGS, "SX_printme(SX self, SX y) -> SX"},
	 { "SX_set_max_depth", _wrap_SX_set_max_depth, METH_VARARGS, "SX_set_max_depth(casadi_int eq_depth=1)"},
	 { "SX_get_max_depth", _wrap_SX_get_max_depth, METH_NOARGS, "SX_get_max_depth() -> casadi_int"},
	 { "SX_get_input", _wrap_SX_get_input, METH_O, "SX_get_input(Function f) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >"},
	 { "SX_get_free", _wrap_SX_get_free, METH_O, "SX_get_free(Function f) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >"},
	 { "SX_type_name", _wrap_SX_type_name, METH_NOARGS, "SX_type_name() -> std::string"},
	 { "SX_print_split", _wrap_SX_print_split, METH_O, "\n"
		"SX_print_split(SX self)\n"
		"\n"
		"\n"
		"Get strings corresponding to the nonzeros and the interdependencies.\n"
		"\n"
		"\n"
		""},
	 { "SX_disp", _wrap_SX_disp, METH_VARARGS, "\n"
		"SX_disp(SX self, bool more=False)\n"
		"\n"
		"\n"
		"Print a representation of the object.\n"
		"\n"
		"\n"
		""},
	 { "SX_str", _wrap_SX_str, METH_VARARGS, "\n"
		"SX_str(SX self, bool more=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation.\n"
		"\n"
		"\n"
		""},
	 { "SX_print_scalar", _wrap_SX_print_scalar, METH_O, "\n"
		"SX_print_scalar(SX self)\n"
		"\n"
		"\n"
		"Print scalar.\n"
		"\n"
		"\n"
		""},
	 { "SX_print_vector", _wrap_SX_print_vector, METH_VARARGS, "\n"
		"SX_print_vector(SX self, bool truncate=True)\n"
		"\n"
		"\n"
		"Print vector-style.\n"
		"\n"
		"\n"
		""},
	 { "SX_print_dense", _wrap_SX_print_dense, METH_VARARGS, "\n"
		"SX_print_dense(SX self, bool truncate=True)\n"
		"\n"
		"\n"
		"Print dense matrix-stype.\n"
		"\n"
		"\n"
		""},
	 { "SX_print_sparse", _wrap_SX_print_sparse, METH_VARARGS, "\n"
		"SX_print_sparse(SX self, bool truncate=True)\n"
		"\n"
		"\n"
		"Print sparse matrix style.\n"
		"\n"
		"\n"
		""},
	 { "SX_clear", _wrap_SX_clear, METH_O, "SX_clear(SX self)"},
	 { "SX_resize", _wrap_SX_resize, METH_VARARGS, "SX_resize(SX self, casadi_int nrow, casadi_int ncol)"},
	 { "SX_reserve", _wrap_SX_reserve, METH_VARARGS, "\n"
		"SX_reserve(SX self, casadi_int nnz)\n"
		"SX_reserve(SX self, casadi_int nnz, casadi_int ncol)\n"
		""},
	 { "SX_erase", _wrap_SX_erase, METH_VARARGS, "\n"
		"SX_erase(SX self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False)\n"
		"SX_erase(SX self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, bool ind1=False)\n"
		"\n"
		"\n"
		"Erase a submatrix (leaving structural zeros in its place) Erase rows and/or\n"
		"columns of a matrix.\n"
		"\n"
		"\n"
		""},
	 { "SX_remove", _wrap_SX_remove, METH_VARARGS, "\n"
		"SX_remove(SX self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc)\n"
		"\n"
		"\n"
		"Remove columns and rows Remove/delete rows and/or columns of a matrix.\n"
		"\n"
		"\n"
		""},
	 { "SX_enlarge", _wrap_SX_enlarge, METH_VARARGS, "\n"
		"SX_enlarge(SX self, casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False)\n"
		"\n"
		"\n"
		"Enlarge matrix Make the matrix larger by inserting empty rows and columns,\n"
		"keeping the existing non-zeros.\n"
		"\n"
		"\n"
		""},
	 { "SX_sparsity", _wrap_SX_sparsity, METH_O, "\n"
		"SX_sparsity(SX self) -> Sparsity\n"
		"\n"
		"\n"
		"Get an owning reference to the sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "SX_triplet", _wrap_SX_triplet, METH_VARARGS, "\n"
		"SX_triplet(std::vector< casadi_int,std::allocator< casadi_int > > const & row, std::vector< casadi_int,std::allocator< casadi_int > > const & col, SX d) -> SX\n"
		"SX_triplet(std::vector< casadi_int,std::allocator< casadi_int > > const & row, std::vector< casadi_int,std::allocator< casadi_int > > const & col, SX d, casadi_int nrow, casadi_int ncol) -> SX\n"
		"SX_triplet(std::vector< casadi_int,std::allocator< casadi_int > > const & row, std::vector< casadi_int,std::allocator< casadi_int > > const & col, SX d, std::pair< casadi_int,casadi_int > const & rc) -> SX\n"
		""},
	 { "SX_inf", _wrap_SX_inf, METH_VARARGS, "\n"
		"SX_inf(Sparsity sp) -> SX\n"
		"SX_inf(casadi_int nrow=1, casadi_int ncol=1) -> SX\n"
		"SX_inf(std::pair< casadi_int,casadi_int > const & rc) -> SX\n"
		"\n"
		"\n"
		"create a matrix with all inf\n"
		"\n"
		"\n"
		""},
	 { "SX_nan", _wrap_SX_nan, METH_VARARGS, "\n"
		"SX_nan(Sparsity sp) -> SX\n"
		"SX_nan(casadi_int nrow=1, casadi_int ncol=1) -> SX\n"
		"SX_nan(std::pair< casadi_int,casadi_int > const & rc) -> SX\n"
		"\n"
		"\n"
		"create a matrix with all nan\n"
		"\n"
		"\n"
		""},
	 { "SX_eye", _wrap_SX_eye, METH_O, "SX_eye(casadi_int n) -> SX"},
	 { "SX_element_hash", _wrap_SX_element_hash, METH_O, "SX_element_hash(SX self) -> casadi_int"},
	 { "SX_is_regular", _wrap_SX_is_regular, METH_O, "SX_is_regular(SX self) -> bool"},
	 { "SX_is_smooth", _wrap_SX_is_smooth, METH_O, "SX_is_smooth(SX self) -> bool"},
	 { "SX_is_leaf", _wrap_SX_is_leaf, METH_O, "SX_is_leaf(SX self) -> bool"},
	 { "SX_is_commutative", _wrap_SX_is_commutative, METH_O, "SX_is_commutative(SX self) -> bool"},
	 { "SX_is_symbolic", _wrap_SX_is_symbolic, METH_O, "SX_is_symbolic(SX self) -> bool"},
	 { "SX_is_valid_input", _wrap_SX_is_valid_input, METH_O, "SX_is_valid_input(SX self) -> bool"},
	 { "SX_has_duplicates", _wrap_SX_has_duplicates, METH_O, "SX_has_duplicates(SX self) -> bool"},
	 { "SX_reset_input", _wrap_SX_reset_input, METH_O, "SX_reset_input(SX self)"},
	 { "SX_is_constant", _wrap_SX_is_constant, METH_O, "\n"
		"SX_is_constant(SX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is constant (note that false negative answers are\n"
		"possible)\n"
		"\n"
		"\n"
		""},
	 { "SX_is_integer", _wrap_SX_is_integer, METH_O, "\n"
		"SX_is_integer(SX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix is integer-valued (note that false negative answers are\n"
		"possible)\n"
		"\n"
		"\n"
		""},
	 { "SX_is_zero", _wrap_SX_is_zero, METH_O, "\n"
		"SX_is_zero(SX self) -> bool\n"
		"\n"
		"\n"
		"check if the matrix is 0 (note that false negative answers are possible)\n"
		"\n"
		"\n"
		""},
	 { "SX_is_one", _wrap_SX_is_one, METH_O, "\n"
		"SX_is_one(SX self) -> bool\n"
		"\n"
		"\n"
		"check if the matrix is 1 (note that false negative answers are possible)\n"
		"\n"
		"\n"
		""},
	 { "SX_is_minus_one", _wrap_SX_is_minus_one, METH_O, "\n"
		"SX_is_minus_one(SX self) -> bool\n"
		"\n"
		"\n"
		"check if the matrix is -1 (note that false negative answers are possible)\n"
		"\n"
		"\n"
		""},
	 { "SX_is_eye", _wrap_SX_is_eye, METH_O, "\n"
		"SX_is_eye(SX self) -> bool\n"
		"\n"
		"\n"
		"check if the matrix is an identity matrix (note that false negative answers\n"
		"are possible)\n"
		"\n"
		"\n"
		""},
	 { "SX_op", _wrap_SX_op, METH_O, "SX_op(SX self) -> casadi_int"},
	 { "SX_is_op", _wrap_SX_is_op, METH_VARARGS, "SX_is_op(SX self, casadi_int op) -> bool"},
	 { "SX_has_zeros", _wrap_SX_has_zeros, METH_O, "\n"
		"SX_has_zeros(SX self) -> bool\n"
		"\n"
		"\n"
		"Check if the matrix has any zero entries which are not structural zeros.\n"
		"\n"
		"\n"
		""},
	 { "SX_nonzeros", _wrap_SX_nonzeros, METH_O, "\n"
		"SX_nonzeros(SX self) -> std::vector< casadi::SXElem,std::allocator< casadi::SXElem > >\n"
		"\n"
		"\n"
		"Get all nonzeros.\n"
		"\n"
		"Implementation of Matrix::get_nonzeros (in public API)\n"
		"\n"
		"\n"
		""},
	 { "SX_elements", _wrap_SX_elements, METH_O, "\n"
		"SX_elements(SX self) -> std::vector< casadi::SXElem,std::allocator< casadi::SXElem > >\n"
		"\n"
		"\n"
		"Get all elements.\n"
		"\n"
		"\n"
		""},
	 { "SX___float__", _wrap_SX___float__, METH_O, "SX___float__(SX self) -> double"},
	 { "SX___int__", _wrap_SX___int__, METH_O, "SX___int__(SX self) -> casadi_int"},
	 { "SX_name", _wrap_SX_name, METH_O, "SX_name(SX self) -> std::string"},
	 { "SX_dep", _wrap_SX_dep, METH_VARARGS, "SX_dep(SX self, casadi_int ch=0) -> SX"},
	 { "SX_n_dep", _wrap_SX_n_dep, METH_O, "SX_n_dep(SX self) -> casadi_int"},
	 { "SX_set_precision", _wrap_SX_set_precision, METH_O, "\n"
		"SX_set_precision(casadi_int precision)\n"
		"\n"
		"\n"
		"Set the 'precision, width & scientific' used in printing and serializing to\n"
		"streams.\n"
		"\n"
		"\n"
		""},
	 { "SX_set_width", _wrap_SX_set_width, METH_O, "\n"
		"SX_set_width(casadi_int width)\n"
		"\n"
		"\n"
		"Set the 'precision, width & scientific' used in printing and serializing to\n"
		"streams.\n"
		"\n"
		"\n"
		""},
	 { "SX_set_scientific", _wrap_SX_set_scientific, METH_O, "\n"
		"SX_set_scientific(bool scientific)\n"
		"\n"
		"\n"
		"Set the 'precision, width & scientific' used in printing and serializing to\n"
		"streams.\n"
		"\n"
		"\n"
		""},
	 { "SX_rng", _wrap_SX_rng, METH_O, "SX_rng(casadi_int seed)"},
	 { "SX_rand", _wrap_SX_rand, METH_VARARGS, "\n"
		"SX_rand(casadi_int nrow=1, casadi_int ncol=1) -> SX\n"
		"SX_rand(Sparsity sp) -> SX\n"
		"SX_rand(std::pair< casadi_int,casadi_int > const & rc) -> SX\n"
		"\n"
		"\n"
		"Create a matrix with uniformly distributed random numbers.\n"
		"\n"
		"\n"
		""},
	 { "SX_export_code", _wrap_SX_export_code, METH_VARARGS, "\n"
		"SX_export_code(SX self, std::string const & lang, casadi::Dict const & options=casadi::Dict())\n"
		"\n"
		"\n"
		"Export matrix in specific language.\n"
		"\n"
		"lang: only 'matlab' supported for now\n"
		"\n"
		"::\n"
		"\n"
		"  * options:\n"
		"  *   inline: Indicates if you want everything on a single line (default: False)\n"
		"  *   name: Name of exported variable (default: 'm')\n"
		"  *   indent_level: Level of indentation (default: 0)\n"
		"  *   spoof_zero: Replace numerical zero by a 1e-200 (default: false)\n"
		"  *               might be needed for matlab sparse construct,\n"
		"  *               which doesn't allow numerical zero\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "SX_info", _wrap_SX_info, METH_O, "SX_info(SX self) -> casadi::Dict"},
	 { "SX_serialize", _wrap_SX_serialize, METH_VARARGS, "\n"
		"SX_serialize(SX self) -> std::string\n"
		"SX_serialize(SX self, casadi::SerializingStream & s)\n"
		"\n"
		"\n"
		"Serialize.\n"
		"\n"
		"\n"
		""},
	 { "SX_deserialize", _wrap_SX_deserialize, METH_VARARGS, "\n"
		"SX_deserialize(std::istream & stream) -> SX\n"
		"SX_deserialize(std::string const & s) -> SX\n"
		"SX_deserialize(casadi::DeserializingStream & s) -> SX\n"
		""},
	 { "SX_to_file", _wrap_SX_to_file, METH_VARARGS, "\n"
		"SX_to_file(SX self, std::string const & filename, std::string const & format=\"\")\n"
		"\n"
		"\n"
		"Export numerical matrix to file\n"
		"\n"
		"Supported formats:\n"
		"\n"
		"\n"
		"\n"
		"::\n"
		"\n"
		"  *   - .mtx   Matrix Market (sparse)\n"
		"  *   - .txt   Ascii full precision representation (sparse)\n"
		"  *            Whitespace separated, aligned.\n"
		"  *            Comments with # % or /\n"
		"  *            Uses C locale\n"
		"  *            Structural zeros represented by 00\n"
		"  *            Does not scale well for large sparse matrices\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "SX_from_file", _wrap_SX_from_file, METH_VARARGS, "\n"
		"SX_from_file(std::string const & filename, std::string const & format_hint=\"\") -> DM\n"
		"\n"
		"\n"
		"Export numerical matrix to file\n"
		"\n"
		"Supported formats:\n"
		"\n"
		"\n"
		"\n"
		"::\n"
		"\n"
		"  *   - .mtx   Matrix Market (sparse)\n"
		"  *   - .txt   Ascii full precision representation (sparse)\n"
		"  *            Whitespace separated, aligned.\n"
		"  *            Comments with # % or /\n"
		"  *            Uses C locale\n"
		"  *            Structural zeros represented by 00\n"
		"  *            Does not scale well for large sparse matrices\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "new_SX", _wrap_new_SX, METH_VARARGS, "\n"
		"SX()\n"
		"SX(SX m)\n"
		"SX(casadi_int nrow, casadi_int ncol)\n"
		"SX(Sparsity sp)\n"
		"SX(Sparsity sp, SX d)\n"
		"SX(double val)\n"
		"SX(std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & m)\n"
		"SX(std::vector< double,std::allocator< double > > const & x)\n"
		"new_SX(DM x) -> SX\n"
		""},
	 { "delete_SX", _wrap_delete_SX, METH_O, "delete_SX(SX self)"},
	 { "SX_swigregister", SX_swigregister, METH_O, NULL},
	 { "SX_swiginit", SX_swiginit, METH_VARARGS, NULL},
	 { "MX_type_name", _wrap_MX_type_name, METH_NOARGS, "MX_type_name() -> std::string"},
	 { "new_MX", _wrap_new_MX, METH_VARARGS, "\n"
		"MX()\n"
		"MX(casadi_int nrow, casadi_int ncol)\n"
		"MX(Sparsity sp)\n"
		"MX(Sparsity sp, MX val)\n"
		"MX(Sparsity sp, std::string const & fname)\n"
		"MX(double x)\n"
		"MX(MX x)\n"
		"new_MX(DM x) -> MX\n"
		"\n"
		"\n"
		"Copy constructor.\n"
		"\n"
		"\n"
		""},
	 { "delete_MX", _wrap_delete_MX, METH_O, "\n"
		"delete_MX(MX self)\n"
		"\n"
		"\n"
		"[INTERNAL]  Destructor.\n"
		"\n"
		"\n"
		""},
	 { "MX___nonzero__", _wrap_MX___nonzero__, METH_O, "\n"
		"MX___nonzero__(MX self) -> bool\n"
		"\n"
		"\n"
		"Returns the truth value of an MX expression.\n"
		"\n"
		"\n"
		""},
	 { "MX_sparsity", _wrap_MX_sparsity, METH_O, "\n"
		"MX_sparsity(MX self) -> Sparsity\n"
		"\n"
		"\n"
		"Get an owning reference to the sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "MX_erase", _wrap_MX_erase, METH_VARARGS, "\n"
		"MX_erase(MX self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False)\n"
		"MX_erase(MX self, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, bool ind1=False)\n"
		"\n"
		"\n"
		"Erase a submatrix (leaving structural zeros in its place) Erase rows and/or\n"
		"columns of a matrix.\n"
		"\n"
		"\n"
		""},
	 { "MX_enlarge", _wrap_MX_enlarge, METH_VARARGS, "\n"
		"MX_enlarge(MX self, casadi_int nrow, casadi_int ncol, std::vector< casadi_int,std::allocator< casadi_int > > const & rr, std::vector< casadi_int,std::allocator< casadi_int > > const & cc, bool ind1=False)\n"
		"\n"
		"\n"
		"Enlarge matrix Make the matrix larger by inserting empty rows and columns,\n"
		"keeping the existing non-zeros.\n"
		"\n"
		"\n"
		""},
	 { "MX___neg__", _wrap_MX___neg__, METH_O, "MX___neg__(MX self) -> MX"},
	 { "MX_dep", _wrap_MX_dep, METH_VARARGS, "\n"
		"MX_dep(MX self, casadi_int ch=0) -> MX\n"
		"\n"
		"\n"
		"Get the nth dependency as MX.\n"
		"\n"
		"\n"
		""},
	 { "MX_n_out", _wrap_MX_n_out, METH_O, "\n"
		"MX_n_out(MX self) -> casadi_int\n"
		"\n"
		"\n"
		"Number of outputs.\n"
		"\n"
		"\n"
		""},
	 { "MX_get_output", _wrap_MX_get_output, METH_VARARGS, "\n"
		"MX_get_output(MX self, casadi_int oind) -> MX\n"
		"\n"
		"\n"
		"Get an output.\n"
		"\n"
		"\n"
		""},
	 { "MX_n_dep", _wrap_MX_n_dep, METH_O, "\n"
		"MX_n_dep(MX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of dependencies of a binary SXElem.\n"
		"\n"
		"\n"
		""},
	 { "MX_name", _wrap_MX_name, METH_O, "\n"
		"MX_name(MX self) -> std::string\n"
		"\n"
		"\n"
		"Get the name.\n"
		"\n"
		"\n"
		""},
	 { "MX___float__", _wrap_MX___float__, METH_O, "MX___float__(MX self) -> double"},
	 { "MX_to_DM", _wrap_MX_to_DM, METH_O, "MX_to_DM(MX self) -> DM"},
	 { "MX_is_symbolic", _wrap_MX_is_symbolic, METH_O, "\n"
		"MX_is_symbolic(MX self) -> bool\n"
		"\n"
		"\n"
		"Check if symbolic.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_constant", _wrap_MX_is_constant, METH_O, "\n"
		"MX_is_constant(MX self) -> bool\n"
		"\n"
		"\n"
		"Check if constant.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_call", _wrap_MX_is_call, METH_O, "\n"
		"MX_is_call(MX self) -> bool\n"
		"\n"
		"\n"
		"Check if evaluation.\n"
		"\n"
		"\n"
		""},
	 { "MX_which_function", _wrap_MX_which_function, METH_O, "\n"
		"MX_which_function(MX self) -> Function\n"
		"\n"
		"\n"
		"Get function - only valid when is_call() is true.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_output", _wrap_MX_is_output, METH_O, "\n"
		"MX_is_output(MX self) -> bool\n"
		"\n"
		"\n"
		"Check if evaluation output.\n"
		"\n"
		"\n"
		""},
	 { "MX_which_output", _wrap_MX_which_output, METH_O, "\n"
		"MX_which_output(MX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the index of evaluation output - only valid when is_output() is true.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_op", _wrap_MX_is_op, METH_VARARGS, "\n"
		"MX_is_op(MX self, casadi_int op) -> bool\n"
		"\n"
		"\n"
		"Is it a certain operation.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_multiplication", _wrap_MX_is_multiplication, METH_O, "\n"
		"MX_is_multiplication(MX self) -> bool\n"
		"\n"
		"\n"
		"Check if multiplication.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_commutative", _wrap_MX_is_commutative, METH_O, "\n"
		"MX_is_commutative(MX self) -> bool\n"
		"\n"
		"\n"
		"Check if commutative operation.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_norm", _wrap_MX_is_norm, METH_O, "\n"
		"MX_is_norm(MX self) -> bool\n"
		"\n"
		"\n"
		"Check if norm.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_valid_input", _wrap_MX_is_valid_input, METH_O, "\n"
		"MX_is_valid_input(MX self) -> bool\n"
		"\n"
		"\n"
		"Check if matrix can be used to define function inputs. Valid inputs for\n"
		"MXFunctions are combinations of Reshape, concatenations and SymbolicMX.\n"
		"\n"
		"\n"
		""},
	 { "MX_n_primitives", _wrap_MX_n_primitives, METH_O, "\n"
		"MX_n_primitives(MX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of primitives for MXFunction inputs/outputs.\n"
		"\n"
		"\n"
		""},
	 { "MX_primitives", _wrap_MX_primitives, METH_O, "\n"
		"MX_primitives(MX self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"Get primitives.\n"
		"\n"
		"\n"
		""},
	 { "MX_split_primitives", _wrap_MX_split_primitives, METH_VARARGS, "\n"
		"MX_split_primitives(MX self, MX x) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"Split up an expression along symbolic primitives.\n"
		"\n"
		"\n"
		""},
	 { "MX_join_primitives", _wrap_MX_join_primitives, METH_VARARGS, "\n"
		"MX_join_primitives(MX self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & v) -> MX\n"
		"\n"
		"\n"
		"Join an expression along symbolic primitives.\n"
		"\n"
		"\n"
		""},
	 { "MX_has_duplicates", _wrap_MX_has_duplicates, METH_O, "\n"
		"MX_has_duplicates(MX self) -> bool\n"
		"\n"
		"\n"
		"[INTERNAL]  Detect duplicate symbolic expressions If there are symbolic\n"
		"primitives appearing more than once, the function will return true and the\n"
		"names of the duplicate expressions will be passed to casadi_warning. Note:\n"
		"Will mark the node using MX::set_temp. Make sure to call reset_input() after\n"
		"usage.\n"
		"\n"
		"\n"
		""},
	 { "MX_reset_input", _wrap_MX_reset_input, METH_O, "\n"
		"MX_reset_input(MX self)\n"
		"\n"
		"\n"
		"[INTERNAL]  Reset the marker for an input expression.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_eye", _wrap_MX_is_eye, METH_O, "\n"
		"MX_is_eye(MX self) -> bool\n"
		"\n"
		"\n"
		"check if identity\n"
		"\n"
		"\n"
		""},
	 { "MX_is_zero", _wrap_MX_is_zero, METH_O, "\n"
		"MX_is_zero(MX self) -> bool\n"
		"\n"
		"\n"
		"check if zero (note that false negative answers are possible)\n"
		"\n"
		"\n"
		""},
	 { "MX_is_one", _wrap_MX_is_one, METH_O, "\n"
		"MX_is_one(MX self) -> bool\n"
		"\n"
		"\n"
		"check if zero (note that false negative answers are possible)\n"
		"\n"
		"\n"
		""},
	 { "MX_is_minus_one", _wrap_MX_is_minus_one, METH_O, "\n"
		"MX_is_minus_one(MX self) -> bool\n"
		"\n"
		"\n"
		"check if zero (note that false negative answers are possible)\n"
		"\n"
		"\n"
		""},
	 { "MX_is_transpose", _wrap_MX_is_transpose, METH_O, "\n"
		"MX_is_transpose(MX self) -> bool\n"
		"\n"
		"\n"
		"Is the expression a transpose?\n"
		"\n"
		"\n"
		""},
	 { "MX_is_regular", _wrap_MX_is_regular, METH_O, "\n"
		"MX_is_regular(MX self) -> bool\n"
		"\n"
		"\n"
		"Checks if expression does not contain NaN or Inf.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_binary", _wrap_MX_is_binary, METH_O, "\n"
		"MX_is_binary(MX self) -> bool\n"
		"\n"
		"\n"
		"Is binary operation.\n"
		"\n"
		"\n"
		""},
	 { "MX_is_unary", _wrap_MX_is_unary, METH_O, "\n"
		"MX_is_unary(MX self) -> bool\n"
		"\n"
		"\n"
		"Is unary operation.\n"
		"\n"
		"\n"
		""},
	 { "MX_op", _wrap_MX_op, METH_O, "\n"
		"MX_op(MX self) -> casadi_int\n"
		"\n"
		"\n"
		"Get operation type.\n"
		"\n"
		"\n"
		""},
	 { "MX_info", _wrap_MX_info, METH_O, "\n"
		"MX_info(MX self) -> casadi::Dict\n"
		"\n"
		"\n"
		"Obtain information about node\n"
		"\n"
		"\n"
		""},
	 { "MX_serialize", _wrap_MX_serialize, METH_VARARGS, "\n"
		"MX_serialize(MX self, casadi::SerializingStream & s)\n"
		"\n"
		"\n"
		"Serialize an object.\n"
		"\n"
		"\n"
		""},
	 { "MX_deserialize", _wrap_MX_deserialize, METH_O, "MX_deserialize(casadi::DeserializingStream & s) -> MX"},
	 { "MX_get_temp", _wrap_MX_get_temp, METH_O, "\n"
		"MX_get_temp(MX self) -> casadi_int\n"
		"\n"
		"\n"
		"[INTERNAL]  Get the temporary variable\n"
		"\n"
		"\n"
		""},
	 { "MX_set_temp", _wrap_MX_set_temp, METH_VARARGS, "\n"
		"MX_set_temp(MX self, casadi_int t)\n"
		"\n"
		"\n"
		"[INTERNAL]  Set the temporary variable.\n"
		"\n"
		"\n"
		""},
	 { "MX_binary", _wrap_MX_binary, METH_VARARGS, "\n"
		"MX_binary(casadi_int op, MX x, MX y) -> MX\n"
		"\n"
		"\n"
		"Create nodes by their ID.\n"
		"\n"
		"\n"
		""},
	 { "MX_unary", _wrap_MX_unary, METH_VARARGS, "\n"
		"MX_unary(casadi_int op, MX x) -> MX\n"
		"\n"
		"\n"
		"Create nodes by their ID.\n"
		"\n"
		"\n"
		""},
	 { "MX_inf", _wrap_MX_inf, METH_VARARGS, "\n"
		"MX_inf(Sparsity sp) -> MX\n"
		"MX_inf(casadi_int nrow=1, casadi_int ncol=1) -> MX\n"
		"MX_inf(std::pair< casadi_int,casadi_int > const & rc) -> MX\n"
		"\n"
		"\n"
		"create a matrix with all inf\n"
		"\n"
		"\n"
		""},
	 { "MX_nan", _wrap_MX_nan, METH_VARARGS, "\n"
		"MX_nan(Sparsity sp) -> MX\n"
		"MX_nan(casadi_int nrow=1, casadi_int ncol=1) -> MX\n"
		"MX_nan(std::pair< casadi_int,casadi_int > const & rc) -> MX\n"
		"\n"
		"\n"
		"create a matrix with all nan\n"
		"\n"
		"\n"
		""},
	 { "MX_eye", _wrap_MX_eye, METH_O, "MX_eye(casadi_int n) -> MX"},
	 { "MX_get", _wrap_MX_get, METH_VARARGS, "\n"
		"MX_get(MX self, bool ind1, Slice rr)\n"
		"MX_get(MX self, bool ind1, casadi::Matrix< casadi_int > const & rr)\n"
		"MX_get(MX self, bool ind1, Sparsity sp)\n"
		"MX_get(MX self, bool ind1, MX rr)\n"
		"MX_get(MX self, bool ind1, casadi_int const rr)\n"
		"MX_get(MX self, bool ind1, Slice rr, Slice cc)\n"
		"MX_get(MX self, bool ind1, Slice rr, casadi::Matrix< casadi_int > const & cc)\n"
		"MX_get(MX self, bool ind1, Slice rr, casadi_int cc)\n"
		"MX_get(MX self, bool ind1, casadi::Matrix< casadi_int > const & rr, Slice cc)\n"
		"MX_get(MX self, bool ind1, casadi_int rr, Slice cc)\n"
		"MX_get(MX self, bool ind1, casadi::Matrix< casadi_int > const & rr, casadi::Matrix< casadi_int > const & cc)\n"
		"MX_get(MX self, bool ind1, casadi_int rr, casadi_int cc)\n"
		"MX_get(MX self, bool ind1, MX rr, Slice cc)\n"
		"MX_get(MX self, bool ind1, Slice rr, MX cc)\n"
		"MX_get(MX self, bool ind1, MX rr, MX cc)\n"
		"\n"
		"\n"
		"Get a submatrix, two arguments\n"
		"\n"
		"\n"
		""},
	 { "MX_set", _wrap_MX_set, METH_VARARGS, "\n"
		"MX_set(MX self, MX m, bool ind1, Slice rr)\n"
		"MX_set(MX self, MX m, bool ind1, casadi::Matrix< casadi_int > const & rr)\n"
		"MX_set(MX self, MX m, bool ind1, Sparsity sp)\n"
		"MX_set(MX self, MX m, bool ind1, Slice rr, Slice cc)\n"
		"MX_set(MX self, MX m, bool ind1, Slice rr, casadi::Matrix< casadi_int > const & cc)\n"
		"MX_set(MX self, MX m, bool ind1, casadi::Matrix< casadi_int > const & rr, Slice cc)\n"
		"MX_set(MX self, MX m, bool ind1, casadi::Matrix< casadi_int > const & rr, casadi::Matrix< casadi_int > const & cc)\n"
		""},
	 { "MX_get_nz", _wrap_MX_get_nz, METH_VARARGS, "\n"
		"MX_get_nz(MX self, bool ind1, Slice kk)\n"
		"MX_get_nz(MX self, bool ind1, casadi::Matrix< casadi_int > const & kk)\n"
		"MX_get_nz(MX self, bool ind1, MX kk)\n"
		"MX_get_nz(MX self, bool ind1, casadi_int kk)\n"
		"MX_get_nz(MX self, bool ind1, MX inner, Slice outer)\n"
		"MX_get_nz(MX self, bool ind1, Slice inner, MX outer)\n"
		"MX_get_nz(MX self, bool ind1, MX inner, MX outer)\n"
		"\n"
		"\n"
		"Get a set of nonzeros\n"
		"\n"
		"\n"
		""},
	 { "MX_set_nz", _wrap_MX_set_nz, METH_VARARGS, "\n"
		"MX_set_nz(MX self, MX m, bool ind1, Slice kk)\n"
		"MX_set_nz(MX self, MX m, bool ind1, casadi::Matrix< casadi_int > const & kk)\n"
		"MX_set_nz(MX self, MX m, bool ind1, MX kk)\n"
		"MX_set_nz(MX self, MX m, bool ind1, casadi_int kk)\n"
		"\n"
		"\n"
		"Set a set of nonzeros\n"
		"\n"
		"\n"
		""},
	 { "MX_einstein", _wrap_MX_einstein, METH_VARARGS, "\n"
		"MX_einstein(MX A, MX B, MX C, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_a, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_b, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_c, std::vector< casadi_int,std::allocator< casadi_int > > const & a, std::vector< casadi_int,std::allocator< casadi_int > > const & b, std::vector< casadi_int,std::allocator< casadi_int > > const & c) -> MX\n"
		"MX_einstein(MX A, MX B, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_a, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_b, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_c, std::vector< casadi_int,std::allocator< casadi_int > > const & a, std::vector< casadi_int,std::allocator< casadi_int > > const & b, std::vector< casadi_int,std::allocator< casadi_int > > const & c) -> MX\n"
		"\n"
		"\n"
		"Computes an einstein dense tensor contraction.\n"
		"\n"
		"Computes the product: C_c = A_a + B_b where a b c are index/einstein\n"
		"notation in an encoded form\n"
		"\n"
		"For example, an matrix-matrix product may be written as: C_ij = A_ik B_kj\n"
		"\n"
		"The encoded form uses strictly negative numbers to indicate labels. For the\n"
		"above example, we would have: a {-1, -3} b {-3, -2} c {-1 -2}\n"
		"\n"
		"\n"
		""},
	 { "MX_bspline_dual", _wrap_MX_bspline_dual, METH_VARARGS, "\n"
		"MX_bspline_dual(std::vector< double,std::allocator< double > > const & x, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & knots, std::vector< casadi_int,std::allocator< casadi_int > > const & degree, casadi::Dict const & opts=casadi::Dict()) -> DM\n"
		"\n"
		"\n"
		"Find first nonzero If failed, returns the number of rows.\n"
		"\n"
		"\n"
		""},
	 { "MX_interpn_linear", _wrap_MX_interpn_linear, METH_VARARGS, "MX_interpn_linear(std::vector< casadi::MX,std::allocator< casadi::MX > > const & x, MX v, std::vector< casadi::MX,std::allocator< casadi::MX > > const & xq, casadi::Dict const & opts=casadi::Dict()) -> MX"},
	 { "MX_printme", _wrap_MX_printme, METH_VARARGS, "MX_printme(MX self, MX b) -> MX"},
	 { "MX_attachAssert", _wrap_MX_attachAssert, METH_VARARGS, "\n"
		"MX_attachAssert(MX self, MX y, std::string const & fail_message=\"\") -> MX\n"
		"\n"
		"\n"
		"returns itself, but with an assertion attached\n"
		"\n"
		"If y does not evaluate to 1, a runtime error is raised\n"
		"\n"
		"\n"
		""},
	 { "MX_monitor", _wrap_MX_monitor, METH_VARARGS, "\n"
		"MX_monitor(MX self, std::string const & comment) -> MX\n"
		"\n"
		"\n"
		"Monitor an expression Returns itself, but with the side effect of printing\n"
		"the nonzeros along with a comment.\n"
		"\n"
		"\n"
		""},
	 { "MX_mapping", _wrap_MX_mapping, METH_O, "\n"
		"MX_mapping(MX self) -> casadi::Matrix< casadi_int >\n"
		"\n"
		"\n"
		"Get an IM representation of a GetNonzeros or SetNonzeros node.\n"
		"\n"
		"\n"
		""},
	 { "MX_set_max_depth", _wrap_MX_set_max_depth, METH_VARARGS, "MX_set_max_depth(casadi_int eq_depth=1)"},
	 { "MX_get_max_depth", _wrap_MX_get_max_depth, METH_NOARGS, "MX_get_max_depth() -> casadi_int"},
	 { "MX_test_cast", _wrap_MX_test_cast, METH_O, "MX_test_cast(casadi::SharedObjectInternal const * ptr) -> bool"},
	 { "MX_get_input", _wrap_MX_get_input, METH_O, "MX_get_input(Function f) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"},
	 { "MX_get_free", _wrap_MX_get_free, METH_O, "MX_get_free(Function f) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"},
	 { "MX_swigregister", MX_swigregister, METH_O, NULL},
	 { "MX_swiginit", MX_swiginit, METH_VARARGS, NULL},
	 { "Function_type_name", _wrap_Function_type_name, METH_NOARGS, "Function_type_name() -> std::string"},
	 { "Function_jit", _wrap_Function_jit, METH_VARARGS, "\n"
		"Function_jit(std::string const & name, std::string const & body, std::vector< std::string,std::allocator< std::string > > const & name_in, std::vector< std::string,std::allocator< std::string > > const & name_out, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"Function_jit(std::string const & name, std::string const & body, std::vector< std::string,std::allocator< std::string > > const & name_in, std::vector< std::string,std::allocator< std::string > > const & name_out, std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & sparsity_in, std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & sparsity_out, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"To resolve ambiguity on some compilers.\n"
		"\n"
		"Create a just-in-time compiled function from a C language string The names\n"
		"and sparsity patterns of all the inputs and outputs must be provided. If\n"
		"sparsities are not provided, all inputs and outputs are assumed to be\n"
		"scalar. Only specify the function body, assuming that input and output\n"
		"nonzeros are stored in arrays with the specified naming convension. The data\n"
		"type used is 'casadi_real', which is typically equal to 'double` or another\n"
		"data type with the same API as 'double'.\n"
		"\n"
		"Inputs may be null pointers. This means that the all entries are zero.\n"
		"Outputs may be null points. This means that the corresponding result can be\n"
		"ignored.\n"
		"\n"
		"If an error occurs in the evaluation, issue \"return 1;\";\n"
		"\n"
		"The final generated function will have a structure similar to:\n"
		"\n"
		"casadi_int fname(const casadi_real** arg, casadi_real** res, casadi_int* iw,\n"
		"casadi_real* w, void* mem) { const casadi_real *x1, *x2; casadi_real *r1,\n"
		"*r2; x1 = *arg++; x2 = *arg++; r1 = *res++; r2 = *res++; <FUNCTION_BODY>\n"
		"return 0; }\n"
		"\n"
		"\n"
		""},
	 { "delete_Function", _wrap_delete_Function, METH_O, "\n"
		"delete_Function(Function self)\n"
		"\n"
		"\n"
		"Destructor.\n"
		"\n"
		"\n"
		""},
	 { "Function_expand", _wrap_Function_expand, METH_VARARGS, "\n"
		"Function_expand(Function self) -> Function\n"
		"Function_expand(Function self, std::string const & name, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Expand a function to SX.\n"
		"\n"
		"\n"
		""},
	 { "Function_n_in", _wrap_Function_n_in, METH_O, "\n"
		"Function_n_in(Function self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of function inputs.\n"
		"\n"
		"\n"
		""},
	 { "Function_n_out", _wrap_Function_n_out, METH_O, "\n"
		"Function_n_out(Function self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of function outputs.\n"
		"\n"
		"\n"
		""},
	 { "Function_size1_in", _wrap_Function_size1_in, METH_VARARGS, "\n"
		"Function_size1_in(Function self, casadi_int ind) -> casadi_int\n"
		"Function_size1_in(Function self, std::string const & iname) -> casadi_int\n"
		"\n"
		"\n"
		"Get input dimension.\n"
		"\n"
		"\n"
		""},
	 { "Function_size2_in", _wrap_Function_size2_in, METH_VARARGS, "\n"
		"Function_size2_in(Function self, casadi_int ind) -> casadi_int\n"
		"Function_size2_in(Function self, std::string const & iname) -> casadi_int\n"
		"\n"
		"\n"
		"Get input dimension.\n"
		"\n"
		"\n"
		""},
	 { "Function_size_in", _wrap_Function_size_in, METH_VARARGS, "\n"
		"Function_size_in(Function self, casadi_int ind) -> std::pair< casadi_int,casadi_int >\n"
		"Function_size_in(Function self, std::string const & iname) -> std::pair< casadi_int,casadi_int >\n"
		"\n"
		"\n"
		"Get input dimension.\n"
		"\n"
		"\n"
		""},
	 { "Function_size1_out", _wrap_Function_size1_out, METH_VARARGS, "\n"
		"Function_size1_out(Function self, casadi_int ind) -> casadi_int\n"
		"Function_size1_out(Function self, std::string const & oname) -> casadi_int\n"
		"\n"
		"\n"
		"Get output dimension.\n"
		"\n"
		"\n"
		""},
	 { "Function_size2_out", _wrap_Function_size2_out, METH_VARARGS, "\n"
		"Function_size2_out(Function self, casadi_int ind) -> casadi_int\n"
		"Function_size2_out(Function self, std::string const & oname) -> casadi_int\n"
		"\n"
		"\n"
		"Get output dimension.\n"
		"\n"
		"\n"
		""},
	 { "Function_size_out", _wrap_Function_size_out, METH_VARARGS, "\n"
		"Function_size_out(Function self, casadi_int ind) -> std::pair< casadi_int,casadi_int >\n"
		"Function_size_out(Function self, std::string const & oname) -> std::pair< casadi_int,casadi_int >\n"
		"\n"
		"\n"
		"Get output dimension.\n"
		"\n"
		"\n"
		""},
	 { "Function_nnz_in", _wrap_Function_nnz_in, METH_VARARGS, "\n"
		"Function_nnz_in(Function self) -> casadi_int\n"
		"Function_nnz_in(Function self, casadi_int ind) -> casadi_int\n"
		"Function_nnz_in(Function self, std::string const & iname) -> casadi_int\n"
		"\n"
		"\n"
		"Get number of input nonzeros.\n"
		"\n"
		"For a particular input or for all of the inputs\n"
		"\n"
		"\n"
		""},
	 { "Function_nnz_out", _wrap_Function_nnz_out, METH_VARARGS, "\n"
		"Function_nnz_out(Function self) -> casadi_int\n"
		"Function_nnz_out(Function self, casadi_int ind) -> casadi_int\n"
		"Function_nnz_out(Function self, std::string const & oname) -> casadi_int\n"
		"\n"
		"\n"
		"Get number of output nonzeros.\n"
		"\n"
		"For a particular output or for all of the outputs\n"
		"\n"
		"\n"
		""},
	 { "Function_numel_in", _wrap_Function_numel_in, METH_VARARGS, "\n"
		"Function_numel_in(Function self) -> casadi_int\n"
		"Function_numel_in(Function self, casadi_int ind) -> casadi_int\n"
		"Function_numel_in(Function self, std::string const & iname) -> casadi_int\n"
		"\n"
		"\n"
		"Get number of input elements.\n"
		"\n"
		"For a particular input or for all of the inputs\n"
		"\n"
		"\n"
		""},
	 { "Function_numel_out", _wrap_Function_numel_out, METH_VARARGS, "\n"
		"Function_numel_out(Function self) -> casadi_int\n"
		"Function_numel_out(Function self, casadi_int ind) -> casadi_int\n"
		"Function_numel_out(Function self, std::string const & oname) -> casadi_int\n"
		"\n"
		"\n"
		"Get number of output elements.\n"
		"\n"
		"For a particular output or for all of the outputs\n"
		"\n"
		"\n"
		""},
	 { "Function_name_in", _wrap_Function_name_in, METH_VARARGS, "\n"
		"Function_name_in(Function self) -> std::vector< std::string,std::allocator< std::string > > const\n"
		"Function_name_in(Function self, casadi_int ind) -> std::string const &\n"
		"\n"
		"\n"
		"Get input scheme.\n"
		"\n"
		"\n"
		""},
	 { "Function_name_out", _wrap_Function_name_out, METH_VARARGS, "\n"
		"Function_name_out(Function self) -> std::vector< std::string,std::allocator< std::string > > const\n"
		"Function_name_out(Function self, casadi_int ind) -> std::string const &\n"
		"\n"
		"\n"
		"Get output scheme.\n"
		"\n"
		"\n"
		""},
	 { "Function_index_in", _wrap_Function_index_in, METH_VARARGS, "\n"
		"Function_index_in(Function self, std::string const & name) -> casadi_int\n"
		"\n"
		"\n"
		"Find the index for a string describing a particular entry of an input\n"
		"scheme.\n"
		"\n"
		"example: schemeEntry(\"x_opt\") -> returns NLPSOL_X if FunctionInternal\n"
		"adheres to SCHEME_NLPINput\n"
		"\n"
		"\n"
		""},
	 { "Function_index_out", _wrap_Function_index_out, METH_VARARGS, "\n"
		"Function_index_out(Function self, std::string const & name) -> casadi_int\n"
		"\n"
		"\n"
		"Find the index for a string describing a particular entry of an output\n"
		"scheme.\n"
		"\n"
		"example: schemeEntry(\"x_opt\") -> returns NLPSOL_X if FunctionInternal\n"
		"adheres to SCHEME_NLPINput\n"
		"\n"
		"\n"
		""},
	 { "Function_default_in", _wrap_Function_default_in, METH_VARARGS, "\n"
		"Function_default_in(Function self, casadi_int ind) -> double\n"
		"\n"
		"\n"
		"Get default input value.\n"
		"\n"
		"\n"
		""},
	 { "Function_max_in", _wrap_Function_max_in, METH_VARARGS, "\n"
		"Function_max_in(Function self, casadi_int ind) -> double\n"
		"\n"
		"\n"
		"Get largest input value.\n"
		"\n"
		"\n"
		""},
	 { "Function_min_in", _wrap_Function_min_in, METH_VARARGS, "\n"
		"Function_min_in(Function self, casadi_int ind) -> double\n"
		"\n"
		"\n"
		"Get smallest input value.\n"
		"\n"
		"\n"
		""},
	 { "Function_sparsity_in", _wrap_Function_sparsity_in, METH_VARARGS, "\n"
		"Function_sparsity_in(Function self, casadi_int ind) -> Sparsity\n"
		"Function_sparsity_in(Function self, std::string const & iname) -> Sparsity\n"
		"\n"
		"\n"
		"Get sparsity of a given input.\n"
		"\n"
		"\n"
		""},
	 { "Function_sparsity_out", _wrap_Function_sparsity_out, METH_VARARGS, "\n"
		"Function_sparsity_out(Function self, casadi_int ind) -> Sparsity\n"
		"Function_sparsity_out(Function self, std::string const & iname) -> Sparsity\n"
		"\n"
		"\n"
		"Get sparsity of a given output.\n"
		"\n"
		"\n"
		""},
	 { "Function_is_diff_in", _wrap_Function_is_diff_in, METH_VARARGS, "\n"
		"Function_is_diff_in(Function self, casadi_int ind) -> bool\n"
		"Function_is_diff_in(Function self) -> std::vector< bool,std::allocator< bool > >\n"
		"\n"
		"\n"
		"Get differentiability of inputs/output.\n"
		"\n"
		"\n"
		""},
	 { "Function_is_diff_out", _wrap_Function_is_diff_out, METH_VARARGS, "\n"
		"Function_is_diff_out(Function self, casadi_int ind) -> bool\n"
		"Function_is_diff_out(Function self) -> std::vector< bool,std::allocator< bool > >\n"
		"\n"
		"\n"
		"Get differentiability of inputs/output.\n"
		"\n"
		"\n"
		""},
	 { "Function_factory", _wrap_Function_factory, METH_VARARGS, "Function_factory(Function self, std::string const & name, std::vector< std::string,std::allocator< std::string > > const & s_in, std::vector< std::string,std::allocator< std::string > > const & s_out, casadi::Function::AuxOut const & aux=casadi::Function::AuxOut(), casadi::Dict const & opts=casadi::Dict()) -> Function"},
	 { "Function_oracle", _wrap_Function_oracle, METH_O, "\n"
		"Function_oracle(Function self) -> Function\n"
		"\n"
		"\n"
		"Get oracle.\n"
		"\n"
		"\n"
		""},
	 { "Function_wrap", _wrap_Function_wrap, METH_O, "\n"
		"Function_wrap(Function self) -> Function\n"
		"\n"
		"\n"
		"Wrap in an Function instance consisting of only one MX call.\n"
		"\n"
		"\n"
		""},
	 { "Function_wrap_as_needed", _wrap_Function_wrap_as_needed, METH_VARARGS, "\n"
		"Function_wrap_as_needed(Function self, casadi::Dict const & opts) -> Function\n"
		"\n"
		"\n"
		"Wrap in a Function with options.\n"
		"\n"
		"\n"
		""},
	 { "Function_which_depends", _wrap_Function_which_depends, METH_VARARGS, "\n"
		"Function_which_depends(Function self, std::string const & s_in, std::vector< std::string,std::allocator< std::string > > const & s_out, casadi_int order=1, bool tr=False) -> std::vector< bool,std::allocator< bool > >\n"
		"\n"
		"\n"
		"Which variables enter with some order.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"order:  Only 1 (linear) and 2 (nonlinear) allowed\n"
		"\n"
		"tr:  Flip the relationship. Return which expressions contain the variables\n"
		"\n"
		"\n"
		""},
	 { "Function_print_dimensions", _wrap_Function_print_dimensions, METH_O, "\n"
		"Function_print_dimensions(Function self)\n"
		"\n"
		"\n"
		"Print dimensions of inputs and outputs.\n"
		"\n"
		"\n"
		""},
	 { "Function_print_options", _wrap_Function_print_options, METH_O, "\n"
		"Function_print_options(Function self)\n"
		"\n"
		"\n"
		"Print options to a stream.\n"
		"\n"
		"\n"
		""},
	 { "Function_print_option", _wrap_Function_print_option, METH_VARARGS, "\n"
		"Function_print_option(Function self, std::string const & name)\n"
		"\n"
		"\n"
		"Print all information there is to know about a certain option.\n"
		"\n"
		"\n"
		""},
	 { "Function_uses_output", _wrap_Function_uses_output, METH_O, "\n"
		"Function_uses_output(Function self) -> bool\n"
		"\n"
		"\n"
		"Do the derivative functions need nondifferentiated outputs?\n"
		"\n"
		"\n"
		""},
	 { "Function_jacobian_old", _wrap_Function_jacobian_old, METH_VARARGS, "\n"
		"Function_jacobian_old(Function self, casadi_int iind, casadi_int oind) -> Function\n"
		"\n"
		"\n"
		"Generate a Jacobian function of output oind with respect to input iind.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"iind:  The index of the input\n"
		"\n"
		"oind:  The index of the output Legacy function: To be deprecated in a future\n"
		"version of CasADi. Exists only for compatibility with Function::jacobian\n"
		"pre-CasADi 3.2\n"
		"\n"
		"\n"
		""},
	 { "Function_hessian_old", _wrap_Function_hessian_old, METH_VARARGS, "\n"
		"Function_hessian_old(Function self, casadi_int iind, casadi_int oind) -> Function\n"
		"\n"
		"\n"
		"Generate a Hessian function of output oind with respect to input iind.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"iind:  The index of the input\n"
		"\n"
		"oind:  The index of the output Legacy function: To be deprecated in a future\n"
		"version of CasADi. Exists only for compatibility with Function::hessian pre-\n"
		"CasADi 3.2\n"
		"\n"
		"\n"
		""},
	 { "Function_jacobian", _wrap_Function_jacobian, METH_O, "\n"
		"Function_jacobian(Function self) -> Function\n"
		"\n"
		"\n"
		"Generate a Jacobian function of all the inputs elements with respect to all\n"
		"the output elements).\n"
		"\n"
		"\n"
		""},
	 { "Function_jac", _wrap_Function_jac, METH_O, "\n"
		"Function_jac(Function self) -> Function\n"
		"\n"
		"\n"
		"Calculate all Jacobian blocks Generates a function that takes all non-\n"
		"differentiated inputs and outputs and calculates all Jacobian blocks. Inputs\n"
		"that are not needed by the routine are all-zero sparse matrices with the\n"
		"correct dimensions. Output blocks that are not calculated, e.g. if the\n"
		"corresponding input or output is marked non-differentiated are also all-zero\n"
		"sparse. The Jacobian blocks are sorted starting by all the blocks for the\n"
		"first output, then all the blocks for the second output and so on. E.g.\n"
		"f:(x,y)->(r,s) results in the function jac_f:(x,y,r,s)->(dr_dx, dr_dy,\n"
		"ds_dx, ds_dy) This function is cached.\n"
		"\n"
		"\n"
		""},
	 { "Function_call", _wrap_Function_call, METH_VARARGS, "\n"
		"Function_call(Function self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg, bool always_inline=False, bool never_inline=False)\n"
		"Function_call(Function self, std::vector< casadi::SX,std::allocator< casadi::SX > > const & arg, bool always_inline=False, bool never_inline=False)\n"
		"Function_call(Function self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, bool always_inline=False, bool never_inline=False)\n"
		"Function_call(Function self, casadi::DMDict const & arg, bool always_inline=False, bool never_inline=False)\n"
		"Function_call(Function self, casadi::SXDict const & arg, bool always_inline=False, bool never_inline=False)\n"
		"Function_call(Function self, casadi::MXDict const & arg, bool always_inline=False, bool never_inline=False)\n"
		"\n"
		"\n"
		"Generate a Jacobian function of output oind with respect to input iind.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"iind:  The index of the input\n"
		"\n"
		"oind:  The index of the output Legacy function: To be deprecated in a future\n"
		"version of CasADi. Exists only for compatibility with Function::jacobian\n"
		"pre-CasADi 3.2\n"
		"\n"
		"\n"
		""},
	 { "Function_mapsum", _wrap_Function_mapsum, METH_VARARGS, "\n"
		"Function_mapsum(Function self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & x, std::string const & parallelization=\"serial\") -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"Evaluate symbolically in parallel and sum (matrix graph)\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"parallelization:  Type of parallelization used: unroll|serial|openmp\n"
		"\n"
		"\n"
		""},
	 { "Function_mapaccum", _wrap_Function_mapaccum, METH_VARARGS, "\n"
		"Function_mapaccum(Function self, std::string const & name, casadi_int N, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"Function_mapaccum(Function self, std::string const & name, casadi_int N, casadi_int n_accum, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"Function_mapaccum(Function self, std::string const & name, casadi_int n, std::vector< casadi_int,std::allocator< casadi_int > > const & accum_in, std::vector< casadi_int,std::allocator< casadi_int > > const & accum_out, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"Function_mapaccum(Function self, std::string const & name, casadi_int n, std::vector< std::string,std::allocator< std::string > > const & accum_in, std::vector< std::string,std::allocator< std::string > > const & accum_out, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"Function_mapaccum(Function self, casadi_int N, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Create a mapaccumulated version of this function.\n"
		"\n"
		"Suppose the function has a signature of:\n"
		"\n"
		"::\n"
		"\n"
		"     f: (x, u) -> (x_next , y )\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"The the mapaccumulated version has the signature:\n"
		"\n"
		"::\n"
		"\n"
		"     F: (x0, U) -> (X , Y )\n"
		"\n"
		"      with\n"
		"          U: horzcat([u0, u1, ..., u_(N-1)])\n"
		"          X: horzcat([x1, x2, ..., x_N])\n"
		"          Y: horzcat([y0, y1, ..., y_(N-1)])\n"
		"\n"
		"      and\n"
		"          x1, y0 <- f(x0, u0)\n"
		"          x2, y1 <- f(x1, u1)\n"
		"          ...\n"
		"          x_N, y_(N-1) <- f(x_(N-1), u_(N-1))\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"Mapaccum has the following benefits over writing an equivalent for- loop:\n"
		"much faster at construction time\n"
		"\n"
		"potentially much faster compilation times (for codegen)\n"
		"\n"
		"offers a trade-off between memory and evaluation time\n"
		"\n"
		"The base (settable through the options dictionary, default 10), is used to\n"
		"create a tower of function calls, containing unrolled for- loops of length\n"
		"maximum base.\n"
		"\n"
		"This technique is much more scalable in terms of memory-usage, but slightly\n"
		"slower at evaluation, than a plain for-loop. The effect is similar to that\n"
		"of a for-loop with a check-pointing instruction after each chunk of\n"
		"iterations with size base.\n"
		"\n"
		"Set base to -1 to unroll all the way; no gains in memory efficiency here.\n"
		"\n"
		"\n"
		""},
	 { "Function_fold", _wrap_Function_fold, METH_VARARGS, "\n"
		"Function_fold(Function self, casadi_int N, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Create a mapaccumulated version of this function.\n"
		"\n"
		"Suppose the function has a signature of:\n"
		"\n"
		"::\n"
		"\n"
		"     f: (x, u) -> (x_next , y )\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"The the mapaccumulated version has the signature:\n"
		"\n"
		"::\n"
		"\n"
		"     F: (x0, U) -> (X , Y )\n"
		"\n"
		"      with\n"
		"          U: horzcat([u0, u1, ..., u_(N-1)])\n"
		"          X: horzcat([x1, x2, ..., x_N])\n"
		"          Y: horzcat([y0, y1, ..., y_(N-1)])\n"
		"\n"
		"      and\n"
		"          x1, y0 <- f(x0, u0)\n"
		"          x2, y1 <- f(x1, u1)\n"
		"          ...\n"
		"          x_N, y_(N-1) <- f(x_(N-1), u_(N-1))\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"Mapaccum has the following benefits over writing an equivalent for- loop:\n"
		"much faster at construction time\n"
		"\n"
		"potentially much faster compilation times (for codegen)\n"
		"\n"
		"offers a trade-off between memory and evaluation time\n"
		"\n"
		"The base (settable through the options dictionary, default 10), is used to\n"
		"create a tower of function calls, containing unrolled for- loops of length\n"
		"maximum base.\n"
		"\n"
		"This technique is much more scalable in terms of memory-usage, but slightly\n"
		"slower at evaluation, than a plain for-loop. The effect is similar to that\n"
		"of a for-loop with a check-pointing instruction after each chunk of\n"
		"iterations with size base.\n"
		"\n"
		"Set base to -1 to unroll all the way; no gains in memory efficiency here.\n"
		"\n"
		"\n"
		""},
	 { "Function_map", _wrap_Function_map, METH_VARARGS, "\n"
		"Function_map(Function self, casadi_int n, std::string const & parallelization=\"serial\") -> Function\n"
		"Function_map(Function self, casadi_int n, std::string const & parallelization, casadi_int max_num_threads) -> Function\n"
		"Function_map(Function self, std::string const & name, std::string const & parallelization, casadi_int n, std::vector< casadi_int,std::allocator< casadi_int > > const & reduce_in, std::vector< casadi_int,std::allocator< casadi_int > > const & reduce_out, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"Function_map(Function self, std::string const & name, std::string const & parallelization, casadi_int n, std::vector< std::string,std::allocator< std::string > > const & reduce_in, std::vector< std::string,std::allocator< std::string > > const & reduce_out, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"Function_map(Function self, casadi_int n, std::vector< bool,std::allocator< bool > > const & reduce_in, std::vector< bool,std::allocator< bool > > const & reduce_out=std::vector< bool >(), casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Map with reduction A subset of the inputs are non-repeated and a subset of\n"
		"the outputs summed up.\n"
		"\n"
		"\n"
		""},
	 { "Function_slice", _wrap_Function_slice, METH_VARARGS, "\n"
		"Function_slice(Function self, std::string const & name, std::vector< casadi_int,std::allocator< casadi_int > > const & order_in, std::vector< casadi_int,std::allocator< casadi_int > > const & order_out, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"returns a new function with a selection of inputs/outputs of the original\n"
		"\n"
		"\n"
		""},
	 { "Function_conditional", _wrap_Function_conditional, METH_VARARGS, "Function_conditional(std::string const & name, std::vector< casadi::Function,std::allocator< casadi::Function > > const & f, Function f_def, casadi::Dict const & opts=casadi::Dict()) -> Function"},
	 { "Function_bspline", _wrap_Function_bspline, METH_VARARGS, "Function_bspline(std::string const & name, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & knots, std::vector< double,std::allocator< double > > const & coeffs, std::vector< casadi_int,std::allocator< casadi_int > > const & degree, casadi_int m=1, casadi::Dict const & opts=casadi::Dict()) -> Function"},
	 { "Function_if_else", _wrap_Function_if_else, METH_VARARGS, "Function_if_else(std::string const & name, Function f_true, Function f_false, casadi::Dict const & opts=casadi::Dict()) -> Function"},
	 { "Function_forward", _wrap_Function_forward, METH_VARARGS, "\n"
		"Function_forward(Function self, casadi_int nfwd) -> Function\n"
		"\n"
		"\n"
		"Get a function that calculates nfwd forward derivatives.\n"
		"\n"
		"Returns a function with n_in + n_out + n_in inputs and nfwd outputs. The\n"
		"first n_in inputs correspond to nondifferentiated inputs. The next n_out\n"
		"inputs correspond to nondifferentiated outputs. and the last n_in inputs\n"
		"correspond to forward seeds, stacked horizontally The n_out outputs\n"
		"correspond to forward sensitivities, stacked horizontally. * (n_in = n_in(),\n"
		"n_out = n_out())\n"
		"\n"
		"The functions returned are cached, meaning that if called multiple timed\n"
		"with the same value, then multiple references to the same function will be\n"
		"returned.\n"
		"\n"
		"\n"
		""},
	 { "Function_reverse", _wrap_Function_reverse, METH_VARARGS, "\n"
		"Function_reverse(Function self, casadi_int nadj) -> Function\n"
		"\n"
		"\n"
		"Get a function that calculates nadj adjoint derivatives.\n"
		"\n"
		"Returns a function with n_in + n_out + n_out inputs and n_in outputs. The\n"
		"first n_in inputs correspond to nondifferentiated inputs. The next n_out\n"
		"inputs correspond to nondifferentiated outputs. and the last n_out inputs\n"
		"correspond to adjoint seeds, stacked horizontally The n_in outputs\n"
		"correspond to adjoint sensitivities, stacked horizontally. * (n_in = n_in(),\n"
		"n_out = n_out())\n"
		"\n"
		"(n_in = n_in(), n_out = n_out())\n"
		"\n"
		"The functions returned are cached, meaning that if called multiple timed\n"
		"with the same value, then multiple references to the same function will be\n"
		"returned.\n"
		"\n"
		"\n"
		""},
	 { "Function_sparsity_jac", _wrap_Function_sparsity_jac, METH_VARARGS, "\n"
		"Function_sparsity_jac(Function self, casadi_int iind, casadi_int oind, bool compact=False, bool symmetric=False) -> Sparsity\n"
		"Function_sparsity_jac(Function self, std::string const & iind, casadi_int oind=0, bool compact=False, bool symmetric=False) -> Sparsity\n"
		"Function_sparsity_jac(Function self, casadi_int iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Sparsity\n"
		"Function_sparsity_jac(Function self, std::string const & iind, std::string const & oind, bool compact=False, bool symmetric=False) -> Sparsity\n"
		"\n"
		"\n"
		"Get, if necessary generate, the sparsity of a Jacobian block\n"
		"\n"
		"\n"
		""},
	 { "Function_generate", _wrap_Function_generate, METH_VARARGS, "\n"
		"Function_generate(Function self, std::string const & fname, casadi::Dict const & opts=casadi::Dict()) -> std::string\n"
		"Function_generate(Function self, casadi::Dict const & opts=casadi::Dict()) -> std::string\n"
		"\n"
		"\n"
		"Export / Generate C code for the function.\n"
		"\n"
		"\n"
		""},
	 { "Function_generate_dependencies", _wrap_Function_generate_dependencies, METH_VARARGS, "\n"
		"Function_generate_dependencies(Function self, std::string const & fname, casadi::Dict const & opts=casadi::Dict()) -> std::string\n"
		"\n"
		"\n"
		"Export / Generate C code for the dependency function.\n"
		"\n"
		"\n"
		""},
	 { "Function_generate_in", _wrap_Function_generate_in, METH_VARARGS, "\n"
		"Function_generate_in(Function self, std::string const & fname, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg)\n"
		"Function_generate_in(Function self, std::string const & fname) -> std::vector< casadi::DM,std::allocator< casadi::DM > >\n"
		"\n"
		"\n"
		"Export an input file that can be passed to generate C code with a main.\n"
		"\n"
		"generate_out  convert_in to convert between dict/map and vector\n"
		"\n"
		"\n"
		""},
	 { "Function_generate_out", _wrap_Function_generate_out, METH_VARARGS, "\n"
		"Function_generate_out(Function self, std::string const & fname, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg)\n"
		"Function_generate_out(Function self, std::string const & fname) -> std::vector< casadi::DM,std::allocator< casadi::DM > >\n"
		"\n"
		"\n"
		"Export an output file that can be checked with generated C code output.\n"
		"\n"
		"generate_in  convert_out to convert between dict/map and vector\n"
		"\n"
		"\n"
		""},
	 { "Function_serialize", _wrap_Function_serialize, METH_VARARGS, "\n"
		"Function_serialize(Function self, casadi::Dict const & opts=casadi::Dict()) -> std::string\n"
		"\n"
		"\n"
		"Serialize.\n"
		"\n"
		"\n"
		""},
	 { "Function_save", _wrap_Function_save, METH_VARARGS, "\n"
		"Function_save(Function self, std::string const & fname, casadi::Dict const & opts=casadi::Dict())\n"
		"\n"
		"\n"
		"Export function in specific language.\n"
		"\n"
		"Only allowed for (a subset of) SX/MX Functions\n"
		"\n"
		"\n"
		""},
	 { "Function_export_code", _wrap_Function_export_code, METH_VARARGS, "\n"
		"Function_export_code(Function self, std::string const & lang, std::string const & fname, casadi::Dict const & options=casadi::Dict())\n"
		"Function_export_code(Function self, std::string const & lang, casadi::Dict const & options=casadi::Dict()) -> std::string\n"
		"\n"
		"\n"
		"Export function in specific language.\n"
		"\n"
		"Only allowed for (a subset of) SX/MX Functions\n"
		"\n"
		"\n"
		""},
	 { "Function_stats", _wrap_Function_stats, METH_VARARGS, "\n"
		"Function_stats(Function self, int mem=0) -> casadi::Dict\n"
		"\n"
		"\n"
		"Get all statistics obtained at the end of the last evaluate call.\n"
		"\n"
		"\n"
		""},
	 { "Function_sx_in", _wrap_Function_sx_in, METH_VARARGS, "\n"
		"Function_sx_in(Function self, casadi_int iind) -> SX\n"
		"Function_sx_in(Function self, std::string const & iname) -> SX\n"
		"Function_sx_in(Function self) -> std::vector< casadi::SX,std::allocator< casadi::SX > > const\n"
		"\n"
		"\n"
		"Get symbolic primitives equivalent to the input expressions There is no\n"
		"guarantee that subsequent calls return unique answers.\n"
		"\n"
		"\n"
		""},
	 { "Function_mx_in", _wrap_Function_mx_in, METH_VARARGS, "\n"
		"Function_mx_in(Function self, casadi_int ind) -> MX\n"
		"Function_mx_in(Function self, std::string const & iname) -> MX\n"
		"Function_mx_in(Function self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const\n"
		"\n"
		"\n"
		"Get symbolic primitives equivalent to the input expressions There is no\n"
		"guarantee that subsequent calls return unique answers.\n"
		"\n"
		"\n"
		""},
	 { "Function_sx_out", _wrap_Function_sx_out, METH_VARARGS, "\n"
		"Function_sx_out(Function self, casadi_int oind) -> SX\n"
		"Function_sx_out(Function self, std::string const & oname) -> SX\n"
		"Function_sx_out(Function self) -> std::vector< casadi::SX,std::allocator< casadi::SX > > const\n"
		"\n"
		"\n"
		"Get symbolic primitives equivalent to the output expressions There is no\n"
		"guarantee that subsequent calls return unique answers.\n"
		"\n"
		"\n"
		""},
	 { "Function_mx_out", _wrap_Function_mx_out, METH_VARARGS, "\n"
		"Function_mx_out(Function self, casadi_int ind) -> MX\n"
		"Function_mx_out(Function self, std::string const & oname) -> MX\n"
		"Function_mx_out(Function self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const\n"
		"\n"
		"\n"
		"Get symbolic primitives equivalent to the output expressions There is no\n"
		"guarantee that subsequent calls return unique answers.\n"
		"\n"
		"\n"
		""},
	 { "Function_nz_from_in", _wrap_Function_nz_from_in, METH_VARARGS, "\n"
		"Function_nz_from_in(Function self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Convert from/to flat vector of input/output nonzeros.\n"
		"\n"
		"\n"
		""},
	 { "Function_nz_from_out", _wrap_Function_nz_from_out, METH_VARARGS, "\n"
		"Function_nz_from_out(Function self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Convert from/to flat vector of input/output nonzeros.\n"
		"\n"
		"\n"
		""},
	 { "Function_nz_to_in", _wrap_Function_nz_to_in, METH_VARARGS, "\n"
		"Function_nz_to_in(Function self, std::vector< double,std::allocator< double > > const & arg) -> std::vector< casadi::DM,std::allocator< casadi::DM > >\n"
		"\n"
		"\n"
		"Convert from/to flat vector of input/output nonzeros.\n"
		"\n"
		"\n"
		""},
	 { "Function_nz_to_out", _wrap_Function_nz_to_out, METH_VARARGS, "\n"
		"Function_nz_to_out(Function self, std::vector< double,std::allocator< double > > const & arg) -> std::vector< casadi::DM,std::allocator< casadi::DM > >\n"
		"\n"
		"\n"
		"Convert from/to flat vector of input/output nonzeros.\n"
		"\n"
		"\n"
		""},
	 { "Function_convert_in", _wrap_Function_convert_in, METH_VARARGS, "\n"
		"Function_convert_in(Function self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg) -> casadi::DMDict\n"
		"Function_convert_in(Function self, casadi::DMDict const & arg) -> std::vector< casadi::DM,std::allocator< casadi::DM > >\n"
		"Function_convert_in(Function self, std::vector< casadi::SX,std::allocator< casadi::SX > > const & arg) -> casadi::SXDict\n"
		"Function_convert_in(Function self, casadi::SXDict const & arg) -> std::vector< casadi::SX,std::allocator< casadi::SX > >\n"
		"Function_convert_in(Function self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg) -> casadi::MXDict\n"
		"Function_convert_in(Function self, casadi::MXDict const & arg) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"Convert from/to input/output lists/map.\n"
		"\n"
		"Will raise an error when an unknown key is used or a list has incorrect\n"
		"size. Does not perform sparsity checking.\n"
		"\n"
		"\n"
		""},
	 { "Function_convert_out", _wrap_Function_convert_out, METH_VARARGS, "\n"
		"Function_convert_out(Function self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg) -> casadi::DMDict\n"
		"Function_convert_out(Function self, casadi::DMDict const & arg) -> std::vector< casadi::DM,std::allocator< casadi::DM > >\n"
		"Function_convert_out(Function self, std::vector< casadi::SX,std::allocator< casadi::SX > > const & arg) -> casadi::SXDict\n"
		"Function_convert_out(Function self, casadi::SXDict const & arg) -> std::vector< casadi::SX,std::allocator< casadi::SX > >\n"
		"Function_convert_out(Function self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg) -> casadi::MXDict\n"
		"Function_convert_out(Function self, casadi::MXDict const & arg) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"Convert from/to input/output lists/map.\n"
		"\n"
		"Will raise an error when an unknown key is used or a list has incorrect\n"
		"size. Does not perform sparsity checking.\n"
		"\n"
		"\n"
		""},
	 { "Function_has_free", _wrap_Function_has_free, METH_O, "\n"
		"Function_has_free(Function self) -> bool\n"
		"\n"
		"\n"
		"Does the function have free variables.\n"
		"\n"
		"\n"
		""},
	 { "Function_get_free", _wrap_Function_get_free, METH_O, "\n"
		"Function_get_free(Function self) -> std::vector< std::string,std::allocator< std::string > >\n"
		"\n"
		"\n"
		"Get free variables as a string.\n"
		"\n"
		"\n"
		""},
	 { "Function_free_sx", _wrap_Function_free_sx, METH_O, "\n"
		"Function_free_sx(Function self) -> std::vector< casadi::SX,std::allocator< casadi::SX > >\n"
		"\n"
		"\n"
		"Get all the free variables of the function.\n"
		"\n"
		"\n"
		""},
	 { "Function_free_mx", _wrap_Function_free_mx, METH_O, "\n"
		"Function_free_mx(Function self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"Get all the free variables of the function.\n"
		"\n"
		"\n"
		""},
	 { "Function_generate_lifted", _wrap_Function_generate_lifted, METH_O, "\n"
		"Function_generate_lifted(Function self)\n"
		"\n"
		"\n"
		"Extract the functions needed for the Lifted Newton method.\n"
		"\n"
		"\n"
		""},
	 { "Function_n_nodes", _wrap_Function_n_nodes, METH_O, "\n"
		"Function_n_nodes(Function self) -> casadi_int\n"
		"\n"
		"\n"
		"Number of nodes in the algorithm.\n"
		"\n"
		"\n"
		""},
	 { "Function_n_instructions", _wrap_Function_n_instructions, METH_O, "\n"
		"Function_n_instructions(Function self) -> casadi_int\n"
		"\n"
		"\n"
		"Number of instruction in the algorithm (SXFunction/MXFunction)\n"
		"\n"
		"\n"
		""},
	 { "Function_instruction_id", _wrap_Function_instruction_id, METH_VARARGS, "\n"
		"Function_instruction_id(Function self, casadi_int k) -> casadi_int\n"
		"\n"
		"\n"
		"Identifier index of the instruction (SXFunction/MXFunction)\n"
		"\n"
		"\n"
		""},
	 { "Function_instruction_input", _wrap_Function_instruction_input, METH_VARARGS, "\n"
		"Function_instruction_input(Function self, casadi_int k) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Locations in the work vector for the inputs of the instruction\n"
		"(SXFunction/MXFunction)\n"
		"\n"
		"\n"
		""},
	 { "Function_instruction_constant", _wrap_Function_instruction_constant, METH_VARARGS, "\n"
		"Function_instruction_constant(Function self, casadi_int k) -> double\n"
		"\n"
		"\n"
		"Get the floating point output argument of an instruction ( SXFunction)\n"
		"\n"
		"\n"
		""},
	 { "Function_instruction_output", _wrap_Function_instruction_output, METH_VARARGS, "\n"
		"Function_instruction_output(Function self, casadi_int k) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"\n"
		"\n"
		"Location in the work vector for the output of the instruction\n"
		"(SXFunction/MXFunction)\n"
		"\n"
		"\n"
		""},
	 { "Function_instruction_MX", _wrap_Function_instruction_MX, METH_VARARGS, "\n"
		"Function_instruction_MX(Function self, casadi_int k) -> MX\n"
		"\n"
		"\n"
		"Get the MX node corresponding to an instruction ( MXFunction)\n"
		"\n"
		"\n"
		""},
	 { "Function_instructions_sx", _wrap_Function_instructions_sx, METH_O, "\n"
		"Function_instructions_sx(Function self) -> SX\n"
		"\n"
		"\n"
		"Get the SX node corresponding to all instructions ( SXFunction)\n"
		"\n"
		"Note: input and output instructions have no SX representation. This method\n"
		"returns nan for those instructions.\n"
		"\n"
		"\n"
		""},
	 { "Function_has_spfwd", _wrap_Function_has_spfwd, METH_O, "\n"
		"Function_has_spfwd(Function self) -> bool\n"
		"\n"
		"\n"
		"Is the class able to propagate seeds through the algorithm?\n"
		"\n"
		"\n"
		""},
	 { "Function_has_sprev", _wrap_Function_has_sprev, METH_O, "\n"
		"Function_has_sprev(Function self) -> bool\n"
		"\n"
		"\n"
		"Is the class able to propagate seeds through the algorithm?\n"
		"\n"
		"\n"
		""},
	 { "Function_sz_arg", _wrap_Function_sz_arg, METH_O, "\n"
		"Function_sz_arg(Function self) -> size_t\n"
		"\n"
		"\n"
		"Get required length of arg field.\n"
		"\n"
		"\n"
		""},
	 { "Function_sz_res", _wrap_Function_sz_res, METH_O, "\n"
		"Function_sz_res(Function self) -> size_t\n"
		"\n"
		"\n"
		"Get required length of res field.\n"
		"\n"
		"\n"
		""},
	 { "Function_sz_iw", _wrap_Function_sz_iw, METH_O, "\n"
		"Function_sz_iw(Function self) -> size_t\n"
		"\n"
		"\n"
		"Get required length of iw field.\n"
		"\n"
		"\n"
		""},
	 { "Function_sz_w", _wrap_Function_sz_w, METH_O, "\n"
		"Function_sz_w(Function self) -> size_t\n"
		"\n"
		"\n"
		"Get required length of w field.\n"
		"\n"
		"\n"
		""},
	 { "Function_name", _wrap_Function_name, METH_O, "\n"
		"Function_name(Function self) -> std::string\n"
		"\n"
		"\n"
		"Name of the function.\n"
		"\n"
		"\n"
		""},
	 { "Function_is_a", _wrap_Function_is_a, METH_VARARGS, "\n"
		"Function_is_a(Function self, std::string const & type, bool recursive=True) -> bool\n"
		"\n"
		"\n"
		"Check if the function is of a particular type Optionally check if name\n"
		"matches one of the base classes (default true)\n"
		"\n"
		"\n"
		""},
	 { "Function_check_name", _wrap_Function_check_name, METH_O, "Function_check_name(std::string const & name) -> bool"},
	 { "Function_fix_name", _wrap_Function_fix_name, METH_O, "Function_fix_name(std::string const & name) -> std::string"},
	 { "Function_load", _wrap_Function_load, METH_O, "Function_load(std::string const & filename) -> Function"},
	 { "Function_deserialize", _wrap_Function_deserialize, METH_VARARGS, "\n"
		"Function_deserialize(std::istream & stream) -> Function\n"
		"Function_deserialize(std::string const & s) -> Function\n"
		"Function_deserialize(casadi::DeserializingStream & s) -> Function\n"
		""},
	 { "Function_assert_size_in", _wrap_Function_assert_size_in, METH_VARARGS, "\n"
		"Function_assert_size_in(Function self, casadi_int i, casadi_int nrow, casadi_int ncol)\n"
		"\n"
		"\n"
		"Assert that an input dimension is equal so some given value.\n"
		"\n"
		"\n"
		""},
	 { "Function_assert_size_out", _wrap_Function_assert_size_out, METH_VARARGS, "\n"
		"Function_assert_size_out(Function self, casadi_int i, casadi_int nrow, casadi_int ncol)\n"
		"\n"
		"\n"
		"Assert that an output dimension is equal so some given value.\n"
		"\n"
		"\n"
		""},
	 { "Function_checkout", _wrap_Function_checkout, METH_O, "\n"
		"Function_checkout(Function self) -> casadi_int\n"
		"\n"
		"\n"
		"Checkout a memory object.\n"
		"\n"
		"\n"
		""},
	 { "Function_release", _wrap_Function_release, METH_VARARGS, "\n"
		"Function_release(Function self, int mem)\n"
		"\n"
		"\n"
		"Release a memory object.\n"
		"\n"
		"\n"
		""},
	 { "Function_get_function", _wrap_Function_get_function, METH_VARARGS, "\n"
		"Function_get_function(Function self) -> std::vector< std::string,std::allocator< std::string > >\n"
		"Function_get_function(Function self, std::string const & name) -> Function\n"
		""},
	 { "Function_has_function", _wrap_Function_has_function, METH_VARARGS, "Function_has_function(Function self, std::string const & fname) -> bool"},
	 { "Function_info", _wrap_Function_info, METH_O, "\n"
		"Function_info(Function self) -> casadi::Dict\n"
		"\n"
		"\n"
		"Obtain information about function\n"
		"\n"
		"\n"
		""},
	 { "new_Function", _wrap_new_Function, METH_VARARGS, "\n"
		"Function()\n"
		"Function(std::string const & fname)\n"
		"Function(std::string const & name, std::vector< casadi::SX,std::allocator< casadi::SX > > const & ex_in, std::vector< casadi::SX,std::allocator< casadi::SX > > const & ex_out, casadi::Dict const & opts=casadi::Dict())\n"
		"Function(std::string const & name, std::vector< casadi::SX,std::allocator< casadi::SX > > const & ex_in, std::vector< casadi::SX,std::allocator< casadi::SX > > const & ex_out, std::vector< std::string,std::allocator< std::string > > const & name_in, std::vector< std::string,std::allocator< std::string > > const & name_out, casadi::Dict const & opts=casadi::Dict())\n"
		"Function(std::string const & name, std::map< std::string,casadi::SX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::SX > > > const & dict, std::vector< std::string,std::allocator< std::string > > const & name_in, std::vector< std::string,std::allocator< std::string > > const & name_out, casadi::Dict const & opts=casadi::Dict())\n"
		"Function(std::string const & name, std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex_in, std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex_out, casadi::Dict const & opts=casadi::Dict())\n"
		"Function(std::string const & name, std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex_in, std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex_out, std::vector< std::string,std::allocator< std::string > > const & name_in, std::vector< std::string,std::allocator< std::string > > const & name_out, casadi::Dict const & opts=casadi::Dict())\n"
		"Function(std::string const & name, std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const & dict, std::vector< std::string,std::allocator< std::string > > const & name_in, std::vector< std::string,std::allocator< std::string > > const & name_out, casadi::Dict const & opts=casadi::Dict())\n"
		"new_Function(Function other) -> Function\n"
		"\n"
		"\n"
		"Construct an MX function.\n"
		"\n"
		"\n"
		""},
	 { "Function_swigregister", Function_swigregister, METH_O, NULL},
	 { "Function_swiginit", Function_swiginit, METH_VARARGS, NULL},
	 { "FunctionBuffer_set_arg", _wrap_FunctionBuffer_set_arg, METH_VARARGS, "\n"
		"FunctionBuffer_set_arg(FunctionBuffer self, casadi_int i, double const * a)\n"
		"\n"
		"\n"
		"Set input buffer for input i.\n"
		"\n"
		"mem.set_arg(0, memoryview(a))\n"
		"\n"
		"Note that CasADi uses 'fortran' order: column-by-column\n"
		"\n"
		"\n"
		""},
	 { "FunctionBuffer_set_res", _wrap_FunctionBuffer_set_res, METH_VARARGS, "\n"
		"FunctionBuffer_set_res(FunctionBuffer self, casadi_int i, double * a)\n"
		"\n"
		"\n"
		"Set output buffer for ouput i.\n"
		"\n"
		"mem.set_res(0, memoryview(a))\n"
		"\n"
		"Note that CasADi uses 'fortran' order: column-by-column\n"
		"\n"
		"\n"
		""},
	 { "FunctionBuffer_ret", _wrap_FunctionBuffer_ret, METH_O, "\n"
		"FunctionBuffer_ret(FunctionBuffer self) -> int\n"
		"\n"
		"\n"
		"Get last return value.\n"
		"\n"
		"\n"
		""},
	 { "FunctionBuffer__eval", _wrap_FunctionBuffer__eval, METH_O, "FunctionBuffer__eval(FunctionBuffer self)"},
	 { "FunctionBuffer__self", _wrap_FunctionBuffer__self, METH_O, "FunctionBuffer__self(FunctionBuffer self) -> void *"},
	 { "new_FunctionBuffer", _wrap_new_FunctionBuffer, METH_VARARGS, "\n"
		"FunctionBuffer(Function f)\n"
		"new_FunctionBuffer(FunctionBuffer other) -> FunctionBuffer\n"
		"\n"
		"\n"
		"Main constructor.\n"
		"\n"
		"\n"
		""},
	 { "delete_FunctionBuffer", _wrap_delete_FunctionBuffer, METH_O, "delete_FunctionBuffer(FunctionBuffer self)"},
	 { "FunctionBuffer_swigregister", FunctionBuffer_swigregister, METH_O, NULL},
	 { "FunctionBuffer_swiginit", FunctionBuffer_swiginit, METH_VARARGS, NULL},
	 { "_function_buffer_eval", _wrap__function_buffer_eval, METH_O, "_function_buffer_eval(void * raw)"},
	 { "external", _wrap_external, METH_VARARGS, "\n"
		"external(std::string const & name, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"external(std::string const & name, std::string const & bin_name, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"external(std::string const & name, Importer li, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Load an external function from a shared library.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"name:  Name as in the label assigned to a CasADi Function object:\n"
		"Function(name,...,...) Will be used to look up symbols/functions named eg.\n"
		"<name>_eval Use nm (linux/osx) or depends.exe (win) to check which symbols\n"
		"are present in your shared library\n"
		"\n"
		"bin_name:  File name of the shared library\n"
		"\n"
		"\n"
		""},
	 { "integrator", _wrap_integrator, METH_VARARGS, "\n"
		"integrator(std::string const & name, std::string const & solver, casadi::SXDict const & dae, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"integrator(std::string const & name, std::string const & solver, casadi::MXDict const & dae, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Create an ODE/DAE integrator Solves an initial value problem (IVP) coupled\n"
		"to a terminal value problem with differential equation given as an implicit\n"
		"ODE coupled to an algebraic equation and a set of quadratures:\n"
		"\n"
		"\n"
		"\n"
		"::\n"
		"\n"
		"  Initial conditions at t=t0\n"
		"  x(t0)  = x0\n"
		"  q(t0)  = 0\n"
		"\n"
		"  Forward integration from t=t0 to t=tf\n"
		"  der(x) = function(x, z, p, t)                  Forward ODE\n"
		"  0 = fz(x, z, p, t)                  Forward algebraic equations\n"
		"  der(q) = fq(x, z, p, t)                  Forward quadratures\n"
		"\n"
		"  Terminal conditions at t=tf\n"
		"  rx(tf)  = rx0\n"
		"  rq(tf)  = 0\n"
		"\n"
		"  Backward integration from t=tf to t=t0\n"
		"  der(rx) = gx(rx, rz, rp, x, z, p, t)        Backward ODE\n"
		"  0 = gz(rx, rz, rp, x, z, p, t)        Backward algebraic equations\n"
		"  der(rq) = gq(rx, rz, rp, x, z, p, t)        Backward quadratures\n"
		"\n"
		"  where we assume that both the forward and backwards integrations are index-1\n"
		"  (i.e. dfz/dz, dgz/drz are invertible) and furthermore that\n"
		"  gx, gz and gq have a linear dependency on rx, rz and rp.\n"
		"\n"
		"\n"
		"\n"
		"General information\n"
		"===================\n"
		"\n"
		"\n"
		"\n"
		">List of available options\n"
		"\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"|        Id        |      Type       |   Description    |     Used in      |\n"
		"+==================+=================+==================+==================+\n"
		"| augmented_option | OT_DICT         | Options to be    | casadi::Integrat |\n"
		"| s                |                 | passed down to   | or               |\n"
		"|                  |                 | the augmented    |                  |\n"
		"|                  |                 | integrator, if   |                  |\n"
		"|                  |                 | one is           |                  |\n"
		"|                  |                 | constructed.     |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| common_options   | OT_DICT         | Options for      | casadi::OracleFu |\n"
		"|                  |                 | auto-generated   | nction           |\n"
		"|                  |                 | functions        |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| expand           | OT_BOOL         | Replace MX with  | casadi::Integrat |\n"
		"|                  |                 | SX expressions   | or               |\n"
		"|                  |                 | in problem       |                  |\n"
		"|                  |                 | formulation      |                  |\n"
		"|                  |                 | [false]          |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| grid             | OT_DOUBLEVECTOR | Time grid        | casadi::Integrat |\n"
		"|                  |                 |                  | or               |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| monitor          | OT_STRINGVECTOR | Set of user      | casadi::OracleFu |\n"
		"|                  |                 | problem          | nction           |\n"
		"|                  |                 | functions to be  |                  |\n"
		"|                  |                 | monitored        |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| number_of_finite | OT_INT          | Number of finite | casadi::Integrat |\n"
		"| _elements        |                 | elements         | or               |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| output_t0        | OT_BOOL         | Output the state | casadi::Integrat |\n"
		"|                  |                 | at the initial   | or               |\n"
		"|                  |                 | time             |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| print_stats      | OT_BOOL         | Print out        | casadi::Integrat |\n"
		"|                  |                 | statistics after | or               |\n"
		"|                  |                 | integration      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| rootfinder       | OT_STRING       | An implicit      | casadi::Integrat |\n"
		"|                  |                 | function solver  | or               |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| rootfinder_optio | OT_DICT         | Options to be    | casadi::Integrat |\n"
		"| ns               |                 | passed to the    | or               |\n"
		"|                  |                 | NLP Solver       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| show_eval_warnin | OT_BOOL         | Show warnings    | casadi::OracleFu |\n"
		"| gs               |                 | generated from   | nction           |\n"
		"|                  |                 | function         |                  |\n"
		"|                  |                 | evaluations      |                  |\n"
		"|                  |                 | [true]           |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| simplify         | OT_BOOL         | Implement as MX  | casadi::Integrat |\n"
		"|                  |                 | Function (codege | or               |\n"
		"|                  |                 | neratable/serial |                  |\n"
		"|                  |                 | izable) default: |                  |\n"
		"|                  |                 | false            |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| simplify_options | OT_DICT         | Any options to   | casadi::Integrat |\n"
		"|                  |                 | pass to          | or               |\n"
		"|                  |                 | simplified form  |                  |\n"
		"|                  |                 | Function         |                  |\n"
		"|                  |                 | constructor      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| specific_options | OT_DICT         | Options for      | casadi::OracleFu |\n"
		"|                  |                 | specific auto-   | nction           |\n"
		"|                  |                 | generated        |                  |\n"
		"|                  |                 | functions,       |                  |\n"
		"|                  |                 | overwriting the  |                  |\n"
		"|                  |                 | defaults from    |                  |\n"
		"|                  |                 | common_options.  |                  |\n"
		"|                  |                 | Nested           |                  |\n"
		"|                  |                 | dictionary.      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| t0               | OT_DOUBLE       | Beginning of the | casadi::Integrat |\n"
		"|                  |                 | time horizon     | or               |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| tf               | OT_DOUBLE       | End of the time  | casadi::Integrat |\n"
		"|                  |                 | horizon          | or               |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"\n"
		">Input scheme: casadi::IntegratorInput (INTEGRATOR_NUM_IN = 6)\n"
		"\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"|   Full name    | Short |                   Description                   |\n"
		"+================+=======+=================================================+\n"
		"| INTEGRATOR_X0  | x0    | Differential state at the initial time.         |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_P   | p     | Parameters.                                     |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_Z0  | z0    | Initial guess for the algebraic variable.       |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_RX0 | rx0   | Backward differential state at the final time.  |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_RP  | rp    | Backward parameter vector.                      |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_RZ0 | rz0   | Initial guess for the backwards algebraic       |\n"
		"|                |       | variable.                                       |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"\n"
		">Output scheme: casadi::IntegratorOutput (INTEGRATOR_NUM_OUT = 6)\n"
		"\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"|   Full name    | Short |                   Description                   |\n"
		"+================+=======+=================================================+\n"
		"| INTEGRATOR_XF  | xf    | Differential state at the final time.           |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_QF  | qf    | Quadrature state at the final time.             |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_ZF  | zf    | Algebraic variable at the final time.           |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_RXF | rxf   | Backward differential state at the initial      |\n"
		"|                |       | time.                                           |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_RQF | rqf   | Backward quadrature state at the initial time.  |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"| INTEGRATOR_RZF | rzf   | Backward algebraic variable at the initial      |\n"
		"|                |       | time.                                           |\n"
		"+----------------+-------+-------------------------------------------------+\n"
		"\n"
		"List of plugins\n"
		"===============\n"
		"\n"
		"\n"
		"\n"
		"- cvodes\n"
		"\n"
		"- idas\n"
		"\n"
		"- collocation\n"
		"\n"
		"- rk\n"
		"\n"
		"Note: some of the plugins in this list might not be available on your\n"
		"system. Also, there might be extra plugins available to you that are not\n"
		"listed here. You can obtain their documentation with\n"
		"Integrator.doc(\"myextraplugin\")\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"cvodes\n"
		"------\n"
		"\n"
		"\n"
		"\n"
		"Interface to CVodes from the Sundials suite.\n"
		"\n"
		"A call to evaluate will integrate to the end.\n"
		"\n"
		"You can retrieve the entire state trajectory as follows, after the evaluate\n"
		"call: Call reset. Then call integrate(t_i) and getOuput for a series of\n"
		"times t_i.\n"
		"\n"
		">List of available options\n"
		"\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"|             Id             |   Type    |           Description           |\n"
		"+============================+===========+=================================+\n"
		"| abstol                     | OT_DOUBLE | Absolute tolerence for the IVP  |\n"
		"|                            |           | solution                        |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| disable_internal_warnings  | OT_BOOL   | Disable SUNDIALS internal       |\n"
		"|                            |           | warning messages                |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| fsens_all_at_once          | OT_BOOL   | Calculate all right hand sides  |\n"
		"|                            |           | of the sensitivity equations at |\n"
		"|                            |           | once                            |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| fsens_err_con              | OT_BOOL   | include the forward             |\n"
		"|                            |           | sensitivities in all error      |\n"
		"|                            |           | controls                        |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| interpolation_type         | OT_STRING | Type of interpolation for the   |\n"
		"|                            |           | adjoint sensitivities           |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| linear_multistep_method    | OT_STRING | Integrator scheme: BDF|adams    |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| linear_solver              | OT_STRING | A custom linear solver creator  |\n"
		"|                            |           | function [default: qr]          |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| linear_solver_options      | OT_DICT   | Options to be passed to the     |\n"
		"|                            |           | linear solver                   |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| max_krylov                 | OT_INT    | Maximum Krylov subspace size    |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| max_multistep_order        | OT_INT    | Maximum order for the           |\n"
		"|                            |           | (variable-order) multistep      |\n"
		"|                            |           | method                          |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| max_num_steps              | OT_INT    | Maximum number of integrator    |\n"
		"|                            |           | steps                           |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| max_order                  | OT_DOUBLE | Maximum order                   |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| max_step_size              | OT_DOUBLE | Max step size [default: 0/inf]  |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| min_step_size              | OT_DOUBLE | Min step size [default: 0/0.0]  |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| newton_scheme              | OT_STRING | Linear solver scheme in the     |\n"
		"|                            |           | Newton method:                  |\n"
		"|                            |           | DIRECT|gmres|bcgstab|tfqmr      |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| nonlin_conv_coeff          | OT_DOUBLE | Coefficient in the nonlinear    |\n"
		"|                            |           | convergence test                |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| nonlinear_solver_iteration | OT_STRING | Nonlinear solver type:          |\n"
		"|                            |           | NEWTON|functional               |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| quad_err_con               | OT_BOOL   | Should the quadratures affect   |\n"
		"|                            |           | the step size control           |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| reltol                     | OT_DOUBLE | Relative tolerence for the IVP  |\n"
		"|                            |           | solution                        |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| second_order_correction    | OT_BOOL   | Second order correction in the  |\n"
		"|                            |           | augmented system Jacobian       |\n"
		"|                            |           | [true]                          |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| sensitivity_method         | OT_STRING | Sensitivity method:             |\n"
		"|                            |           | SIMULTANEOUS|staggered          |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| step0                      | OT_DOUBLE | initial step size [default:     |\n"
		"|                            |           | 0/estimated]                    |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| steps_per_checkpoint       | OT_INT    | Number of steps between two     |\n"
		"|                            |           | consecutive checkpoints         |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| stop_at_end                | OT_BOOL   | Stop the integrator at the end  |\n"
		"|                            |           | of the interval                 |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"| use_preconditioner         | OT_BOOL   | Precondition the iterative      |\n"
		"|                            |           | solver [default: true]          |\n"
		"+----------------------------+-----------+---------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"idas\n"
		"----\n"
		"\n"
		"\n"
		"\n"
		"Interface to IDAS from the Sundials suite.\n"
		"\n"
		">List of available options\n"
		"\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"|            Id             |      Type       |        Description         |\n"
		"+===========================+=================+============================+\n"
		"| abstol                    | OT_DOUBLE       | Absolute tolerence for the |\n"
		"|                           |                 | IVP solution               |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| abstolv                   | OT_DOUBLEVECTOR | Absolute tolerarance for   |\n"
		"|                           |                 | each component             |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| calc_ic                   | OT_BOOL         | Use IDACalcIC to get       |\n"
		"|                           |                 | consistent initial         |\n"
		"|                           |                 | conditions.                |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| calc_icB                  | OT_BOOL         | Use IDACalcIC to get       |\n"
		"|                           |                 | consistent initial         |\n"
		"|                           |                 | conditions for backwards   |\n"
		"|                           |                 | system [default: equal to  |\n"
		"|                           |                 | calc_ic].                  |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| cj_scaling                | OT_BOOL         | IDAS scaling on cj for the |\n"
		"|                           |                 | user-defined linear solver |\n"
		"|                           |                 | module                     |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| constraints               | OT_INTVECTOR    | Constrain the solution     |\n"
		"|                           |                 | y=[x,z]. 0 (default): no   |\n"
		"|                           |                 | constraint on yi, 1: yi >= |\n"
		"|                           |                 | 0.0, -1: yi <= 0.0, 2: yi  |\n"
		"|                           |                 | > 0.0, -2: yi < 0.0.       |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| disable_internal_warnings | OT_BOOL         | Disable SUNDIALS internal  |\n"
		"|                           |                 | warning messages           |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| first_time                | OT_DOUBLE       | First requested time as a  |\n"
		"|                           |                 | fraction of the time       |\n"
		"|                           |                 | interval                   |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| fsens_err_con             | OT_BOOL         | include the forward        |\n"
		"|                           |                 | sensitivities in all error |\n"
		"|                           |                 | controls                   |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| init_xdot                 | OT_DOUBLEVECTOR | Initial values for the     |\n"
		"|                           |                 | state derivatives          |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| interpolation_type        | OT_STRING       | Type of interpolation for  |\n"
		"|                           |                 | the adjoint sensitivities  |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| linear_solver             | OT_STRING       | A custom linear solver     |\n"
		"|                           |                 | creator function [default: |\n"
		"|                           |                 | qr]                        |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| linear_solver_options     | OT_DICT         | Options to be passed to    |\n"
		"|                           |                 | the linear solver          |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| max_krylov                | OT_INT          | Maximum Krylov subspace    |\n"
		"|                           |                 | size                       |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| max_multistep_order       | OT_INT          | Maximum order for the      |\n"
		"|                           |                 | (variable-order) multistep |\n"
		"|                           |                 | method                     |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| max_num_steps             | OT_INT          | Maximum number of          |\n"
		"|                           |                 | integrator steps           |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| max_order                 | OT_DOUBLE       | Maximum order              |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| max_step_size             | OT_DOUBLE       | Maximim step size          |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| newton_scheme             | OT_STRING       | Linear solver scheme in    |\n"
		"|                           |                 | the Newton method:         |\n"
		"|                           |                 | DIRECT|gmres|bcgstab|tfqmr |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| nonlin_conv_coeff         | OT_DOUBLE       | Coefficient in the         |\n"
		"|                           |                 | nonlinear convergence test |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| quad_err_con              | OT_BOOL         | Should the quadratures     |\n"
		"|                           |                 | affect the step size       |\n"
		"|                           |                 | control                    |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| reltol                    | OT_DOUBLE       | Relative tolerence for the |\n"
		"|                           |                 | IVP solution               |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| second_order_correction   | OT_BOOL         | Second order correction in |\n"
		"|                           |                 | the augmented system       |\n"
		"|                           |                 | Jacobian [true]            |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| sensitivity_method        | OT_STRING       | Sensitivity method:        |\n"
		"|                           |                 | SIMULTANEOUS|staggered     |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| step0                     | OT_DOUBLE       | initial step size          |\n"
		"|                           |                 | [default: 0/estimated]     |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| steps_per_checkpoint      | OT_INT          | Number of steps between    |\n"
		"|                           |                 | two consecutive            |\n"
		"|                           |                 | checkpoints                |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| stop_at_end               | OT_BOOL         | Stop the integrator at the |\n"
		"|                           |                 | end of the interval        |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| suppress_algebraic        | OT_BOOL         | Suppress algebraic         |\n"
		"|                           |                 | variables in the error     |\n"
		"|                           |                 | testing                    |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| use_preconditioner        | OT_BOOL         | Precondition the iterative |\n"
		"|                           |                 | solver [default: true]     |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"collocation\n"
		"-----------\n"
		"\n"
		"\n"
		"\n"
		"Fixed-step implicit Runge-Kutta integrator ODE/DAE integrator based on\n"
		"collocation schemes\n"
		"\n"
		"The method is still under development\n"
		"\n"
		">List of available options\n"
		"\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"|            Id             |      Type       |        Description         |\n"
		"+===========================+=================+============================+\n"
		"| augmented_options         | OT_DICT         | Options to be passed down  |\n"
		"|                           |                 | to the augmented           |\n"
		"|                           |                 | integrator, if one is      |\n"
		"|                           |                 | constructed.               |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| collocation_scheme        | OT_STRING       | Collocation scheme:        |\n"
		"|                           |                 | radau|legendre             |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| expand                    | OT_BOOL         | Replace MX with SX         |\n"
		"|                           |                 | expressions in problem     |\n"
		"|                           |                 | formulation [false]        |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| grid                      | OT_DOUBLEVECTOR | Time grid                  |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| interpolation_order       | OT_INT          | Order of the interpolating |\n"
		"|                           |                 | polynomials                |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| number_of_finite_elements | OT_INT          | Number of finite elements  |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| output_t0                 | OT_BOOL         | Output the state at the    |\n"
		"|                           |                 | initial time               |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| print_stats               | OT_BOOL         | Print out statistics after |\n"
		"|                           |                 | integration                |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| rootfinder                | OT_STRING       | An implicit function       |\n"
		"|                           |                 | solver                     |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| rootfinder_options        | OT_DICT         | Options to be passed to    |\n"
		"|                           |                 | the NLP Solver             |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| simplify                  | OT_BOOL         | Implement as MX  Function  |\n"
		"|                           |                 | (codegeneratable/serializa |\n"
		"|                           |                 | ble) default: false        |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| simplify_options          | OT_DICT         | Any options to pass to     |\n"
		"|                           |                 | simplified form Function   |\n"
		"|                           |                 | constructor                |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| t0                        | OT_DOUBLE       | Beginning of the time      |\n"
		"|                           |                 | horizon                    |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"| tf                        | OT_DOUBLE       | End of the time horizon    |\n"
		"+---------------------------+-----------------+----------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"rk --\n"
		"\n"
		"\n"
		"\n"
		"Fixed-step explicit Runge-Kutta integrator for ODEs Currently implements\n"
		"RK4.\n"
		"\n"
		"The method is still under development\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"Joel Andersson\n"
		"\n"
		"\n"
		""},
	 { "has_integrator", _wrap_has_integrator, METH_O, "\n"
		"has_integrator(std::string const & name) -> bool\n"
		"\n"
		"\n"
		"Check if a particular plugin is available.\n"
		"\n"
		"\n"
		""},
	 { "load_integrator", _wrap_load_integrator, METH_O, "\n"
		"load_integrator(std::string const & name)\n"
		"\n"
		"\n"
		"Explicitly load a plugin dynamically.\n"
		"\n"
		"\n"
		""},
	 { "doc_integrator", _wrap_doc_integrator, METH_O, "\n"
		"doc_integrator(std::string const & name) -> std::string\n"
		"\n"
		"\n"
		"Get the documentation string for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "integrator_in", _wrap_integrator_in, METH_VARARGS, "\n"
		"integrator_in() -> std::vector< std::string,std::allocator< std::string > >\n"
		"integrator_in(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get input scheme of integrators.\n"
		"\n"
		"\n"
		""},
	 { "integrator_out", _wrap_integrator_out, METH_VARARGS, "\n"
		"integrator_out() -> std::vector< std::string,std::allocator< std::string > >\n"
		"integrator_out(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get integrator output scheme of integrators.\n"
		"\n"
		"\n"
		""},
	 { "integrator_n_in", _wrap_integrator_n_in, METH_NOARGS, "\n"
		"integrator_n_in() -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of integrator inputs.\n"
		"\n"
		"\n"
		""},
	 { "integrator_n_out", _wrap_integrator_n_out, METH_NOARGS, "\n"
		"integrator_n_out() -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of integrator outputs.\n"
		"\n"
		"\n"
		""},
	 { "conic", _wrap_conic, METH_VARARGS, "\n"
		"conic(std::string const & name, std::string const & solver, casadi::SpDict const & qp, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Create a QP solver Solves the following strictly convex problem:\n"
		"\n"
		"\n"
		"\n"
		"::\n"
		"\n"
		"  min          1/2 x' H x + g' x\n"
		"  x\n"
		"\n"
		"  subject to\n"
		"  LBA <= A x <= UBA\n"
		"  LBX <= x   <= UBX\n"
		"\n"
		"  resize(Q x, np, np) + P >= 0 (psd)\n"
		"\n"
		"  with :\n"
		"  H sparse (n x n) positive definite\n"
		"  g dense  (n x 1)\n"
		"  A sparse (nc x n)\n"
		"  Q sparse symmetric (np^2 x n)\n"
		"  P sparse symmetric (np x nq)\n"
		"\n"
		"  n: number of decision variables (x)\n"
		"  nc: number of constraints (A)\n"
		"  nq: shape of psd constraint matrix\n"
		"\n"
		"\n"
		"\n"
		"If H is not positive-definite, the solver should throw an error.\n"
		"\n"
		"Second-order cone constraints can be added as psd constraints through a\n"
		"helper function 'soc':\n"
		"\n"
		"x in R^n y in R\n"
		"\n"
		"|| x ||_2 <= y\n"
		"\n"
		"<=>\n"
		"\n"
		"soc(x, y) psd\n"
		"\n"
		"This can be proven with soc(x, y)=[y*I x; x' y] using the Shur complement.\n"
		"\n"
		"General information\n"
		"===================\n"
		"\n"
		"\n"
		"\n"
		">List of available options\n"
		"\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"|        Id        |      Type       |   Description    |     Used in      |\n"
		"+==================+=================+==================+==================+\n"
		"| ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |\n"
		"|                  |                 | for derivative   | Internal         |\n"
		"|                  |                 | calculation.When |                  |\n"
		"|                  |                 | there is an      |                  |\n"
		"|                  |                 | option of either |                  |\n"
		"|                  |                 | using forward or |                  |\n"
		"|                  |                 | reverse mode     |                  |\n"
		"|                  |                 | directional      |                  |\n"
		"|                  |                 | derivatives, the |                  |\n"
		"|                  |                 | condition ad_wei |                  |\n"
		"|                  |                 | ght*nf<=(1-ad_we |                  |\n"
		"|                  |                 | ight)*na is used |                  |\n"
		"|                  |                 | where nf and na  |                  |\n"
		"|                  |                 | are estimates of |                  |\n"
		"|                  |                 | the number of    |                  |\n"
		"|                  |                 | forward/reverse  |                  |\n"
		"|                  |                 | mode directional |                  |\n"
		"|                  |                 | derivatives      |                  |\n"
		"|                  |                 | needed. By       |                  |\n"
		"|                  |                 | default,         |                  |\n"
		"|                  |                 | ad_weight is     |                  |\n"
		"|                  |                 | calculated       |                  |\n"
		"|                  |                 | automatically,   |                  |\n"
		"|                  |                 | but this can be  |                  |\n"
		"|                  |                 | overridden by    |                  |\n"
		"|                  |                 | setting this     |                  |\n"
		"|                  |                 | option. In       |                  |\n"
		"|                  |                 | particular, 0    |                  |\n"
		"|                  |                 | means forcing    |                  |\n"
		"|                  |                 | forward mode and |                  |\n"
		"|                  |                 | 1 forcing        |                  |\n"
		"|                  |                 | reverse mode.    |                  |\n"
		"|                  |                 | Leave unset for  |                  |\n"
		"|                  |                 | (class specific) |                  |\n"
		"|                  |                 | heuristics.      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |\n"
		"|                  |                 | for sparsity     | Internal         |\n"
		"|                  |                 | pattern          |                  |\n"
		"|                  |                 | calculation calc |                  |\n"
		"|                  |                 | ulation.Override |                  |\n"
		"|                  |                 | s default        |                  |\n"
		"|                  |                 | behavior. Set to |                  |\n"
		"|                  |                 | 0 and 1 to force |                  |\n"
		"|                  |                 | forward and      |                  |\n"
		"|                  |                 | reverse mode     |                  |\n"
		"|                  |                 | respectively.    |                  |\n"
		"|                  |                 | Cf. option       |                  |\n"
		"|                  |                 | \"ad_weight\".     |                  |\n"
		"|                  |                 | When set to -1,  |                  |\n"
		"|                  |                 | sparsity is      |                  |\n"
		"|                  |                 | completely       |                  |\n"
		"|                  |                 | ignored and      |                  |\n"
		"|                  |                 | dense matrices   |                  |\n"
		"|                  |                 | are used.        |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| always_inline    | OT_BOOL         | Force inlining.  | casadi::Function |\n"
		"|                  |                 |                  | Internal         |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| compiler         | OT_STRING       | Just-in-time     | casadi::Function |\n"
		"|                  |                 | compiler plugin  | Internal         |\n"
		"|                  |                 | to be used.      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| custom_jacobian  | OT_FUNCTION     | Override         | casadi::Function |\n"
		"|                  |                 | CasADi's AD. Use | Internal         |\n"
		"|                  |                 | together with    |                  |\n"
		"|                  |                 | 'jac_penalty':   |                  |\n"
		"|                  |                 | 0. Note: Highly  |                  |\n"
		"|                  |                 | experimental.    |                  |\n"
		"|                  |                 | Syntax may break |                  |\n"
		"|                  |                 | often.           |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |\n"
		"|                  |                 | a derivative of  | Internal         |\n"
		"|                  |                 | another          |                  |\n"
		"|                  |                 | function. The    |                  |\n"
		"|                  |                 | type of          |                  |\n"
		"|                  |                 | derivative       |                  |\n"
		"|                  |                 | (directional     |                  |\n"
		"|                  |                 | derivative,      |                  |\n"
		"|                  |                 | Jacobian) is     |                  |\n"
		"|                  |                 | inferred from    |                  |\n"
		"|                  |                 | the function     |                  |\n"
		"|                  |                 | name.            |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| discrete         | OT_BOOLVECTOR   | Indicates which  | casadi::Conic    |\n"
		"|                  |                 | of the variables |                  |\n"
		"|                  |                 | are discrete,    |                  |\n"
		"|                  |                 | i.e. integer-    |                  |\n"
		"|                  |                 | valued           |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump             | OT_BOOL         | Dump function to | casadi::Function |\n"
		"|                  |                 | file upon first  | Internal         |\n"
		"|                  |                 | evaluation.      |                  |\n"
		"|                  |                 | [false]          |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump_dir         | OT_STRING       | Directory to     | casadi::Function |\n"
		"|                  |                 | dump             | Internal         |\n"
		"|                  |                 | inputs/outputs   |                  |\n"
		"|                  |                 | to. Make sure    |                  |\n"
		"|                  |                 | the directory    |                  |\n"
		"|                  |                 | exists [.]       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump_format      | OT_STRING       | Choose file      | casadi::Function |\n"
		"|                  |                 | format to dump   | Internal         |\n"
		"|                  |                 | matrices. See    |                  |\n"
		"|                  |                 | DM.from_file     |                  |\n"
		"|                  |                 | [mtx]            |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump_in          | OT_BOOL         | Dump numerical   | casadi::Function |\n"
		"|                  |                 | values of inputs | Internal         |\n"
		"|                  |                 | to file          |                  |\n"
		"|                  |                 | (readable with   |                  |\n"
		"|                  |                 | DM.from_file )   |                  |\n"
		"|                  |                 | [default: false] |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump_out         | OT_BOOL         | Dump numerical   | casadi::Function |\n"
		"|                  |                 | values of        | Internal         |\n"
		"|                  |                 | outputs to file  |                  |\n"
		"|                  |                 | (readable with   |                  |\n"
		"|                  |                 | DM.from_file )   |                  |\n"
		"|                  |                 | [default: false] |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| enable_fd        | OT_BOOL         | Enable           | casadi::Function |\n"
		"|                  |                 | derivative       | Internal         |\n"
		"|                  |                 | calculation by   |                  |\n"
		"|                  |                 | finite           |                  |\n"
		"|                  |                 | differencing.    |                  |\n"
		"|                  |                 | [default:        |                  |\n"
		"|                  |                 | false]]          |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| enable_forward   | OT_BOOL         | Enable           | casadi::Function |\n"
		"|                  |                 | derivative       | Internal         |\n"
		"|                  |                 | calculation      |                  |\n"
		"|                  |                 | using generated  |                  |\n"
		"|                  |                 | functions for    |                  |\n"
		"|                  |                 | Jacobian-times-  |                  |\n"
		"|                  |                 | vector products  |                  |\n"
		"|                  |                 | - typically      |                  |\n"
		"|                  |                 | using forward    |                  |\n"
		"|                  |                 | mode AD - if     |                  |\n"
		"|                  |                 | available.       |                  |\n"
		"|                  |                 | [default: true]  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| enable_jacobian  | OT_BOOL         | Enable           | casadi::Function |\n"
		"|                  |                 | derivative       | Internal         |\n"
		"|                  |                 | calculation      |                  |\n"
		"|                  |                 | using generated  |                  |\n"
		"|                  |                 | functions for    |                  |\n"
		"|                  |                 | Jacobians of all |                  |\n"
		"|                  |                 | differentiable   |                  |\n"
		"|                  |                 | outputs with     |                  |\n"
		"|                  |                 | respect to all   |                  |\n"
		"|                  |                 | differentiable   |                  |\n"
		"|                  |                 | inputs - if      |                  |\n"
		"|                  |                 | available.       |                  |\n"
		"|                  |                 | [default: true]  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| enable_reverse   | OT_BOOL         | Enable           | casadi::Function |\n"
		"|                  |                 | derivative       | Internal         |\n"
		"|                  |                 | calculation      |                  |\n"
		"|                  |                 | using generated  |                  |\n"
		"|                  |                 | functions for    |                  |\n"
		"|                  |                 | transposed       |                  |\n"
		"|                  |                 | Jacobian-times-  |                  |\n"
		"|                  |                 | vector products  |                  |\n"
		"|                  |                 | - typically      |                  |\n"
		"|                  |                 | using reverse    |                  |\n"
		"|                  |                 | mode AD - if     |                  |\n"
		"|                  |                 | available.       |                  |\n"
		"|                  |                 | [default: true]  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| error_on_fail    | OT_BOOL         | When the         | casadi::Conic    |\n"
		"|                  |                 | numerical        |                  |\n"
		"|                  |                 | process returns  |                  |\n"
		"|                  |                 | unsuccessfully,  |                  |\n"
		"|                  |                 | raise an error   |                  |\n"
		"|                  |                 | (default false). |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| fd_method        | OT_STRING       | Method for       | casadi::Function |\n"
		"|                  |                 | finite           | Internal         |\n"
		"|                  |                 | differencing     |                  |\n"
		"|                  |                 | [default         |                  |\n"
		"|                  |                 | 'central']       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| fd_options       | OT_DICT         | Options to be    | casadi::Function |\n"
		"|                  |                 | passed to the    | Internal         |\n"
		"|                  |                 | finite           |                  |\n"
		"|                  |                 | difference       |                  |\n"
		"|                  |                 | instance         |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| forward_options  | OT_DICT         | Options to be    | casadi::Function |\n"
		"|                  |                 | passed to a      | Internal         |\n"
		"|                  |                 | forward mode     |                  |\n"
		"|                  |                 | constructor      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |\n"
		"|                  |                 | option           | Internal         |\n"
		"|                  |                 | (ignored):       |                  |\n"
		"|                  |                 | Statistics are   |                  |\n"
		"|                  |                 | now always       |                  |\n"
		"|                  |                 | collected.       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| input_scheme     | OT_STRINGVECTOR | Deprecated       | casadi::Function |\n"
		"|                  |                 | option (ignored) | Internal         |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |\n"
		"|                  |                 | when the         | Internal         |\n"
		"|                  |                 | numerical values |                  |\n"
		"|                  |                 | of the inputs    |                  |\n"
		"|                  |                 | don't make sense |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| is_diff_in       | OT_BOOLVECTOR   | Indicate for     | casadi::Function |\n"
		"|                  |                 | each input if it | Internal         |\n"
		"|                  |                 | should be        |                  |\n"
		"|                  |                 | differentiable.  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| is_diff_out      | OT_BOOLVECTOR   | Indicate for     | casadi::Function |\n"
		"|                  |                 | each output if   | Internal         |\n"
		"|                  |                 | it should be     |                  |\n"
		"|                  |                 | differentiable.  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |\n"
		"|                  |                 | for a number of  | Internal         |\n"
		"|                  |                 | forward/reverse  |                  |\n"
		"|                  |                 | directions, it   |                  |\n"
		"|                  |                 | may be cheaper   |                  |\n"
		"|                  |                 | to compute first |                  |\n"
		"|                  |                 | the full         |                  |\n"
		"|                  |                 | jacobian and     |                  |\n"
		"|                  |                 | then multiply    |                  |\n"
		"|                  |                 | with seeds,      |                  |\n"
		"|                  |                 | rather than      |                  |\n"
		"|                  |                 | obtain the       |                  |\n"
		"|                  |                 | requested        |                  |\n"
		"|                  |                 | directions in a  |                  |\n"
		"|                  |                 | straightforward  |                  |\n"
		"|                  |                 | manner. Casadi   |                  |\n"
		"|                  |                 | uses a heuristic |                  |\n"
		"|                  |                 | to decide which  |                  |\n"
		"|                  |                 | is cheaper. A    |                  |\n"
		"|                  |                 | high value of    |                  |\n"
		"|                  |                 | 'jac_penalty'    |                  |\n"
		"|                  |                 | makes it less    |                  |\n"
		"|                  |                 | likely for the   |                  |\n"
		"|                  |                 | heurstic to      |                  |\n"
		"|                  |                 | chose the full   |                  |\n"
		"|                  |                 | Jacobian         |                  |\n"
		"|                  |                 | strategy. The    |                  |\n"
		"|                  |                 | special value -1 |                  |\n"
		"|                  |                 | indicates never  |                  |\n"
		"|                  |                 | to use the full  |                  |\n"
		"|                  |                 | Jacobian         |                  |\n"
		"|                  |                 | strategy         |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit              | OT_BOOL         | Use just-in-time | casadi::Function |\n"
		"|                  |                 | compiler to      | Internal         |\n"
		"|                  |                 | speed up the     |                  |\n"
		"|                  |                 | evaluation       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_cleanup      | OT_BOOL         | Cleanup up the   | casadi::Function |\n"
		"|                  |                 | temporary source | Internal         |\n"
		"|                  |                 | file that jit    |                  |\n"
		"|                  |                 | creates.         |                  |\n"
		"|                  |                 | Default: true    |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_name         | OT_STRING       | The file name    | casadi::Function |\n"
		"|                  |                 | used to write    | Internal         |\n"
		"|                  |                 | out code. The    |                  |\n"
		"|                  |                 | actual file      |                  |\n"
		"|                  |                 | names used       |                  |\n"
		"|                  |                 | depend on 'jit_t |                  |\n"
		"|                  |                 | emp_suffix' and  |                  |\n"
		"|                  |                 | include          |                  |\n"
		"|                  |                 | extensions.      |                  |\n"
		"|                  |                 | Default:         |                  |\n"
		"|                  |                 | 'jit_tmp'        |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_options      | OT_DICT         | Options to be    | casadi::Function |\n"
		"|                  |                 | passed to the    | Internal         |\n"
		"|                  |                 | jit compiler.    |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_serialize    | OT_STRING       | Specify          | casadi::Function |\n"
		"|                  |                 | behaviour when   | Internal         |\n"
		"|                  |                 | serializing a    |                  |\n"
		"|                  |                 | jitted function: |                  |\n"
		"|                  |                 | SOURCE|link|embe |                  |\n"
		"|                  |                 | d.               |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_temp_suffix  | OT_BOOL         | Use a temporary  | casadi::Function |\n"
		"|                  |                 | (seemingly       | Internal         |\n"
		"|                  |                 | random) filename |                  |\n"
		"|                  |                 | suffix for       |                  |\n"
		"|                  |                 | generated code   |                  |\n"
		"|                  |                 | and libraries.   |                  |\n"
		"|                  |                 | This is desired  |                  |\n"
		"|                  |                 | for thread-      |                  |\n"
		"|                  |                 | safety. This     |                  |\n"
		"|                  |                 | behaviour may    |                  |\n"
		"|                  |                 | defeat caching   |                  |\n"
		"|                  |                 | compiler         |                  |\n"
		"|                  |                 | wrappers.        |                  |\n"
		"|                  |                 | Default: true    |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| max_num_dir      | OT_INT          | Specify the      | casadi::Function |\n"
		"|                  |                 | maximum number   | Internal         |\n"
		"|                  |                 | of directions    |                  |\n"
		"|                  |                 | for derivative   |                  |\n"
		"|                  |                 | functions.       |                  |\n"
		"|                  |                 | Overrules the    |                  |\n"
		"|                  |                 | builtin optimize |                  |\n"
		"|                  |                 | d_num_dir.       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| never_inline     | OT_BOOL         | Forbid inlining. | casadi::Function |\n"
		"|                  |                 |                  | Internal         |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| output_scheme    | OT_STRINGVECTOR | Deprecated       | casadi::Function |\n"
		"|                  |                 | option (ignored) | Internal         |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| print_in         | OT_BOOL         | Print numerical  | casadi::Function |\n"
		"|                  |                 | values of inputs | Internal         |\n"
		"|                  |                 | [default: false] |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| print_out        | OT_BOOL         | Print numerical  | casadi::Function |\n"
		"|                  |                 | values of        | Internal         |\n"
		"|                  |                 | outputs          |                  |\n"
		"|                  |                 | [default: false] |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| print_problem    | OT_BOOL         | Print a numeric  | casadi::Conic    |\n"
		"|                  |                 | description of   |                  |\n"
		"|                  |                 | the problem      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| print_time       | OT_BOOL         | print            | casadi::Function |\n"
		"|                  |                 | information      | Internal         |\n"
		"|                  |                 | about execution  |                  |\n"
		"|                  |                 | time. Implies    |                  |\n"
		"|                  |                 | record_time.     |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| record_time      | OT_BOOL         | record           | casadi::Function |\n"
		"|                  |                 | information      | Internal         |\n"
		"|                  |                 | about execution  |                  |\n"
		"|                  |                 | time, for        |                  |\n"
		"|                  |                 | retrieval with   |                  |\n"
		"|                  |                 | stats().         |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |\n"
		"|                  |                 | when NaN or Inf  | Internal         |\n"
		"|                  |                 | appears during   |                  |\n"
		"|                  |                 | evaluation       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| reverse_options  | OT_DICT         | Options to be    | casadi::Function |\n"
		"|                  |                 | passed to a      | Internal         |\n"
		"|                  |                 | reverse mode     |                  |\n"
		"|                  |                 | constructor      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |\n"
		"|                  |                 | field that can   | Internal         |\n"
		"|                  |                 | be used to       |                  |\n"
		"|                  |                 | identify the     |                  |\n"
		"|                  |                 | function or pass |                  |\n"
		"|                  |                 | additional       |                  |\n"
		"|                  |                 | information      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| verbose          | OT_BOOL         | Verbose          | casadi::Function |\n"
		"|                  |                 | evaluation  for  | Internal         |\n"
		"|                  |                 | debugging        |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"\n"
		">Input scheme: casadi::ConicInput (CONIC_NUM_IN = 12)\n"
		"\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"|  Full name   | Short  |                   Description                    |\n"
		"+==============+========+==================================================+\n"
		"| CONIC_H      | h      | The square matrix H: sparse, (n x n). Only the   |\n"
		"|              |        | lower triangular part is actually used. The      |\n"
		"|              |        | matrix is assumed to be symmetrical.             |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_G      | g      | The vector g: dense, (n x 1)                     |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_A      | a      | The matrix A: sparse, (nc x n) - product with x  |\n"
		"|              |        | must be dense.                                   |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_LBA    | lba    | dense, (nc x 1)                                  |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_UBA    | uba    | dense, (nc x 1)                                  |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_LBX    | lbx    | dense, (n x 1)                                   |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_UBX    | ubx    | dense, (n x 1)                                   |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_X0     | x0     | dense, (n x 1)                                   |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_LAM_X0 | lam_x0 | dense                                            |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_LAM_A0 | lam_a0 | dense                                            |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_Q      | q      | The matrix Q: sparse symmetric, (np^2 x n)       |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"| CONIC_P      | p      | The matrix P: sparse symmetric, (np x np)        |\n"
		"+--------------+--------+--------------------------------------------------+\n"
		"\n"
		">Output scheme: casadi::ConicOutput (CONIC_NUM_OUT = 4)\n"
		"\n"
		"+-------------+-------+---------------------------------------------------+\n"
		"|  Full name  | Short |                    Description                    |\n"
		"+=============+=======+===================================================+\n"
		"| CONIC_X     | x     | The primal solution.                              |\n"
		"+-------------+-------+---------------------------------------------------+\n"
		"| CONIC_COST  | cost  | The optimal cost.                                 |\n"
		"+-------------+-------+---------------------------------------------------+\n"
		"| CONIC_LAM_A | lam_a | The dual solution corresponding to linear bounds. |\n"
		"+-------------+-------+---------------------------------------------------+\n"
		"| CONIC_LAM_X | lam_x | The dual solution corresponding to simple bounds. |\n"
		"+-------------+-------+---------------------------------------------------+\n"
		"\n"
		"List of plugins\n"
		"===============\n"
		"\n"
		"\n"
		"\n"
		"- cbc\n"
		"\n"
		"- clp\n"
		"\n"
		"- cplex\n"
		"\n"
		"- gurobi\n"
		"\n"
		"- hpmpc\n"
		"\n"
		"- ooqp\n"
		"\n"
		"- osqp\n"
		"\n"
		"- qpoases\n"
		"\n"
		"- sqic\n"
		"\n"
		"- superscs\n"
		"\n"
		"- nlpsol\n"
		"\n"
		"- qrqp\n"
		"\n"
		"Note: some of the plugins in this list might not be available on your\n"
		"system. Also, there might be extra plugins available to you that are not\n"
		"listed here. You can obtain their documentation with\n"
		"Conic.doc(\"myextraplugin\")\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"cbc\n"
		"---\n"
		"\n"
		"\n"
		"\n"
		"Interface to Cbc solver for sparse Quadratic Programs\n"
		"\n"
		">List of available options\n"
		"\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"|     Id      |         Type          |            Description             |\n"
		"+=============+=======================+====================================+\n"
		"| cbc         | OT_DICT               | Options to be passed to CBC.Three  |\n"
		"|             |                       | sets of options are supported. The |\n"
		"|             |                       | first can be found in              |\n"
		"|             |                       | OsiSolverParameters.hpp. The       |\n"
		"|             |                       | second can be found in             |\n"
		"|             |                       | CbcModel.hpp. The third are        |\n"
		"|             |                       | options that can be passed to      |\n"
		"|             |                       | CbcMain1.                          |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"| hot_start   | OT_BOOL               | Hot start with x0 [Default false]. |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"| sos_groups  | OT_INTVECTORVECTOR    | Definition of SOS groups by        |\n"
		"|             |                       | indices.                           |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"| sos_types   | OT_INTVECTOR          | Specify 1 or 2 for each SOS group. |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"| sos_weights | OT_DOUBLEVECTORVECTOR | Weights corresponding to SOS       |\n"
		"|             |                       | entries.                           |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"clp\n"
		"---\n"
		"\n"
		"\n"
		"\n"
		"Interface to Clp solver for sparse Quadratic Programs\n"
		"\n"
		">List of available options\n"
		"\n"
		"+-----+---------+----------------------------------------------------------+\n"
		"| Id  |  Type   |                       Description                        |\n"
		"+=====+=========+==========================================================+\n"
		"| clp | OT_DICT | Options to be passed to CLP. A first set of options can  |\n"
		"|     |         | be found in ClpParameters.hpp. eg. 'PrimalTolerance'.    |\n"
		"|     |         | There are other options in additions. 'AutomaticScaling' |\n"
		"|     |         | (bool) is recognised. 'initial_solve' (default off)      |\n"
		"|     |         | activates the use of Clp's initialSolve.                 |\n"
		"|     |         | 'initial_solve_options' takes a dictionary with          |\n"
		"|     |         | following keys (see ClpSolve.hpp): SolveType (string),   |\n"
		"|     |         | PresolveType (string), NumberPasses, SpecialOptions      |\n"
		"|     |         | (intvectorvector), IndependentOptions (intvectorvector). |\n"
		"+-----+---------+----------------------------------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"cplex\n"
		"-----\n"
		"\n"
		"\n"
		"\n"
		"Interface to Cplex solver for sparse Quadratic Programs\n"
		"\n"
		">List of available options\n"
		"\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"|      Id       |         Type          |           Description            |\n"
		"+===============+=======================+==================================+\n"
		"| cplex         | OT_DICT               | Options to be passed to CPLEX    |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| dep_check     | OT_INT                | Detect redundant constraints.    |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| dump_filename | OT_STRING             | The filename to dump to.         |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| dump_to_file  | OT_BOOL               | Dumps QP to file in CPLEX        |\n"
		"|               |                       | format.                          |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| mip_start     | OT_BOOL               | Hot start integers with x0       |\n"
		"|               |                       | [Default false].                 |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| qp_method     | OT_INT                | Determines which CPLEX algorithm |\n"
		"|               |                       | to use.                          |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| sos_groups    | OT_INTVECTORVECTOR    | Definition of SOS groups by      |\n"
		"|               |                       | indices.                         |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| sos_types     | OT_INTVECTOR          | Specify 1 or 2 for each SOS      |\n"
		"|               |                       | group.                           |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| sos_weights   | OT_DOUBLEVECTORVECTOR | Weights corresponding to SOS     |\n"
		"|               |                       | entries.                         |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| tol           | OT_DOUBLE             | Tolerance of solver              |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"| warm_start    | OT_BOOL               | Use warm start with simplex      |\n"
		"|               |                       | methods (affects only the        |\n"
		"|               |                       | simplex methods).                |\n"
		"+---------------+-----------------------+----------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"gurobi\n"
		"------\n"
		"\n"
		"\n"
		"\n"
		"Interface to the GUROBI Solver for quadratic programming\n"
		"\n"
		">List of available options\n"
		"\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"|     Id      |         Type          |            Description             |\n"
		"+=============+=======================+====================================+\n"
		"| gurobi      | OT_DICT               | Options to be passed to gurobi.    |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"| sos_groups  | OT_INTVECTORVECTOR    | Definition of SOS groups by        |\n"
		"|             |                       | indices.                           |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"| sos_types   | OT_INTVECTOR          | Specify 1 or 2 for each SOS group. |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"| sos_weights | OT_DOUBLEVECTORVECTOR | Weights corresponding to SOS       |\n"
		"|             |                       | entries.                           |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"| vtype       | OT_STRINGVECTOR       | Type of variables: [CONTINUOUS|bin |\n"
		"|             |                       | ary|integer|semicont|semiint]      |\n"
		"+-------------+-----------------------+------------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"hpmpc\n"
		"-----\n"
		"\n"
		"\n"
		"\n"
		"Interface to HMPC Solver\n"
		"\n"
		"In order to use this interface, you must:\n"
		"\n"
		"Decision variables must only by state and control, and the variable ordering\n"
		"must be [x0 u0 x1 u1 ...]\n"
		"\n"
		"The constraints must be in order: [ gap0 lincon0 gap1 lincon1 ]\n"
		"\n"
		"gap: Ak+1 = Ak xk + Bk uk lincon: yk= Ck xk + Dk uk\n"
		"\n"
		"\n"
		"\n"
		"::\n"
		"\n"
		"         A0 B0 -I\n"
		"         C0 D0\n"
		"                A1 B1 -I\n"
		"                C1 D1\n"
		"\n"
		"\n"
		"\n"
		"where I must be a diagonal sparse matrix Either supply all of N, nx, ng, nu\n"
		"options or rely on automatic detection\n"
		"\n"
		">List of available options\n"
		"\n"
		"+----------------+--------------+------------------------------------------+\n"
		"|       Id       |     Type     |               Description                |\n"
		"+================+==============+==========================================+\n"
		"| N              | OT_INT       | OCP horizon                              |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| blasfeo_target | OT_STRING    | hpmpc target                             |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| inf            | OT_DOUBLE    | HPMPC cannot handle infinities.          |\n"
		"|                |              | Infinities will be replaced by this      |\n"
		"|                |              | option's value.                          |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| max_iter       | OT_INT       | Max number of iterations                 |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| mu0            | OT_DOUBLE    | Max element in cost function as estimate |\n"
		"|                |              | of max multiplier                        |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| ng             | OT_INTVECTOR | Number of non-dynamic constraints,       |\n"
		"|                |              | length N+1                               |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| nu             | OT_INTVECTOR | Number of controls, length N             |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| nx             | OT_INTVECTOR | Number of states, length N+1             |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| print_level    | OT_INT       | Amount of diagnostic printing [Default:  |\n"
		"|                |              | 1].                                      |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| target         | OT_STRING    | hpmpc target                             |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| tol            | OT_DOUBLE    | Tolerance in the duality measure         |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"| warm_start     | OT_BOOL      | Use warm-starting                        |\n"
		"+----------------+--------------+------------------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"ooqp\n"
		"----\n"
		"\n"
		"\n"
		"\n"
		"Interface to the OOQP Solver for quadratic programming The current\n"
		"implementation assumes that OOQP is configured with the MA27 sparse linear\n"
		"solver.\n"
		"\n"
		"NOTE: when doing multiple calls to evaluate(), check if you need to\n"
		"reInit();\n"
		"\n"
		">List of available options\n"
		"\n"
		"+-------------+-----------+------------------------------------------------+\n"
		"|     Id      |   Type    |                  Description                   |\n"
		"+=============+===========+================================================+\n"
		"| artol       | OT_DOUBLE | tolerance as provided with setArTol to OOQP    |\n"
		"+-------------+-----------+------------------------------------------------+\n"
		"| mutol       | OT_DOUBLE | tolerance as provided with setMuTol to OOQP    |\n"
		"+-------------+-----------+------------------------------------------------+\n"
		"| print_level | OT_INT    | Print level. OOQP listens to print_level 0, 10 |\n"
		"|             |           | and 100                                        |\n"
		"+-------------+-----------+------------------------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"osqp\n"
		"----\n"
		"\n"
		"\n"
		"\n"
		"Interface to the OSQP Solver for quadratic programming\n"
		"\n"
		">List of available options\n"
		"\n"
		"+-------------------+---------+--------------------------------------------+\n"
		"|        Id         |  Type   |                Description                 |\n"
		"+===================+=========+============================================+\n"
		"| osqp              | OT_DICT | const Options to be passed to osqp.        |\n"
		"+-------------------+---------+--------------------------------------------+\n"
		"| warm_start_dual   | OT_BOOL | Use lam_a0 and lam_x0 input to warmstart   |\n"
		"|                   |         | [Default: truw].                           |\n"
		"+-------------------+---------+--------------------------------------------+\n"
		"| warm_start_primal | OT_BOOL | Use x0 input to warmstart [Default: true]. |\n"
		"+-------------------+---------+--------------------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"qpoases\n"
		"-------\n"
		"\n"
		"\n"
		"\n"
		"Interface to QPOases Solver for quadratic programming\n"
		"\n"
		">List of available options\n"
		"\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"|              Id               |   Type    |         Description          |\n"
		"+===============================+===========+==============================+\n"
		"| CPUtime                       | OT_DOUBLE | The maximum allowed CPU time |\n"
		"|                               |           | in seconds for the whole     |\n"
		"|                               |           | initialisation (and the      |\n"
		"|                               |           | actually required one on     |\n"
		"|                               |           | output). Disabled if unset.  |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| boundRelaxation               | OT_DOUBLE | Initial relaxation of bounds |\n"
		"|                               |           | to start homotopy and        |\n"
		"|                               |           | initial value for far        |\n"
		"|                               |           | bounds.                      |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| boundTolerance                | OT_DOUBLE | If upper and lower bounds    |\n"
		"|                               |           | differ less than this        |\n"
		"|                               |           | tolerance, they are regarded |\n"
		"|                               |           | equal, i.e. as equality      |\n"
		"|                               |           | constraint.                  |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableCholeskyRefactorisation | OT_INT    | Specifies the frequency of a |\n"
		"|                               |           | full re-factorisation of     |\n"
		"|                               |           | projected Hessian matrix: 0: |\n"
		"|                               |           | turns them off, 1: uses them |\n"
		"|                               |           | at each iteration etc.       |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableDriftCorrection         | OT_INT    | Specifies the frequency of   |\n"
		"|                               |           | drift corrections: 0: turns  |\n"
		"|                               |           | them off.                    |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableEqualities              | OT_BOOL   | Specifies whether equalities |\n"
		"|                               |           | should be treated as always  |\n"
		"|                               |           | active (True) or not (False) |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableFarBounds               | OT_BOOL   | Enables the use of far       |\n"
		"|                               |           | bounds.                      |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableFlippingBounds          | OT_BOOL   | Enables the use of flipping  |\n"
		"|                               |           | bounds.                      |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableFullLITests             | OT_BOOL   | Enables condition-hardened   |\n"
		"|                               |           | (but more expensive) LI      |\n"
		"|                               |           | test.                        |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableInertiaCorrection       | OT_BOOL   | Should working set be        |\n"
		"|                               |           | repaired when negative       |\n"
		"|                               |           | curvature is discovered      |\n"
		"|                               |           | during hotstart.             |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableNZCTests                | OT_BOOL   | Enables nonzero curvature    |\n"
		"|                               |           | tests.                       |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableRamping                 | OT_BOOL   | Enables ramping.             |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| enableRegularisation          | OT_BOOL   | Enables automatic Hessian    |\n"
		"|                               |           | regularisation.              |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| epsDen                        | OT_DOUBLE | Denominator tolerance for    |\n"
		"|                               |           | ratio tests.                 |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| epsFlipping                   | OT_DOUBLE | Tolerance of squared         |\n"
		"|                               |           | Cholesky diagonal factor     |\n"
		"|                               |           | which triggers flipping      |\n"
		"|                               |           | bound.                       |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| epsIterRef                    | OT_DOUBLE | Early termination tolerance  |\n"
		"|                               |           | for iterative refinement.    |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| epsLITests                    | OT_DOUBLE | Tolerance for linear         |\n"
		"|                               |           | independence tests.          |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| epsNZCTests                   | OT_DOUBLE | Tolerance for nonzero        |\n"
		"|                               |           | curvature tests.             |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| epsNum                        | OT_DOUBLE | Numerator tolerance for      |\n"
		"|                               |           | ratio tests.                 |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| epsRegularisation             | OT_DOUBLE | Scaling factor of identity   |\n"
		"|                               |           | matrix used for Hessian      |\n"
		"|                               |           | regularisation.              |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| finalRamping                  | OT_DOUBLE | Final value for ramping      |\n"
		"|                               |           | strategy.                    |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| growFarBounds                 | OT_DOUBLE | Factor to grow far bounds.   |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| hessian_type                  | OT_STRING | Type of Hessian - see        |\n"
		"|                               |           | qpOASES documentation [UNKNO |\n"
		"|                               |           | WN|posdef|semidef|indef|zero |\n"
		"|                               |           | |identity]]                  |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| initialFarBounds              | OT_DOUBLE | Initial size for far bounds. |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| initialRamping                | OT_DOUBLE | Start value for ramping      |\n"
		"|                               |           | strategy.                    |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| initialStatusBounds           | OT_STRING | Initial status of bounds at  |\n"
		"|                               |           | first iteration.             |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| linsol_plugin                 | OT_STRING | Linear solver plugin         |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| maxDualJump                   | OT_DOUBLE | Maximum allowed jump in dual |\n"
		"|                               |           | variables in linear          |\n"
		"|                               |           | independence tests.          |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| maxPrimalJump                 | OT_DOUBLE | Maximum allowed jump in      |\n"
		"|                               |           | primal variables in nonzero  |\n"
		"|                               |           | curvature tests.             |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| max_schur                     | OT_INT    | Maximal number of Schur      |\n"
		"|                               |           | updates [75]                 |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| nWSR                          | OT_INT    | The maximum number of        |\n"
		"|                               |           | working set recalculations   |\n"
		"|                               |           | to be performed during the   |\n"
		"|                               |           | initial homotopy. Default is |\n"
		"|                               |           | 5(nx + nc)                   |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| numRefinementSteps            | OT_INT    | Maximum number of iterative  |\n"
		"|                               |           | refinement steps.            |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| numRegularisationSteps        | OT_INT    | Maximum number of successive |\n"
		"|                               |           | regularisation steps.        |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| printLevel                    | OT_STRING | Defines the amount of text   |\n"
		"|                               |           | output during QP solution,   |\n"
		"|                               |           | see Section 5.7              |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| schur                         | OT_BOOL   | Use Schur Complement         |\n"
		"|                               |           | Approach [false]             |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| sparse                        | OT_BOOL   | Formulate the QP using       |\n"
		"|                               |           | sparse matrices. [false]     |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"| terminationTolerance          | OT_DOUBLE | Relative termination         |\n"
		"|                               |           | tolerance to stop homotopy.  |\n"
		"+-------------------------------+-----------+------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"sqic\n"
		"----\n"
		"\n"
		"\n"
		"\n"
		"Interface to the SQIC solver for quadratic programming\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"superscs\n"
		"--------\n"
		"\n"
		"\n"
		"\n"
		"Interface to the SuperSCS solver for conic programming\n"
		"\n"
		"Joris Gillis, 2019\n"
		"\n"
		">List of available options\n"
		"\n"
		"+----------+---------+-----------------------------------+\n"
		"|    Id    |  Type   |            Description            |\n"
		"+==========+=========+===================================+\n"
		"| superscs | OT_DICT | Options to be passed to superscs. |\n"
		"+----------+---------+-----------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"nlpsol\n"
		"------\n"
		"\n"
		"\n"
		"\n"
		"Solve QPs using an Nlpsol Use the 'nlpsol' option to specify the NLP solver\n"
		"to use.\n"
		"\n"
		">List of available options\n"
		"\n"
		"+----------------+-----------+---------------------------------+\n"
		"|       Id       |   Type    |           Description           |\n"
		"+================+===========+=================================+\n"
		"| nlpsol         | OT_STRING | Name of solver.                 |\n"
		"+----------------+-----------+---------------------------------+\n"
		"| nlpsol_options | OT_DICT   | Options to be passed to solver. |\n"
		"+----------------+-----------+---------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"qrqp\n"
		"----\n"
		"\n"
		"\n"
		"\n"
		"Solve QPs using an active-set method\n"
		"\n"
		">List of available options\n"
		"\n"
		"+-----------------+-----------+--------------------------------------------+\n"
		"|       Id        |   Type    |                Description                 |\n"
		"+=================+===========+============================================+\n"
		"| constr_viol_tol | OT_DOUBLE | Constraint violation tolerance [1e-8].     |\n"
		"+-----------------+-----------+--------------------------------------------+\n"
		"| dual_inf_tol    | OT_DOUBLE | Dual feasibility violation tolerance       |\n"
		"|                 |           | [1e-8]                                     |\n"
		"+-----------------+-----------+--------------------------------------------+\n"
		"| max_iter        | OT_INT    | Maximum number of iterations [1000].       |\n"
		"+-----------------+-----------+--------------------------------------------+\n"
		"| min_lam         | OT_DOUBLE | Smallest multiplier treated as inactive    |\n"
		"|                 |           | for the initial active set [0].            |\n"
		"+-----------------+-----------+--------------------------------------------+\n"
		"| print_header    | OT_BOOL   | Print header [true].                       |\n"
		"+-----------------+-----------+--------------------------------------------+\n"
		"| print_info      | OT_BOOL   | Print info [true].                         |\n"
		"+-----------------+-----------+--------------------------------------------+\n"
		"| print_iter      | OT_BOOL   | Print iterations [true].                   |\n"
		"+-----------------+-----------+--------------------------------------------+\n"
		"| print_lincomb   | OT_BOOL   | Print dependant linear combinations of     |\n"
		"|                 |           | constraints [false]. Printed numbers are   |\n"
		"|                 |           | 0-based indices into the vector of [simple |\n"
		"|                 |           | bounds;linear bounds]                      |\n"
		"+-----------------+-----------+--------------------------------------------+\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"Joel Andersson\n"
		"\n"
		"\n"
		""},
	 { "qpsol", _wrap_qpsol, METH_VARARGS, "\n"
		"qpsol(std::string const & name, std::string const & solver, casadi::SXDict const & qp, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"qpsol(std::string const & name, std::string const & solver, casadi::MXDict const & qp, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		""},
	 { "conic_in", _wrap_conic_in, METH_VARARGS, "\n"
		"conic_in() -> std::vector< std::string,std::allocator< std::string > >\n"
		"conic_in(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get input scheme of QP solvers.\n"
		"\n"
		"\n"
		""},
	 { "conic_out", _wrap_conic_out, METH_VARARGS, "\n"
		"conic_out() -> std::vector< std::string,std::allocator< std::string > >\n"
		"conic_out(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get QP solver output scheme of QP solvers.\n"
		"\n"
		"\n"
		""},
	 { "conic_n_in", _wrap_conic_n_in, METH_NOARGS, "\n"
		"conic_n_in() -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of QP solver inputs.\n"
		"\n"
		"\n"
		""},
	 { "conic_n_out", _wrap_conic_n_out, METH_NOARGS, "\n"
		"conic_n_out() -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of QP solver outputs.\n"
		"\n"
		"\n"
		""},
	 { "conic_options", _wrap_conic_options, METH_O, "\n"
		"conic_options(std::string const & name) -> std::vector< std::string,std::allocator< std::string > >\n"
		"\n"
		"\n"
		"Get all options for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "conic_option_type", _wrap_conic_option_type, METH_VARARGS, "\n"
		"conic_option_type(std::string const & name, std::string const & op) -> std::string\n"
		"\n"
		"\n"
		"Get type info for a particular option.\n"
		"\n"
		"\n"
		""},
	 { "conic_option_info", _wrap_conic_option_info, METH_VARARGS, "\n"
		"conic_option_info(std::string const & name, std::string const & op) -> std::string\n"
		"\n"
		"\n"
		"Get documentation for a particular option.\n"
		"\n"
		"\n"
		""},
	 { "has_conic", _wrap_has_conic, METH_O, "\n"
		"has_conic(std::string const & name) -> bool\n"
		"\n"
		"\n"
		"Check if a particular plugin is available.\n"
		"\n"
		"\n"
		""},
	 { "load_conic", _wrap_load_conic, METH_O, "\n"
		"load_conic(std::string const & name)\n"
		"\n"
		"\n"
		"Explicitly load a plugin dynamically.\n"
		"\n"
		"\n"
		""},
	 { "doc_conic", _wrap_doc_conic, METH_O, "\n"
		"doc_conic(std::string const & name) -> std::string\n"
		"\n"
		"\n"
		"Get the documentation string for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "conic_debug", _wrap_conic_debug, METH_VARARGS, "\n"
		"conic_debug(Function f, std::string const & filename)\n"
		"conic_debug(Function f, std::ostream & file)\n"
		"\n"
		"\n"
		"Generate native code in the interfaced language for debugging\n"
		"\n"
		"\n"
		""},
	 { "nlpsol", _wrap_nlpsol, METH_VARARGS, "\n"
		"nlpsol(std::string const & name, std::string const & solver, casadi::SXDict const & nlp, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"nlpsol(std::string const & name, std::string const & solver, casadi::MXDict const & nlp, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"nlpsol(std::string const & name, std::string const & solver, std::string const & fname, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"nlpsol(std::string const & name, std::string const & solver, Importer compiler, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"nlpsol(std::string const & name, std::string const & solver, NlpBuilder nl, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		""},
	 { "nlpsol_in", _wrap_nlpsol_in, METH_VARARGS, "\n"
		"nlpsol_in() -> std::vector< std::string,std::allocator< std::string > >\n"
		"nlpsol_in(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get input scheme of NLP solvers.\n"
		"\n"
		">Input scheme: casadi::NlpsolInput (NLPSOL_NUM_IN = 8)\n"
		"\n"
		"+---------------+--------+-------------------------------------------------+\n"
		"|   Full name   | Short  |                   Description                   |\n"
		"+===============+========+=================================================+\n"
		"| NLPSOL_X0     | x0     | Decision variables, initial guess (nx x 1)      |\n"
		"+---------------+--------+-------------------------------------------------+\n"
		"| NLPSOL_P      | p      | Value of fixed parameters (np x 1)              |\n"
		"+---------------+--------+-------------------------------------------------+\n"
		"| NLPSOL_LBX    | lbx    | Decision variables lower bound (nx x 1),        |\n"
		"|               |        | default -inf.                                   |\n"
		"+---------------+--------+-------------------------------------------------+\n"
		"| NLPSOL_UBX    | ubx    | Decision variables upper bound (nx x 1),        |\n"
		"|               |        | default +inf.                                   |\n"
		"+---------------+--------+-------------------------------------------------+\n"
		"| NLPSOL_LBG    | lbg    | Constraints lower bound (ng x 1), default -inf. |\n"
		"+---------------+--------+-------------------------------------------------+\n"
		"| NLPSOL_UBG    | ubg    | Constraints upper bound (ng x 1), default +inf. |\n"
		"+---------------+--------+-------------------------------------------------+\n"
		"| NLPSOL_LAM_X0 | lam_x0 | Lagrange multipliers for bounds on X, initial   |\n"
		"|               |        | guess (nx x 1)                                  |\n"
		"+---------------+--------+-------------------------------------------------+\n"
		"| NLPSOL_LAM_G0 | lam_g0 | Lagrange multipliers for bounds on G, initial   |\n"
		"|               |        | guess (ng x 1)                                  |\n"
		"+---------------+--------+-------------------------------------------------+\n"
		"\n"
		"\n"
		""},
	 { "nlpsol_out", _wrap_nlpsol_out, METH_VARARGS, "\n"
		"nlpsol_out() -> std::vector< std::string,std::allocator< std::string > >\n"
		"nlpsol_out(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get NLP solver output scheme of NLP solvers.\n"
		"\n"
		">Output scheme: casadi::NlpsolOutput (NLPSOL_NUM_OUT = 6)\n"
		"\n"
		"+--------------+-------+---------------------------------------------------+\n"
		"|  Full name   | Short |                    Description                    |\n"
		"+==============+=======+===================================================+\n"
		"| NLPSOL_X     | x     | Decision variables at the optimal solution (nx x  |\n"
		"|              |       | 1)                                                |\n"
		"+--------------+-------+---------------------------------------------------+\n"
		"| NLPSOL_F     | f     | Cost function value at the optimal solution (1 x  |\n"
		"|              |       | 1)                                                |\n"
		"+--------------+-------+---------------------------------------------------+\n"
		"| NLPSOL_G     | g     | Constraints function at the optimal solution (ng  |\n"
		"|              |       | x 1)                                              |\n"
		"+--------------+-------+---------------------------------------------------+\n"
		"| NLPSOL_LAM_X | lam_x | Lagrange multipliers for bounds on X at the       |\n"
		"|              |       | solution (nx x 1)                                 |\n"
		"+--------------+-------+---------------------------------------------------+\n"
		"| NLPSOL_LAM_G | lam_g | Lagrange multipliers for bounds on G at the       |\n"
		"|              |       | solution (ng x 1)                                 |\n"
		"+--------------+-------+---------------------------------------------------+\n"
		"| NLPSOL_LAM_P | lam_p | Lagrange multipliers for bounds on P at the       |\n"
		"|              |       | solution (np x 1)                                 |\n"
		"+--------------+-------+---------------------------------------------------+\n"
		"\n"
		"\n"
		""},
	 { "nlpsol_n_in", _wrap_nlpsol_n_in, METH_NOARGS, "\n"
		"nlpsol_n_in() -> casadi_int\n"
		"\n"
		"\n"
		"Number of NLP solver inputs.\n"
		"\n"
		"\n"
		""},
	 { "nlpsol_n_out", _wrap_nlpsol_n_out, METH_NOARGS, "\n"
		"nlpsol_n_out() -> casadi_int\n"
		"\n"
		"\n"
		"Number of NLP solver outputs.\n"
		"\n"
		"\n"
		""},
	 { "nlpsol_default_in", _wrap_nlpsol_default_in, METH_VARARGS, "\n"
		"nlpsol_default_in(casadi_int ind) -> double\n"
		"nlpsol_default_in() -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Default input for an NLP solver.\n"
		"\n"
		"\n"
		""},
	 { "nlpsol_options", _wrap_nlpsol_options, METH_O, "\n"
		"nlpsol_options(std::string const & name) -> std::vector< std::string,std::allocator< std::string > >\n"
		"\n"
		"\n"
		"Get all options for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "nlpsol_option_type", _wrap_nlpsol_option_type, METH_VARARGS, "\n"
		"nlpsol_option_type(std::string const & name, std::string const & op) -> std::string\n"
		"\n"
		"\n"
		"Get type info for a particular option.\n"
		"\n"
		"\n"
		""},
	 { "nlpsol_option_info", _wrap_nlpsol_option_info, METH_VARARGS, "\n"
		"nlpsol_option_info(std::string const & name, std::string const & op) -> std::string\n"
		"\n"
		"\n"
		"Get documentation for a particular option.\n"
		"\n"
		"\n"
		""},
	 { "has_nlpsol", _wrap_has_nlpsol, METH_O, "\n"
		"has_nlpsol(std::string const & name) -> bool\n"
		"\n"
		"\n"
		"Check if a particular plugin is available.\n"
		"\n"
		"\n"
		""},
	 { "load_nlpsol", _wrap_load_nlpsol, METH_O, "\n"
		"load_nlpsol(std::string const & name)\n"
		"\n"
		"\n"
		"Explicitly load a plugin dynamically.\n"
		"\n"
		"\n"
		""},
	 { "doc_nlpsol", _wrap_doc_nlpsol, METH_O, "\n"
		"doc_nlpsol(std::string const & name) -> std::string\n"
		"\n"
		"\n"
		"Get the documentation string for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "rootfinder", _wrap_rootfinder, METH_VARARGS, "\n"
		"rootfinder(std::string const & name, std::string const & solver, casadi::SXDict const & rfp, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"rootfinder(std::string const & name, std::string const & solver, casadi::MXDict const & rfp, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"rootfinder(std::string const & name, std::string const & solver, Function f, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		""},
	 { "rootfinder_in", _wrap_rootfinder_in, METH_VARARGS, "\n"
		"rootfinder_in() -> std::vector< std::string,std::allocator< std::string > >\n"
		"rootfinder_in(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get rootfinder input scheme.\n"
		"\n"
		"\n"
		""},
	 { "rootfinder_out", _wrap_rootfinder_out, METH_VARARGS, "\n"
		"rootfinder_out() -> std::vector< std::string,std::allocator< std::string > >\n"
		"rootfinder_out(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get rootfinder output scheme.\n"
		"\n"
		"\n"
		""},
	 { "rootfinder_n_in", _wrap_rootfinder_n_in, METH_NOARGS, "\n"
		"rootfinder_n_in() -> casadi_int\n"
		"\n"
		"\n"
		"Number of rootfinder inputs.\n"
		"\n"
		"\n"
		""},
	 { "rootfinder_n_out", _wrap_rootfinder_n_out, METH_NOARGS, "\n"
		"rootfinder_n_out() -> casadi_int\n"
		"\n"
		"\n"
		"Number of rootfinder outputs.\n"
		"\n"
		"\n"
		""},
	 { "rootfinder_options", _wrap_rootfinder_options, METH_O, "\n"
		"rootfinder_options(std::string const & name) -> std::vector< std::string,std::allocator< std::string > >\n"
		"\n"
		"\n"
		"Get all options for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "rootfinder_option_type", _wrap_rootfinder_option_type, METH_VARARGS, "\n"
		"rootfinder_option_type(std::string const & name, std::string const & op) -> std::string\n"
		"\n"
		"\n"
		"Get type info for a particular option.\n"
		"\n"
		"\n"
		""},
	 { "rootfinder_option_info", _wrap_rootfinder_option_info, METH_VARARGS, "\n"
		"rootfinder_option_info(std::string const & name, std::string const & op) -> std::string\n"
		"\n"
		"\n"
		"Get documentation for a particular option.\n"
		"\n"
		"\n"
		""},
	 { "has_rootfinder", _wrap_has_rootfinder, METH_O, "\n"
		"has_rootfinder(std::string const & name) -> bool\n"
		"\n"
		"\n"
		"Check if a particular plugin is available.\n"
		"\n"
		"\n"
		""},
	 { "load_rootfinder", _wrap_load_rootfinder, METH_O, "\n"
		"load_rootfinder(std::string const & name)\n"
		"\n"
		"\n"
		"Explicitly load a plugin dynamically.\n"
		"\n"
		"\n"
		""},
	 { "doc_rootfinder", _wrap_doc_rootfinder, METH_O, "\n"
		"doc_rootfinder(std::string const & name) -> std::string\n"
		"\n"
		"\n"
		"Get the documentation string for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "Linsol_type_name", _wrap_Linsol_type_name, METH_NOARGS, "Linsol_type_name() -> std::string"},
	 { "Linsol_has_plugin", _wrap_Linsol_has_plugin, METH_O, "Linsol_has_plugin(std::string const & name) -> bool"},
	 { "Linsol_load_plugin", _wrap_Linsol_load_plugin, METH_O, "Linsol_load_plugin(std::string const & name)"},
	 { "Linsol_doc", _wrap_Linsol_doc, METH_O, "Linsol_doc(std::string const & name) -> std::string"},
	 { "Linsol_plugin_name", _wrap_Linsol_plugin_name, METH_O, "\n"
		"Linsol_plugin_name(Linsol self) -> std::string\n"
		"\n"
		"\n"
		"Query plugin name.\n"
		"\n"
		"\n"
		""},
	 { "Linsol_sparsity", _wrap_Linsol_sparsity, METH_O, "\n"
		"Linsol_sparsity(Linsol self) -> Sparsity\n"
		"\n"
		"\n"
		"Get linear system sparsity.\n"
		"\n"
		"\n"
		""},
	 { "Linsol_sfact", _wrap_Linsol_sfact, METH_VARARGS, "\n"
		"Linsol_sfact(Linsol self, DM A)\n"
		"\n"
		"\n"
		"Symbolic factorization of the linear system, e.g. selecting pivots.\n"
		"\n"
		"\n"
		""},
	 { "Linsol_nfact", _wrap_Linsol_nfact, METH_VARARGS, "\n"
		"Linsol_nfact(Linsol self, DM A)\n"
		"\n"
		"\n"
		"Numeric factorization of the linear system.\n"
		"\n"
		"\n"
		""},
	 { "Linsol_solve", _wrap_Linsol_solve, METH_VARARGS, "\n"
		"Linsol_solve(Linsol self, DM A, DM B, bool tr=False) -> DM\n"
		"Linsol_solve(Linsol self, MX A, MX B, bool tr=False) -> MX\n"
		"\n"
		"\n"
		"Solve linear system of equations\n"
		"\n"
		"\n"
		""},
	 { "Linsol_neig", _wrap_Linsol_neig, METH_VARARGS, "\n"
		"Linsol_neig(Linsol self, DM A) -> casadi_int\n"
		"\n"
		"\n"
		"Number of negative eigenvalues Not available for all solvers.\n"
		"\n"
		"\n"
		""},
	 { "Linsol_rank", _wrap_Linsol_rank, METH_VARARGS, "\n"
		"Linsol_rank(Linsol self, DM A) -> casadi_int\n"
		"\n"
		"\n"
		"Matrix rank Not available for all solvers.\n"
		"\n"
		"\n"
		""},
	 { "Linsol_stats", _wrap_Linsol_stats, METH_VARARGS, "\n"
		"Linsol_stats(Linsol self, int mem=1) -> casadi::Dict\n"
		"\n"
		"\n"
		"Get all statistics obtained at the end of the last evaluate call.\n"
		"\n"
		"\n"
		""},
	 { "new_Linsol", _wrap_new_Linsol, METH_VARARGS, "\n"
		"Linsol()\n"
		"Linsol(std::string const & name, std::string const & solver, Sparsity sp, casadi::Dict const & opts=casadi::Dict())\n"
		"new_Linsol(Linsol other) -> Linsol\n"
		"\n"
		"\n"
		"Constructor.\n"
		"\n"
		"\n"
		""},
	 { "delete_Linsol", _wrap_delete_Linsol, METH_O, "delete_Linsol(Linsol self)"},
	 { "Linsol_swigregister", Linsol_swigregister, METH_O, NULL},
	 { "Linsol_swiginit", Linsol_swiginit, METH_VARARGS, NULL},
	 { "has_linsol", _wrap_has_linsol, METH_O, "\n"
		"has_linsol(std::string const & name) -> bool\n"
		"\n"
		"\n"
		"Check if a particular plugin is available.\n"
		"\n"
		"\n"
		""},
	 { "load_linsol", _wrap_load_linsol, METH_O, "\n"
		"load_linsol(std::string const & name)\n"
		"\n"
		"\n"
		"Explicitly load a plugin dynamically.\n"
		"\n"
		"\n"
		""},
	 { "doc_linsol", _wrap_doc_linsol, METH_O, "\n"
		"doc_linsol(std::string const & name) -> std::string\n"
		"\n"
		"\n"
		"Get the documentation string for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "dplesol", _wrap_dplesol, METH_VARARGS, "\n"
		"dplesol(std::string const & name, std::string const & solver, casadi::SpDict const & st, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"dplesol(MX A, MX V, std::string const & solver, casadi::Dict const & opts=casadi::Dict()) -> MX\n"
		"dplesol(casadi::MXVector const & A, casadi::MXVector const & V, std::string const & solver, casadi::Dict const & opts=casadi::Dict()) -> casadi::MXVector\n"
		"dplesol(casadi::DMVector const & A, casadi::DMVector const & V, std::string const & solver, casadi::Dict const & opts=casadi::Dict()) -> casadi::DMVector\n"
		""},
	 { "dple_in", _wrap_dple_in, METH_VARARGS, "\n"
		"dple_in() -> std::vector< std::string,std::allocator< std::string > >\n"
		"dple_in(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get input scheme of DPLE solvers.\n"
		"\n"
		"\n"
		""},
	 { "dple_out", _wrap_dple_out, METH_VARARGS, "\n"
		"dple_out() -> std::vector< std::string,std::allocator< std::string > >\n"
		"dple_out(casadi_int ind) -> std::string\n"
		"\n"
		"\n"
		"Get output scheme of DPLE solvers.\n"
		"\n"
		"\n"
		""},
	 { "dple_n_in", _wrap_dple_n_in, METH_NOARGS, "\n"
		"dple_n_in() -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of QP solver inputs.\n"
		"\n"
		"\n"
		""},
	 { "dple_n_out", _wrap_dple_n_out, METH_NOARGS, "\n"
		"dple_n_out() -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of QP solver outputs.\n"
		"\n"
		"\n"
		""},
	 { "has_dple", _wrap_has_dple, METH_O, "\n"
		"has_dple(std::string const & name) -> bool\n"
		"\n"
		"\n"
		"Check if a particular plugin is available.\n"
		"\n"
		"\n"
		""},
	 { "load_dple", _wrap_load_dple, METH_O, "\n"
		"load_dple(std::string const & name)\n"
		"\n"
		"\n"
		"Explicitly load a plugin dynamically.\n"
		"\n"
		"\n"
		""},
	 { "doc_dple", _wrap_doc_dple, METH_O, "\n"
		"doc_dple(std::string const & name) -> std::string\n"
		"\n"
		"\n"
		"Get the documentation string for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "expmsol", _wrap_expmsol, METH_VARARGS, "\n"
		"expmsol(std::string const & name, std::string const & solver, Sparsity A, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Performs a matrix exponentiation expm(A)\n"
		"\n"
		"General information\n"
		"===================\n"
		"\n"
		"\n"
		"\n"
		">List of available options\n"
		"\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"|        Id        |      Type       |   Description    |     Used in      |\n"
		"+==================+=================+==================+==================+\n"
		"| ad_weight        | OT_DOUBLE       | Weighting factor | casadi::Function |\n"
		"|                  |                 | for derivative   | Internal         |\n"
		"|                  |                 | calculation.When |                  |\n"
		"|                  |                 | there is an      |                  |\n"
		"|                  |                 | option of either |                  |\n"
		"|                  |                 | using forward or |                  |\n"
		"|                  |                 | reverse mode     |                  |\n"
		"|                  |                 | directional      |                  |\n"
		"|                  |                 | derivatives, the |                  |\n"
		"|                  |                 | condition ad_wei |                  |\n"
		"|                  |                 | ght*nf<=(1-ad_we |                  |\n"
		"|                  |                 | ight)*na is used |                  |\n"
		"|                  |                 | where nf and na  |                  |\n"
		"|                  |                 | are estimates of |                  |\n"
		"|                  |                 | the number of    |                  |\n"
		"|                  |                 | forward/reverse  |                  |\n"
		"|                  |                 | mode directional |                  |\n"
		"|                  |                 | derivatives      |                  |\n"
		"|                  |                 | needed. By       |                  |\n"
		"|                  |                 | default,         |                  |\n"
		"|                  |                 | ad_weight is     |                  |\n"
		"|                  |                 | calculated       |                  |\n"
		"|                  |                 | automatically,   |                  |\n"
		"|                  |                 | but this can be  |                  |\n"
		"|                  |                 | overridden by    |                  |\n"
		"|                  |                 | setting this     |                  |\n"
		"|                  |                 | option. In       |                  |\n"
		"|                  |                 | particular, 0    |                  |\n"
		"|                  |                 | means forcing    |                  |\n"
		"|                  |                 | forward mode and |                  |\n"
		"|                  |                 | 1 forcing        |                  |\n"
		"|                  |                 | reverse mode.    |                  |\n"
		"|                  |                 | Leave unset for  |                  |\n"
		"|                  |                 | (class specific) |                  |\n"
		"|                  |                 | heuristics.      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| ad_weight_sp     | OT_DOUBLE       | Weighting factor | casadi::Function |\n"
		"|                  |                 | for sparsity     | Internal         |\n"
		"|                  |                 | pattern          |                  |\n"
		"|                  |                 | calculation calc |                  |\n"
		"|                  |                 | ulation.Override |                  |\n"
		"|                  |                 | s default        |                  |\n"
		"|                  |                 | behavior. Set to |                  |\n"
		"|                  |                 | 0 and 1 to force |                  |\n"
		"|                  |                 | forward and      |                  |\n"
		"|                  |                 | reverse mode     |                  |\n"
		"|                  |                 | respectively.    |                  |\n"
		"|                  |                 | Cf. option       |                  |\n"
		"|                  |                 | \"ad_weight\".     |                  |\n"
		"|                  |                 | When set to -1,  |                  |\n"
		"|                  |                 | sparsity is      |                  |\n"
		"|                  |                 | completely       |                  |\n"
		"|                  |                 | ignored and      |                  |\n"
		"|                  |                 | dense matrices   |                  |\n"
		"|                  |                 | are used.        |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| always_inline    | OT_BOOL         | Force inlining.  | casadi::Function |\n"
		"|                  |                 |                  | Internal         |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| compiler         | OT_STRING       | Just-in-time     | casadi::Function |\n"
		"|                  |                 | compiler plugin  | Internal         |\n"
		"|                  |                 | to be used.      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| const_A          | OT_BOOL         | Assume A is      | casadi::Expm     |\n"
		"|                  |                 | constant.        |                  |\n"
		"|                  |                 | Default: false.  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| custom_jacobian  | OT_FUNCTION     | Override         | casadi::Function |\n"
		"|                  |                 | CasADi's AD. Use | Internal         |\n"
		"|                  |                 | together with    |                  |\n"
		"|                  |                 | 'jac_penalty':   |                  |\n"
		"|                  |                 | 0. Note: Highly  |                  |\n"
		"|                  |                 | experimental.    |                  |\n"
		"|                  |                 | Syntax may break |                  |\n"
		"|                  |                 | often.           |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| derivative_of    | OT_FUNCTION     | The function is  | casadi::Function |\n"
		"|                  |                 | a derivative of  | Internal         |\n"
		"|                  |                 | another          |                  |\n"
		"|                  |                 | function. The    |                  |\n"
		"|                  |                 | type of          |                  |\n"
		"|                  |                 | derivative       |                  |\n"
		"|                  |                 | (directional     |                  |\n"
		"|                  |                 | derivative,      |                  |\n"
		"|                  |                 | Jacobian) is     |                  |\n"
		"|                  |                 | inferred from    |                  |\n"
		"|                  |                 | the function     |                  |\n"
		"|                  |                 | name.            |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump             | OT_BOOL         | Dump function to | casadi::Function |\n"
		"|                  |                 | file upon first  | Internal         |\n"
		"|                  |                 | evaluation.      |                  |\n"
		"|                  |                 | [false]          |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump_dir         | OT_STRING       | Directory to     | casadi::Function |\n"
		"|                  |                 | dump             | Internal         |\n"
		"|                  |                 | inputs/outputs   |                  |\n"
		"|                  |                 | to. Make sure    |                  |\n"
		"|                  |                 | the directory    |                  |\n"
		"|                  |                 | exists [.]       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump_format      | OT_STRING       | Choose file      | casadi::Function |\n"
		"|                  |                 | format to dump   | Internal         |\n"
		"|                  |                 | matrices. See    |                  |\n"
		"|                  |                 | DM.from_file     |                  |\n"
		"|                  |                 | [mtx]            |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump_in          | OT_BOOL         | Dump numerical   | casadi::Function |\n"
		"|                  |                 | values of inputs | Internal         |\n"
		"|                  |                 | to file          |                  |\n"
		"|                  |                 | (readable with   |                  |\n"
		"|                  |                 | DM.from_file )   |                  |\n"
		"|                  |                 | [default: false] |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| dump_out         | OT_BOOL         | Dump numerical   | casadi::Function |\n"
		"|                  |                 | values of        | Internal         |\n"
		"|                  |                 | outputs to file  |                  |\n"
		"|                  |                 | (readable with   |                  |\n"
		"|                  |                 | DM.from_file )   |                  |\n"
		"|                  |                 | [default: false] |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| enable_fd        | OT_BOOL         | Enable           | casadi::Function |\n"
		"|                  |                 | derivative       | Internal         |\n"
		"|                  |                 | calculation by   |                  |\n"
		"|                  |                 | finite           |                  |\n"
		"|                  |                 | differencing.    |                  |\n"
		"|                  |                 | [default:        |                  |\n"
		"|                  |                 | false]]          |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| enable_forward   | OT_BOOL         | Enable           | casadi::Function |\n"
		"|                  |                 | derivative       | Internal         |\n"
		"|                  |                 | calculation      |                  |\n"
		"|                  |                 | using generated  |                  |\n"
		"|                  |                 | functions for    |                  |\n"
		"|                  |                 | Jacobian-times-  |                  |\n"
		"|                  |                 | vector products  |                  |\n"
		"|                  |                 | - typically      |                  |\n"
		"|                  |                 | using forward    |                  |\n"
		"|                  |                 | mode AD - if     |                  |\n"
		"|                  |                 | available.       |                  |\n"
		"|                  |                 | [default: true]  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| enable_jacobian  | OT_BOOL         | Enable           | casadi::Function |\n"
		"|                  |                 | derivative       | Internal         |\n"
		"|                  |                 | calculation      |                  |\n"
		"|                  |                 | using generated  |                  |\n"
		"|                  |                 | functions for    |                  |\n"
		"|                  |                 | Jacobians of all |                  |\n"
		"|                  |                 | differentiable   |                  |\n"
		"|                  |                 | outputs with     |                  |\n"
		"|                  |                 | respect to all   |                  |\n"
		"|                  |                 | differentiable   |                  |\n"
		"|                  |                 | inputs - if      |                  |\n"
		"|                  |                 | available.       |                  |\n"
		"|                  |                 | [default: true]  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| enable_reverse   | OT_BOOL         | Enable           | casadi::Function |\n"
		"|                  |                 | derivative       | Internal         |\n"
		"|                  |                 | calculation      |                  |\n"
		"|                  |                 | using generated  |                  |\n"
		"|                  |                 | functions for    |                  |\n"
		"|                  |                 | transposed       |                  |\n"
		"|                  |                 | Jacobian-times-  |                  |\n"
		"|                  |                 | vector products  |                  |\n"
		"|                  |                 | - typically      |                  |\n"
		"|                  |                 | using reverse    |                  |\n"
		"|                  |                 | mode AD - if     |                  |\n"
		"|                  |                 | available.       |                  |\n"
		"|                  |                 | [default: true]  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| fd_method        | OT_STRING       | Method for       | casadi::Function |\n"
		"|                  |                 | finite           | Internal         |\n"
		"|                  |                 | differencing     |                  |\n"
		"|                  |                 | [default         |                  |\n"
		"|                  |                 | 'central']       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| fd_options       | OT_DICT         | Options to be    | casadi::Function |\n"
		"|                  |                 | passed to the    | Internal         |\n"
		"|                  |                 | finite           |                  |\n"
		"|                  |                 | difference       |                  |\n"
		"|                  |                 | instance         |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| forward_options  | OT_DICT         | Options to be    | casadi::Function |\n"
		"|                  |                 | passed to a      | Internal         |\n"
		"|                  |                 | forward mode     |                  |\n"
		"|                  |                 | constructor      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| gather_stats     | OT_BOOL         | Deprecated       | casadi::Function |\n"
		"|                  |                 | option           | Internal         |\n"
		"|                  |                 | (ignored):       |                  |\n"
		"|                  |                 | Statistics are   |                  |\n"
		"|                  |                 | now always       |                  |\n"
		"|                  |                 | collected.       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| input_scheme     | OT_STRINGVECTOR | Deprecated       | casadi::Function |\n"
		"|                  |                 | option (ignored) | Internal         |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| inputs_check     | OT_BOOL         | Throw exceptions | casadi::Function |\n"
		"|                  |                 | when the         | Internal         |\n"
		"|                  |                 | numerical values |                  |\n"
		"|                  |                 | of the inputs    |                  |\n"
		"|                  |                 | don't make sense |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| is_diff_in       | OT_BOOLVECTOR   | Indicate for     | casadi::Function |\n"
		"|                  |                 | each input if it | Internal         |\n"
		"|                  |                 | should be        |                  |\n"
		"|                  |                 | differentiable.  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| is_diff_out      | OT_BOOLVECTOR   | Indicate for     | casadi::Function |\n"
		"|                  |                 | each output if   | Internal         |\n"
		"|                  |                 | it should be     |                  |\n"
		"|                  |                 | differentiable.  |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jac_penalty      | OT_DOUBLE       | When requested   | casadi::Function |\n"
		"|                  |                 | for a number of  | Internal         |\n"
		"|                  |                 | forward/reverse  |                  |\n"
		"|                  |                 | directions, it   |                  |\n"
		"|                  |                 | may be cheaper   |                  |\n"
		"|                  |                 | to compute first |                  |\n"
		"|                  |                 | the full         |                  |\n"
		"|                  |                 | jacobian and     |                  |\n"
		"|                  |                 | then multiply    |                  |\n"
		"|                  |                 | with seeds,      |                  |\n"
		"|                  |                 | rather than      |                  |\n"
		"|                  |                 | obtain the       |                  |\n"
		"|                  |                 | requested        |                  |\n"
		"|                  |                 | directions in a  |                  |\n"
		"|                  |                 | straightforward  |                  |\n"
		"|                  |                 | manner. Casadi   |                  |\n"
		"|                  |                 | uses a heuristic |                  |\n"
		"|                  |                 | to decide which  |                  |\n"
		"|                  |                 | is cheaper. A    |                  |\n"
		"|                  |                 | high value of    |                  |\n"
		"|                  |                 | 'jac_penalty'    |                  |\n"
		"|                  |                 | makes it less    |                  |\n"
		"|                  |                 | likely for the   |                  |\n"
		"|                  |                 | heurstic to      |                  |\n"
		"|                  |                 | chose the full   |                  |\n"
		"|                  |                 | Jacobian         |                  |\n"
		"|                  |                 | strategy. The    |                  |\n"
		"|                  |                 | special value -1 |                  |\n"
		"|                  |                 | indicates never  |                  |\n"
		"|                  |                 | to use the full  |                  |\n"
		"|                  |                 | Jacobian         |                  |\n"
		"|                  |                 | strategy         |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit              | OT_BOOL         | Use just-in-time | casadi::Function |\n"
		"|                  |                 | compiler to      | Internal         |\n"
		"|                  |                 | speed up the     |                  |\n"
		"|                  |                 | evaluation       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_cleanup      | OT_BOOL         | Cleanup up the   | casadi::Function |\n"
		"|                  |                 | temporary source | Internal         |\n"
		"|                  |                 | file that jit    |                  |\n"
		"|                  |                 | creates.         |                  |\n"
		"|                  |                 | Default: true    |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_name         | OT_STRING       | The file name    | casadi::Function |\n"
		"|                  |                 | used to write    | Internal         |\n"
		"|                  |                 | out code. The    |                  |\n"
		"|                  |                 | actual file      |                  |\n"
		"|                  |                 | names used       |                  |\n"
		"|                  |                 | depend on 'jit_t |                  |\n"
		"|                  |                 | emp_suffix' and  |                  |\n"
		"|                  |                 | include          |                  |\n"
		"|                  |                 | extensions.      |                  |\n"
		"|                  |                 | Default:         |                  |\n"
		"|                  |                 | 'jit_tmp'        |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_options      | OT_DICT         | Options to be    | casadi::Function |\n"
		"|                  |                 | passed to the    | Internal         |\n"
		"|                  |                 | jit compiler.    |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_serialize    | OT_STRING       | Specify          | casadi::Function |\n"
		"|                  |                 | behaviour when   | Internal         |\n"
		"|                  |                 | serializing a    |                  |\n"
		"|                  |                 | jitted function: |                  |\n"
		"|                  |                 | SOURCE|link|embe |                  |\n"
		"|                  |                 | d.               |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| jit_temp_suffix  | OT_BOOL         | Use a temporary  | casadi::Function |\n"
		"|                  |                 | (seemingly       | Internal         |\n"
		"|                  |                 | random) filename |                  |\n"
		"|                  |                 | suffix for       |                  |\n"
		"|                  |                 | generated code   |                  |\n"
		"|                  |                 | and libraries.   |                  |\n"
		"|                  |                 | This is desired  |                  |\n"
		"|                  |                 | for thread-      |                  |\n"
		"|                  |                 | safety. This     |                  |\n"
		"|                  |                 | behaviour may    |                  |\n"
		"|                  |                 | defeat caching   |                  |\n"
		"|                  |                 | compiler         |                  |\n"
		"|                  |                 | wrappers.        |                  |\n"
		"|                  |                 | Default: true    |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| max_num_dir      | OT_INT          | Specify the      | casadi::Function |\n"
		"|                  |                 | maximum number   | Internal         |\n"
		"|                  |                 | of directions    |                  |\n"
		"|                  |                 | for derivative   |                  |\n"
		"|                  |                 | functions.       |                  |\n"
		"|                  |                 | Overrules the    |                  |\n"
		"|                  |                 | builtin optimize |                  |\n"
		"|                  |                 | d_num_dir.       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| never_inline     | OT_BOOL         | Forbid inlining. | casadi::Function |\n"
		"|                  |                 |                  | Internal         |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| output_scheme    | OT_STRINGVECTOR | Deprecated       | casadi::Function |\n"
		"|                  |                 | option (ignored) | Internal         |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| print_in         | OT_BOOL         | Print numerical  | casadi::Function |\n"
		"|                  |                 | values of inputs | Internal         |\n"
		"|                  |                 | [default: false] |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| print_out        | OT_BOOL         | Print numerical  | casadi::Function |\n"
		"|                  |                 | values of        | Internal         |\n"
		"|                  |                 | outputs          |                  |\n"
		"|                  |                 | [default: false] |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| print_time       | OT_BOOL         | print            | casadi::Function |\n"
		"|                  |                 | information      | Internal         |\n"
		"|                  |                 | about execution  |                  |\n"
		"|                  |                 | time. Implies    |                  |\n"
		"|                  |                 | record_time.     |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| record_time      | OT_BOOL         | record           | casadi::Function |\n"
		"|                  |                 | information      | Internal         |\n"
		"|                  |                 | about execution  |                  |\n"
		"|                  |                 | time, for        |                  |\n"
		"|                  |                 | retrieval with   |                  |\n"
		"|                  |                 | stats().         |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| regularity_check | OT_BOOL         | Throw exceptions | casadi::Function |\n"
		"|                  |                 | when NaN or Inf  | Internal         |\n"
		"|                  |                 | appears during   |                  |\n"
		"|                  |                 | evaluation       |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| reverse_options  | OT_DICT         | Options to be    | casadi::Function |\n"
		"|                  |                 | passed to a      | Internal         |\n"
		"|                  |                 | reverse mode     |                  |\n"
		"|                  |                 | constructor      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| user_data        | OT_VOIDPTR      | A user-defined   | casadi::Function |\n"
		"|                  |                 | field that can   | Internal         |\n"
		"|                  |                 | be used to       |                  |\n"
		"|                  |                 | identify the     |                  |\n"
		"|                  |                 | function or pass |                  |\n"
		"|                  |                 | additional       |                  |\n"
		"|                  |                 | information      |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"| verbose          | OT_BOOL         | Verbose          | casadi::Function |\n"
		"|                  |                 | evaluation  for  | Internal         |\n"
		"|                  |                 | debugging        |                  |\n"
		"+------------------+-----------------+------------------+------------------+\n"
		"\n"
		"List of plugins\n"
		"===============\n"
		"\n"
		"\n"
		"\n"
		"- slicot\n"
		"\n"
		"Note: some of the plugins in this list might not be available on your\n"
		"system. Also, there might be extra plugins available to you that are not\n"
		"listed here. You can obtain their documentation with\n"
		"Expm.doc(\"myextraplugin\")\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"slicot\n"
		"------\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"\n"
		"--------------------------------------------------------------------------------\n"
		"\n"
		"\n"
		"\n"
		"Joris Gillis\n"
		"\n"
		"\n"
		""},
	 { "expm_n_in", _wrap_expm_n_in, METH_NOARGS, "\n"
		"expm_n_in() -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of expm solver inputs.\n"
		"\n"
		"\n"
		""},
	 { "expm_n_out", _wrap_expm_n_out, METH_NOARGS, "\n"
		"expm_n_out() -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of expm solver outputs.\n"
		"\n"
		"\n"
		""},
	 { "has_expm", _wrap_has_expm, METH_O, "\n"
		"has_expm(std::string const & name) -> bool\n"
		"\n"
		"\n"
		"Check if a particular plugin is available.\n"
		"\n"
		"\n"
		""},
	 { "load_expm", _wrap_load_expm, METH_O, "\n"
		"load_expm(std::string const & name)\n"
		"\n"
		"\n"
		"Explicitly load a plugin dynamically.\n"
		"\n"
		"\n"
		""},
	 { "doc_expm", _wrap_doc_expm, METH_O, "\n"
		"doc_expm(std::string const & name) -> std::string\n"
		"\n"
		"\n"
		"Get the documentation string for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "interpolant", _wrap_interpolant, METH_VARARGS, "\n"
		"interpolant(std::string const & name, std::string const & solver, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & grid, std::vector< double,std::allocator< double > > const & values, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"interpolant(std::string const & name, std::string const & solver, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & grid, casadi_int m=1, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"interpolant(std::string const & name, std::string const & solver, std::vector< casadi_int,std::allocator< casadi_int > > const & grid_dims, casadi_int m=1, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"interpolant(std::string const & name, std::string const & solver, std::vector< casadi_int,std::allocator< casadi_int > > const & grid_dims, std::vector< double,std::allocator< double > > const & values, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Parametric variant of interpolant.\n"
		"\n"
		"The resulting function will have additional arguments for the grid and\n"
		"coefficients\n"
		"\n"
		"By default, derivatives wrt the coefficients are not supported (zero). Some\n"
		"interpolant plugins may support the inline=true which enables correct\n"
		"derivatives\n"
		"\n"
		"\n"
		""},
	 { "has_interpolant", _wrap_has_interpolant, METH_O, "\n"
		"has_interpolant(std::string const & name) -> bool\n"
		"\n"
		"\n"
		"Check if a particular plugin is available.\n"
		"\n"
		"\n"
		""},
	 { "load_interpolant", _wrap_load_interpolant, METH_O, "\n"
		"load_interpolant(std::string const & name)\n"
		"\n"
		"\n"
		"Explicitly load a plugin dynamically.\n"
		"\n"
		"\n"
		""},
	 { "doc_interpolant", _wrap_doc_interpolant, METH_O, "\n"
		"doc_interpolant(std::string const & name) -> std::string\n"
		"\n"
		"\n"
		"Get the documentation string for a plugin.\n"
		"\n"
		"\n"
		""},
	 { "new_CodeGenerator", _wrap_new_CodeGenerator, METH_VARARGS, "\n"
		"new_CodeGenerator(std::string const & name, casadi::Dict const & opts=casadi::Dict()) -> CodeGenerator\n"
		"\n"
		"\n"
		"Constructor.\n"
		"\n"
		"\n"
		""},
	 { "CodeGenerator_add", _wrap_CodeGenerator_add, METH_VARARGS, "\n"
		"CodeGenerator_add(CodeGenerator self, Function f, bool with_jac_sparsity=False)\n"
		"\n"
		"\n"
		"Add a function (name generated)\n"
		"\n"
		"\n"
		""},
	 { "CodeGenerator_dump", _wrap_CodeGenerator_dump, METH_O, "\n"
		"CodeGenerator_dump(CodeGenerator self) -> std::string\n"
		"\n"
		"\n"
		"Generate a file, return code as string.\n"
		"\n"
		"\n"
		""},
	 { "CodeGenerator_generate", _wrap_CodeGenerator_generate, METH_VARARGS, "\n"
		"CodeGenerator_generate(CodeGenerator self, std::string const & prefix=\"\") -> std::string\n"
		"\n"
		"\n"
		"Generate file(s) The \"prefix\" argument will be prepended to the generated\n"
		"files and may be a directory or a file prefix. returns the filename.\n"
		"\n"
		"\n"
		""},
	 { "CodeGenerator_add_include", _wrap_CodeGenerator_add_include, METH_VARARGS, "\n"
		"CodeGenerator_add_include(CodeGenerator self, std::string const & new_include, bool relative_path=False, std::string const & use_ifdef=std::string())\n"
		"\n"
		"\n"
		"Add an include file optionally using a relative path \"...\" instead of an\n"
		"absolute path <...>\n"
		"\n"
		"\n"
		""},
	 { "delete_CodeGenerator", _wrap_delete_CodeGenerator, METH_O, "delete_CodeGenerator(CodeGenerator self)"},
	 { "CodeGenerator_swigregister", CodeGenerator_swigregister, METH_O, NULL},
	 { "CodeGenerator_swiginit", CodeGenerator_swiginit, METH_VARARGS, NULL},
	 { "_horzcat", _wrap__horzcat, METH_VARARGS, "\n"
		"_horzcat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & v) -> Sparsity\n"
		"_horzcat(std::vector< casadi::MX,std::allocator< casadi::MX > > const & v) -> MX\n"
		"_horzcat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v) -> DM\n"
		"_horzcat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v) -> SX\n"
		""},
	 { "_vertcat", _wrap__vertcat, METH_VARARGS, "\n"
		"_vertcat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & v) -> Sparsity\n"
		"_vertcat(std::vector< casadi::MX,std::allocator< casadi::MX > > const & v) -> MX\n"
		"_vertcat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v) -> DM\n"
		"_vertcat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v) -> SX\n"
		""},
	 { "horzsplit", _wrap_horzsplit, METH_VARARGS, "\n"
		"horzsplit(Sparsity v, std::vector< casadi_int,std::allocator< casadi_int > > const & offset) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >\n"
		"horzsplit(Sparsity v, casadi_int incr=1) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >\n"
		"horzsplit(MX v, std::vector< casadi_int,std::allocator< casadi_int > > const & offset) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"horzsplit(MX v, casadi_int incr=1) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"horzsplit(DM v, std::vector< casadi_int,std::allocator< casadi_int > > const & offset) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"horzsplit(DM v, casadi_int incr=1) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"horzsplit(SX v, std::vector< casadi_int,std::allocator< casadi_int > > const & offset) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		"horzsplit(SX v, casadi_int incr=1) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		""},
	 { "offset", _wrap_offset, METH_VARARGS, "\n"
		"offset(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & v, bool vert=True) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"offset(std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, bool vert=True) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"offset(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v, bool vert=True) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		"offset(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v, bool vert=True) -> std::vector< casadi_int,std::allocator< casadi_int > >\n"
		""},
	 { "vertsplit", _wrap_vertsplit, METH_VARARGS, "\n"
		"vertsplit(Sparsity v, std::vector< casadi_int,std::allocator< casadi_int > > const & offset) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >\n"
		"vertsplit(Sparsity v, casadi_int incr=1) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >\n"
		"vertsplit(MX v, std::vector< casadi_int,std::allocator< casadi_int > > const & offset) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"vertsplit(MX v, casadi_int incr=1) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"vertsplit(DM v, std::vector< casadi_int,std::allocator< casadi_int > > const & offset) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"vertsplit(DM v, casadi_int incr=1) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"vertsplit(SX v, std::vector< casadi_int,std::allocator< casadi_int > > const & offset) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		"vertsplit(SX v, casadi_int incr=1) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		""},
	 { "blocksplit", _wrap_blocksplit, METH_VARARGS, "\n"
		"blocksplit(Sparsity x, std::vector< casadi_int,std::allocator< casadi_int > > const & vert_offset, std::vector< casadi_int,std::allocator< casadi_int > > const & horz_offset) -> std::vector< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >,std::allocator< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > > >\n"
		"blocksplit(Sparsity x, casadi_int vert_incr=1, casadi_int horz_incr=1) -> std::vector< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >,std::allocator< std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > > >\n"
		"blocksplit(MX x, std::vector< casadi_int,std::allocator< casadi_int > > const & vert_offset, std::vector< casadi_int,std::allocator< casadi_int > > const & horz_offset) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >\n"
		"blocksplit(MX x, casadi_int vert_incr=1, casadi_int horz_incr=1) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >\n"
		"blocksplit(DM x, std::vector< casadi_int,std::allocator< casadi_int > > const & vert_offset, std::vector< casadi_int,std::allocator< casadi_int > > const & horz_offset) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >\n"
		"blocksplit(DM x, casadi_int vert_incr=1, casadi_int horz_incr=1) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >\n"
		"blocksplit(SX x, std::vector< casadi_int,std::allocator< casadi_int > > const & vert_offset, std::vector< casadi_int,std::allocator< casadi_int > > const & horz_offset) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >\n"
		"blocksplit(SX x, casadi_int vert_incr=1, casadi_int horz_incr=1) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >\n"
		""},
	 { "_diagcat", _wrap__diagcat, METH_VARARGS, "\n"
		"_diagcat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & A) -> Sparsity\n"
		"_diagcat(std::vector< casadi::MX,std::allocator< casadi::MX > > const & A) -> MX\n"
		"_diagcat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & A) -> DM\n"
		"_diagcat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & A) -> SX\n"
		""},
	 { "diagsplit", _wrap_diagsplit, METH_VARARGS, "\n"
		"diagsplit(Sparsity x, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset1, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset2) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >\n"
		"diagsplit(Sparsity x, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >\n"
		"diagsplit(Sparsity x, casadi_int incr=1) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >\n"
		"diagsplit(Sparsity x, casadi_int incr1, casadi_int incr2) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >\n"
		"diagsplit(MX x, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset1, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset2) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"diagsplit(MX x, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"diagsplit(MX x, casadi_int incr=1) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"diagsplit(MX x, casadi_int incr1, casadi_int incr2) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"diagsplit(DM x, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset1, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset2) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"diagsplit(DM x, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"diagsplit(DM x, casadi_int incr=1) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"diagsplit(DM x, casadi_int incr1, casadi_int incr2) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"diagsplit(SX x, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset1, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset2) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		"diagsplit(SX x, std::vector< casadi_int,std::allocator< casadi_int > > const & output_offset) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		"diagsplit(SX x, casadi_int incr=1) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		"diagsplit(SX x, casadi_int incr1, casadi_int incr2) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		""},
	 { "_veccat", _wrap__veccat, METH_VARARGS, "\n"
		"_veccat(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & x) -> Sparsity\n"
		"_veccat(std::vector< casadi::MX,std::allocator< casadi::MX > > const & x) -> MX\n"
		"_veccat(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & x) -> DM\n"
		"_veccat(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & x) -> SX\n"
		""},
	 { "mtimes", _wrap_mtimes, METH_VARARGS, "\n"
		"mtimes(Sparsity x, Sparsity y) -> Sparsity\n"
		"mtimes(std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & args) -> Sparsity\n"
		"mtimes(MX x, MX y) -> MX\n"
		"mtimes(std::vector< casadi::MX,std::allocator< casadi::MX > > const & args) -> MX\n"
		"mtimes(DM x, DM y) -> DM\n"
		"mtimes(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & args) -> DM\n"
		"mtimes(SX x, SX y) -> SX\n"
		"mtimes(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & args) -> SX\n"
		""},
	 { "mac", _wrap_mac, METH_VARARGS, "\n"
		"mac(Sparsity X, Sparsity Y, Sparsity Z) -> Sparsity\n"
		"mac(MX X, MX Y, MX Z) -> MX\n"
		"mac(DM X, DM Y, DM Z) -> DM\n"
		"mac(SX X, SX Y, SX Z) -> SX\n"
		""},
	 { "transpose", _wrap_transpose, METH_VARARGS, "\n"
		"transpose(Sparsity X) -> Sparsity\n"
		"transpose(MX X) -> MX\n"
		"transpose(DM X) -> DM\n"
		"transpose(SX X) -> SX\n"
		"\n"
		"\n"
		"Transpose the matrix and get the reordering of the non-zero entries.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"mapping:  the non-zeros of the original matrix for each non-zero of the new\n"
		"matrix\n"
		"\n"
		"\n"
		""},
	 { "vec", _wrap_vec, METH_VARARGS, "\n"
		"vec(Sparsity a) -> Sparsity\n"
		"vec(MX a) -> MX\n"
		"vec(DM a) -> DM\n"
		"vec(SX a) -> SX\n"
		""},
	 { "reshape", _wrap_reshape, METH_VARARGS, "\n"
		"reshape(Sparsity a, casadi_int nrow, casadi_int ncol) -> Sparsity\n"
		"reshape(Sparsity a, std::pair< casadi_int,casadi_int > rc) -> Sparsity\n"
		"reshape(Sparsity a, Sparsity sp) -> Sparsity\n"
		"reshape(MX a, casadi_int nrow, casadi_int ncol) -> MX\n"
		"reshape(MX a, std::pair< casadi_int,casadi_int > rc) -> MX\n"
		"reshape(MX a, Sparsity sp) -> MX\n"
		"reshape(DM a, casadi_int nrow, casadi_int ncol) -> DM\n"
		"reshape(DM a, std::pair< casadi_int,casadi_int > rc) -> DM\n"
		"reshape(DM a, Sparsity sp) -> DM\n"
		"reshape(SX a, casadi_int nrow, casadi_int ncol) -> SX\n"
		"reshape(SX a, std::pair< casadi_int,casadi_int > rc) -> SX\n"
		"reshape(SX a, Sparsity sp) -> SX\n"
		""},
	 { "sprank", _wrap_sprank, METH_VARARGS, "\n"
		"sprank(Sparsity A) -> casadi_int\n"
		"sprank(MX A) -> casadi_int\n"
		"sprank(DM A) -> casadi_int\n"
		"sprank(SX A) -> casadi_int\n"
		""},
	 { "norm_0_mul", _wrap_norm_0_mul, METH_VARARGS, "\n"
		"norm_0_mul(Sparsity x, Sparsity y) -> casadi_int\n"
		"norm_0_mul(MX x, MX y) -> casadi_int\n"
		"norm_0_mul(DM x, DM y) -> casadi_int\n"
		"norm_0_mul(SX x, SX y) -> casadi_int\n"
		""},
	 { "triu", _wrap_triu, METH_VARARGS, "\n"
		"triu(Sparsity a, bool includeDiagonal=True) -> Sparsity\n"
		"triu(MX a, bool includeDiagonal=True) -> MX\n"
		"triu(DM a, bool includeDiagonal=True) -> DM\n"
		"triu(SX a, bool includeDiagonal=True) -> SX\n"
		""},
	 { "tril", _wrap_tril, METH_VARARGS, "\n"
		"tril(Sparsity a, bool includeDiagonal=True) -> Sparsity\n"
		"tril(MX a, bool includeDiagonal=True) -> MX\n"
		"tril(DM a, bool includeDiagonal=True) -> DM\n"
		"tril(SX a, bool includeDiagonal=True) -> SX\n"
		""},
	 { "kron", _wrap_kron, METH_VARARGS, "\n"
		"kron(Sparsity a, Sparsity b) -> Sparsity\n"
		"kron(MX a, MX b) -> MX\n"
		"kron(DM a, DM b) -> DM\n"
		"kron(SX a, SX b) -> SX\n"
		""},
	 { "repmat", _wrap_repmat, METH_VARARGS, "\n"
		"repmat(Sparsity A, casadi_int n, casadi_int m=1) -> Sparsity\n"
		"repmat(Sparsity A, std::pair< casadi_int,casadi_int > const & rc) -> Sparsity\n"
		"repmat(MX A, casadi_int n, casadi_int m=1) -> MX\n"
		"repmat(MX A, std::pair< casadi_int,casadi_int > const & rc) -> MX\n"
		"repmat(DM A, casadi_int n, casadi_int m=1) -> DM\n"
		"repmat(DM A, std::pair< casadi_int,casadi_int > const & rc) -> DM\n"
		"repmat(SX A, casadi_int n, casadi_int m=1) -> SX\n"
		"repmat(SX A, std::pair< casadi_int,casadi_int > const & rc) -> SX\n"
		""},
	 { "sum2", _wrap_sum2, METH_VARARGS, "\n"
		"sum2(Sparsity x) -> Sparsity\n"
		"sum2(MX x) -> MX\n"
		"sum2(DM x) -> DM\n"
		"sum2(SX x) -> SX\n"
		""},
	 { "sum1", _wrap_sum1, METH_VARARGS, "\n"
		"sum1(Sparsity x) -> Sparsity\n"
		"sum1(MX x) -> MX\n"
		"sum1(DM x) -> DM\n"
		"sum1(SX x) -> SX\n"
		""},
	 { "plus", _wrap_plus, METH_VARARGS, "\n"
		"plus(MX x, MX y) -> MX\n"
		"plus(DM x, DM y) -> DM\n"
		"plus(SX x, SX y) -> SX\n"
		"plus(double const & x, double const & y) -> double\n"
		""},
	 { "minus", _wrap_minus, METH_VARARGS, "\n"
		"minus(MX x, MX y) -> MX\n"
		"minus(DM x, DM y) -> DM\n"
		"minus(SX x, SX y) -> SX\n"
		"minus(double const & x, double const & y) -> double\n"
		""},
	 { "times", _wrap_times, METH_VARARGS, "\n"
		"times(MX x, MX y) -> MX\n"
		"times(DM x, DM y) -> DM\n"
		"times(SX x, SX y) -> SX\n"
		"times(double const & x, double const & y) -> double\n"
		""},
	 { "rdivide", _wrap_rdivide, METH_VARARGS, "\n"
		"rdivide(MX x, MX y) -> MX\n"
		"rdivide(DM x, DM y) -> DM\n"
		"rdivide(SX x, SX y) -> SX\n"
		"rdivide(double const & x, double const & y) -> double\n"
		""},
	 { "ldivide", _wrap_ldivide, METH_VARARGS, "\n"
		"ldivide(MX x, MX y) -> MX\n"
		"ldivide(DM x, DM y) -> DM\n"
		"ldivide(SX x, SX y) -> SX\n"
		"ldivide(double const & x, double const & y) -> double\n"
		""},
	 { "lt", _wrap_lt, METH_VARARGS, "\n"
		"lt(MX x, MX y) -> MX\n"
		"lt(DM x, DM y) -> DM\n"
		"lt(SX x, SX y) -> SX\n"
		"lt(double const & x, double const & y) -> double\n"
		""},
	 { "le", _wrap_le, METH_VARARGS, "\n"
		"le(MX x, MX y) -> MX\n"
		"le(DM x, DM y) -> DM\n"
		"le(SX x, SX y) -> SX\n"
		"le(double const & x, double const & y) -> double\n"
		""},
	 { "gt", _wrap_gt, METH_VARARGS, "\n"
		"gt(MX x, MX y) -> MX\n"
		"gt(DM x, DM y) -> DM\n"
		"gt(SX x, SX y) -> SX\n"
		"gt(double const & x, double const & y) -> double\n"
		""},
	 { "ge", _wrap_ge, METH_VARARGS, "\n"
		"ge(MX x, MX y) -> MX\n"
		"ge(DM x, DM y) -> DM\n"
		"ge(SX x, SX y) -> SX\n"
		"ge(double const & x, double const & y) -> double\n"
		""},
	 { "eq", _wrap_eq, METH_VARARGS, "\n"
		"eq(MX x, MX y) -> MX\n"
		"eq(DM x, DM y) -> DM\n"
		"eq(SX x, SX y) -> SX\n"
		"eq(double const & x, double const & y) -> double\n"
		""},
	 { "ne", _wrap_ne, METH_VARARGS, "\n"
		"ne(MX x, MX y) -> MX\n"
		"ne(DM x, DM y) -> DM\n"
		"ne(SX x, SX y) -> SX\n"
		"ne(double const & x, double const & y) -> double\n"
		""},
	 { "logic_and", _wrap_logic_and, METH_VARARGS, "\n"
		"logic_and(MX x, MX y) -> MX\n"
		"logic_and(DM x, DM y) -> DM\n"
		"logic_and(SX x, SX y) -> SX\n"
		"logic_and(double const & x, double const & y) -> double\n"
		""},
	 { "logic_or", _wrap_logic_or, METH_VARARGS, "\n"
		"logic_or(MX x, MX y) -> MX\n"
		"logic_or(DM x, DM y) -> DM\n"
		"logic_or(SX x, SX y) -> SX\n"
		"logic_or(double const & x, double const & y) -> double\n"
		""},
	 { "logic_not", _wrap_logic_not, METH_VARARGS, "\n"
		"logic_not(MX x) -> MX\n"
		"logic_not(DM x) -> DM\n"
		"logic_not(SX x) -> SX\n"
		"logic_not(double const & x) -> double\n"
		""},
	 { "fabs", _wrap_fabs, METH_VARARGS, "\n"
		"fabs(MX x) -> MX\n"
		"fabs(DM x) -> DM\n"
		"fabs(SX x) -> SX\n"
		"fabs(double const & x) -> double\n"
		""},
	 { "sqrt", _wrap_sqrt, METH_VARARGS, "\n"
		"sqrt(MX x) -> MX\n"
		"sqrt(DM x) -> DM\n"
		"sqrt(SX x) -> SX\n"
		"sqrt(double const & x) -> double\n"
		""},
	 { "sin", _wrap_sin, METH_VARARGS, "\n"
		"sin(MX x) -> MX\n"
		"sin(DM x) -> DM\n"
		"sin(SX x) -> SX\n"
		"sin(double const & x) -> double\n"
		""},
	 { "cos", _wrap_cos, METH_VARARGS, "\n"
		"cos(MX x) -> MX\n"
		"cos(DM x) -> DM\n"
		"cos(SX x) -> SX\n"
		"cos(double const & x) -> double\n"
		""},
	 { "tan", _wrap_tan, METH_VARARGS, "\n"
		"tan(MX x) -> MX\n"
		"tan(DM x) -> DM\n"
		"tan(SX x) -> SX\n"
		"tan(double const & x) -> double\n"
		""},
	 { "atan", _wrap_atan, METH_VARARGS, "\n"
		"atan(MX x) -> MX\n"
		"atan(DM x) -> DM\n"
		"atan(SX x) -> SX\n"
		"atan(double const & x) -> double\n"
		""},
	 { "asin", _wrap_asin, METH_VARARGS, "\n"
		"asin(MX x) -> MX\n"
		"asin(DM x) -> DM\n"
		"asin(SX x) -> SX\n"
		"asin(double const & x) -> double\n"
		""},
	 { "acos", _wrap_acos, METH_VARARGS, "\n"
		"acos(MX x) -> MX\n"
		"acos(DM x) -> DM\n"
		"acos(SX x) -> SX\n"
		"acos(double const & x) -> double\n"
		""},
	 { "tanh", _wrap_tanh, METH_VARARGS, "\n"
		"tanh(MX x) -> MX\n"
		"tanh(DM x) -> DM\n"
		"tanh(SX x) -> SX\n"
		"tanh(double const & x) -> double\n"
		""},
	 { "sinh", _wrap_sinh, METH_VARARGS, "\n"
		"sinh(MX x) -> MX\n"
		"sinh(DM x) -> DM\n"
		"sinh(SX x) -> SX\n"
		"sinh(double const & x) -> double\n"
		""},
	 { "cosh", _wrap_cosh, METH_VARARGS, "\n"
		"cosh(MX x) -> MX\n"
		"cosh(DM x) -> DM\n"
		"cosh(SX x) -> SX\n"
		"cosh(double const & x) -> double\n"
		""},
	 { "atanh", _wrap_atanh, METH_VARARGS, "\n"
		"atanh(MX x) -> MX\n"
		"atanh(DM x) -> DM\n"
		"atanh(SX x) -> SX\n"
		"atanh(double const & x) -> double\n"
		""},
	 { "asinh", _wrap_asinh, METH_VARARGS, "\n"
		"asinh(MX x) -> MX\n"
		"asinh(DM x) -> DM\n"
		"asinh(SX x) -> SX\n"
		"asinh(double const & x) -> double\n"
		""},
	 { "acosh", _wrap_acosh, METH_VARARGS, "\n"
		"acosh(MX x) -> MX\n"
		"acosh(DM x) -> DM\n"
		"acosh(SX x) -> SX\n"
		"acosh(double const & x) -> double\n"
		""},
	 { "exp", _wrap_exp, METH_VARARGS, "\n"
		"exp(MX x) -> MX\n"
		"exp(DM x) -> DM\n"
		"exp(SX x) -> SX\n"
		"exp(double const & x) -> double\n"
		""},
	 { "log", _wrap_log, METH_VARARGS, "\n"
		"log(MX x) -> MX\n"
		"log(DM x) -> DM\n"
		"log(SX x) -> SX\n"
		"log(double const & x) -> double\n"
		""},
	 { "log10", _wrap_log10, METH_VARARGS, "\n"
		"log10(MX x) -> MX\n"
		"log10(DM x) -> DM\n"
		"log10(SX x) -> SX\n"
		"log10(double const & x) -> double\n"
		""},
	 { "floor", _wrap_floor, METH_VARARGS, "\n"
		"floor(MX x) -> MX\n"
		"floor(DM x) -> DM\n"
		"floor(SX x) -> SX\n"
		"floor(double const & x) -> double\n"
		""},
	 { "ceil", _wrap_ceil, METH_VARARGS, "\n"
		"ceil(MX x) -> MX\n"
		"ceil(DM x) -> DM\n"
		"ceil(SX x) -> SX\n"
		"ceil(double const & x) -> double\n"
		""},
	 { "erf", _wrap_erf, METH_VARARGS, "\n"
		"erf(MX x) -> MX\n"
		"erf(DM x) -> DM\n"
		"erf(SX x) -> SX\n"
		"erf(double const & x) -> double\n"
		""},
	 { "erfinv", _wrap_erfinv, METH_VARARGS, "\n"
		"erfinv(MX x) -> MX\n"
		"erfinv(DM x) -> DM\n"
		"erfinv(SX x) -> SX\n"
		"erfinv(double const & x) -> double\n"
		""},
	 { "sign", _wrap_sign, METH_VARARGS, "\n"
		"sign(MX x) -> MX\n"
		"sign(DM x) -> DM\n"
		"sign(SX x) -> SX\n"
		"sign(double const & x) -> double\n"
		""},
	 { "power", _wrap_power, METH_VARARGS, "\n"
		"power(MX x, MX n) -> MX\n"
		"power(DM x, DM n) -> DM\n"
		"power(SX x, SX n) -> SX\n"
		"power(double const & x, double const & n) -> double\n"
		""},
	 { "mod", _wrap_mod, METH_VARARGS, "\n"
		"mod(MX x, MX y) -> MX\n"
		"mod(DM x, DM y) -> DM\n"
		"mod(SX x, SX y) -> SX\n"
		"mod(double const & x, double const & y) -> double\n"
		""},
	 { "fmod", _wrap_fmod, METH_VARARGS, "\n"
		"fmod(MX x, MX y) -> MX\n"
		"fmod(DM x, DM y) -> DM\n"
		"fmod(SX x, SX y) -> SX\n"
		"fmod(double const & x, double const & y) -> double\n"
		""},
	 { "atan2", _wrap_atan2, METH_VARARGS, "\n"
		"atan2(MX x, MX y) -> MX\n"
		"atan2(DM x, DM y) -> DM\n"
		"atan2(SX x, SX y) -> SX\n"
		"atan2(double const & x, double const & y) -> double\n"
		""},
	 { "fmin", _wrap_fmin, METH_VARARGS, "\n"
		"fmin(MX x, MX y) -> MX\n"
		"fmin(DM x, DM y) -> DM\n"
		"fmin(SX x, SX y) -> SX\n"
		"fmin(double const & x, double const & y) -> double\n"
		""},
	 { "fmax", _wrap_fmax, METH_VARARGS, "\n"
		"fmax(MX x, MX y) -> MX\n"
		"fmax(DM x, DM y) -> DM\n"
		"fmax(SX x, SX y) -> SX\n"
		"fmax(double const & x, double const & y) -> double\n"
		""},
	 { "simplify", _wrap_simplify, METH_VARARGS, "\n"
		"simplify(MX x) -> MX\n"
		"simplify(DM x) -> DM\n"
		"simplify(SX x) -> SX\n"
		"simplify(double const & x) -> double\n"
		"\n"
		"\n"
		"Simplify an expression.\n"
		"\n"
		"\n"
		""},
	 { "is_equal", _wrap_is_equal, METH_VARARGS, "\n"
		"is_equal(MX x, MX y, casadi_int depth=0) -> bool\n"
		"is_equal(DM x, DM y, casadi_int depth=0) -> bool\n"
		"is_equal(SX x, SX y, casadi_int depth=0) -> bool\n"
		"is_equal(double const & x, double const & y, casadi_int depth=0) -> bool\n"
		""},
	 { "copysign", _wrap_copysign, METH_VARARGS, "\n"
		"copysign(MX x, MX y) -> MX\n"
		"copysign(DM x, DM y) -> DM\n"
		"copysign(SX x, SX y) -> SX\n"
		"copysign(double const & x, double const & y) -> double\n"
		""},
	 { "constpow", _wrap_constpow, METH_VARARGS, "\n"
		"constpow(MX x, MX y) -> MX\n"
		"constpow(DM x, DM y) -> DM\n"
		"constpow(SX x, SX y) -> SX\n"
		"constpow(double const & x, double const & y) -> double\n"
		""},
	 { "mpower", _wrap_mpower, METH_VARARGS, "\n"
		"mpower(MX x, MX n) -> MX\n"
		"mpower(DM x, DM n) -> DM\n"
		"mpower(SX x, SX n) -> SX\n"
		"\n"
		"\n"
		"Matrix power x^n.\n"
		"\n"
		"\n"
		""},
	 { "mrdivide", _wrap_mrdivide, METH_VARARGS, "\n"
		"mrdivide(MX x, MX y) -> MX\n"
		"mrdivide(DM x, DM y) -> DM\n"
		"mrdivide(SX x, SX y) -> SX\n"
		"\n"
		"\n"
		"Matrix divide (cf. slash '/' in MATLAB)\n"
		"\n"
		"\n"
		""},
	 { "mldivide", _wrap_mldivide, METH_VARARGS, "\n"
		"mldivide(MX x, MX y) -> MX\n"
		"mldivide(DM x, DM y) -> DM\n"
		"mldivide(SX x, SX y) -> SX\n"
		"\n"
		"\n"
		"Matrix divide (cf. backslash '\\\\' in MATLAB)\n"
		"\n"
		"\n"
		""},
	 { "symvar", _wrap_symvar, METH_VARARGS, "\n"
		"symvar(MX x) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"symvar(DM x) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"symvar(SX x) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		"\n"
		"\n"
		"Get symbols present in expression.\n"
		"\n"
		"Returned vector is ordered according to the order of variable()/parameter()\n"
		"calls used to create the variables\n"
		"\n"
		"\n"
		""},
	 { "bilin", _wrap_bilin, METH_VARARGS, "\n"
		"bilin(MX A, MX x, MX y) -> MX\n"
		"bilin(DM A, DM x, DM y) -> DM\n"
		"bilin(SX A, SX x, SX y) -> SX\n"
		"\n"
		"\n"
		"Calculate bilinear form x^T A y.\n"
		"\n"
		"\n"
		""},
	 { "rank1", _wrap_rank1, METH_VARARGS, "\n"
		"rank1(MX A, MX alpha, MX x, MX y) -> MX\n"
		"rank1(DM A, DM alpha, DM x, DM y) -> DM\n"
		"rank1(SX A, SX alpha, SX x, SX y) -> SX\n"
		"\n"
		"\n"
		"Make a rank-1 update to a matrix A Calculates A + 1/2 * alpha * x*y'.\n"
		"\n"
		"\n"
		""},
	 { "sumsqr", _wrap_sumsqr, METH_VARARGS, "\n"
		"sumsqr(MX X) -> MX\n"
		"sumsqr(DM X) -> DM\n"
		"sumsqr(SX X) -> SX\n"
		"\n"
		"\n"
		"Calculate sum of squares: sum_ij X_ij^2.\n"
		"\n"
		"\n"
		""},
	 { "linspace", _wrap_linspace, METH_VARARGS, "\n"
		"linspace(MX a, MX b, casadi_int nsteps) -> MX\n"
		"linspace(DM a, DM b, casadi_int nsteps) -> DM\n"
		"linspace(SX a, SX b, casadi_int nsteps) -> SX\n"
		"\n"
		"\n"
		"Matlab's linspace command.\n"
		"\n"
		"\n"
		""},
	 { "interp1d", _wrap_interp1d, METH_VARARGS, "\n"
		"interp1d(std::vector< double,std::allocator< double > > const & x, MX v, std::vector< double,std::allocator< double > > const & xq, std::string const & mode=\"linear\", bool equidistant=False) -> MX\n"
		"interp1d(std::vector< double,std::allocator< double > > const & x, DM v, std::vector< double,std::allocator< double > > const & xq, std::string const & mode=\"linear\", bool equidistant=False) -> DM\n"
		"interp1d(std::vector< double,std::allocator< double > > const & x, SX v, std::vector< double,std::allocator< double > > const & xq, std::string const & mode=\"linear\", bool equidistant=False) -> SX\n"
		"\n"
		"\n"
		"Performs 1d linear interpolation.\n"
		"\n"
		"The data-points to be interpolated are given as (x[i], v[i]). xq[j] is used\n"
		"as interplating value\n"
		"\n"
		"\n"
		""},
	 { "soc", _wrap_soc, METH_VARARGS, "\n"
		"soc(MX x, MX y) -> MX\n"
		"soc(DM x, DM y) -> DM\n"
		"soc(SX x, SX y) -> SX\n"
		"\n"
		"\n"
		"Construct second-order-convex.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"x:  vector expression of size n\n"
		"\n"
		"y:  scalar expression\n"
		"\n"
		"soc(x,y) computes [y*eye(n) x; x' y]\n"
		"\n"
		"soc(x,y) positive semi definite <=> || x ||_2 <= y\n"
		"\n"
		"\n"
		""},
	 { "cross", _wrap_cross, METH_VARARGS, "\n"
		"cross(MX a, MX b, casadi_int dim=-1) -> MX\n"
		"cross(DM a, DM b, casadi_int dim=-1) -> DM\n"
		"cross(SX a, SX b, casadi_int dim=-1) -> SX\n"
		"\n"
		"\n"
		"Matlab's cross command.\n"
		"\n"
		"\n"
		""},
	 { "skew", _wrap_skew, METH_VARARGS, "\n"
		"skew(MX a) -> MX\n"
		"skew(DM a) -> DM\n"
		"skew(SX a) -> SX\n"
		"\n"
		"\n"
		"Generate a skew symmetric matrix from a 3-vector.\n"
		"\n"
		"\n"
		""},
	 { "inv_skew", _wrap_inv_skew, METH_VARARGS, "\n"
		"inv_skew(MX a) -> MX\n"
		"inv_skew(DM a) -> DM\n"
		"inv_skew(SX a) -> SX\n"
		"\n"
		"\n"
		"Generate the 3-vector progenitor of a skew symmetric matrix.\n"
		"\n"
		"\n"
		""},
	 { "det", _wrap_det, METH_VARARGS, "\n"
		"det(MX A) -> MX\n"
		"det(DM A) -> DM\n"
		"det(SX A) -> SX\n"
		"\n"
		"\n"
		"Matrix determinant (experimental)\n"
		"\n"
		"\n"
		""},
	 { "inv_minor", _wrap_inv_minor, METH_VARARGS, "\n"
		"inv_minor(MX A) -> MX\n"
		"inv_minor(DM A) -> DM\n"
		"inv_minor(SX A) -> SX\n"
		"\n"
		"\n"
		"Matrix inverse (experimental)\n"
		"\n"
		"\n"
		""},
	 { "inv", _wrap_inv, METH_VARARGS, "\n"
		"inv(MX A) -> MX\n"
		"inv(MX A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> MX\n"
		"inv(DM A) -> DM\n"
		"inv(DM A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> DM\n"
		"inv(SX A) -> SX\n"
		"inv(SX A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> SX\n"
		"\n"
		"\n"
		"Matrix inverse.\n"
		"\n"
		"\n"
		""},
	 { "trace", _wrap_trace, METH_VARARGS, "\n"
		"trace(MX a) -> MX\n"
		"trace(DM a) -> DM\n"
		"trace(SX a) -> SX\n"
		"\n"
		"\n"
		"Matrix trace.\n"
		"\n"
		"\n"
		""},
	 { "tril2symm", _wrap_tril2symm, METH_VARARGS, "\n"
		"tril2symm(MX a) -> MX\n"
		"tril2symm(DM a) -> DM\n"
		"tril2symm(SX a) -> SX\n"
		"\n"
		"\n"
		"Convert a lower triangular matrix to a symmetric one.\n"
		"\n"
		"\n"
		""},
	 { "triu2symm", _wrap_triu2symm, METH_VARARGS, "\n"
		"triu2symm(MX a) -> MX\n"
		"triu2symm(DM a) -> DM\n"
		"triu2symm(SX a) -> SX\n"
		"\n"
		"\n"
		"Convert a upper triangular matrix to a symmetric one.\n"
		"\n"
		"\n"
		""},
	 { "norm_fro", _wrap_norm_fro, METH_VARARGS, "\n"
		"norm_fro(MX x) -> MX\n"
		"norm_fro(DM x) -> DM\n"
		"norm_fro(SX x) -> SX\n"
		"\n"
		"\n"
		"Frobenius norm.\n"
		"\n"
		"\n"
		""},
	 { "norm_2", _wrap_norm_2, METH_VARARGS, "\n"
		"norm_2(MX x) -> MX\n"
		"norm_2(DM x) -> DM\n"
		"norm_2(SX x) -> SX\n"
		"\n"
		"\n"
		"2-norm\n"
		"\n"
		"\n"
		""},
	 { "norm_1", _wrap_norm_1, METH_VARARGS, "\n"
		"norm_1(MX x) -> MX\n"
		"norm_1(DM x) -> DM\n"
		"norm_1(SX x) -> SX\n"
		"\n"
		"\n"
		"1-norm\n"
		"\n"
		"\n"
		""},
	 { "norm_inf", _wrap_norm_inf, METH_VARARGS, "\n"
		"norm_inf(MX x) -> MX\n"
		"norm_inf(DM x) -> DM\n"
		"norm_inf(SX x) -> SX\n"
		"\n"
		"\n"
		"Infinity-norm.\n"
		"\n"
		"\n"
		""},
	 { "dot", _wrap_dot, METH_VARARGS, "\n"
		"dot(MX x, MX y) -> MX\n"
		"dot(DM x, DM y) -> DM\n"
		"dot(SX x, SX y) -> SX\n"
		"\n"
		"\n"
		"Inner product of two matrices with x and y matrices of the same dimension.\n"
		"\n"
		"\n"
		""},
	 { "nullspace", _wrap_nullspace, METH_VARARGS, "\n"
		"nullspace(MX A) -> MX\n"
		"nullspace(DM A) -> DM\n"
		"nullspace(SX A) -> SX\n"
		"\n"
		"\n"
		"Computes the nullspace of a matrix A.\n"
		"\n"
		"Finds Z m-by-(m-n) such that AZ = 0 with A n-by-m with m > n\n"
		"\n"
		"Assumes A is full rank\n"
		"\n"
		"Inspired by Numerical Methods in Scientific Computing by Ake Bjorck\n"
		"\n"
		"\n"
		""},
	 { "polyval", _wrap_polyval, METH_VARARGS, "\n"
		"polyval(MX p, MX x) -> MX\n"
		"polyval(DM p, DM x) -> DM\n"
		"polyval(SX p, SX x) -> SX\n"
		"\n"
		"\n"
		"Evaluate a polynomial with coefficients p in x.\n"
		"\n"
		"\n"
		""},
	 { "diag", _wrap_diag, METH_VARARGS, "\n"
		"diag(MX A) -> MX\n"
		"diag(DM A) -> DM\n"
		"diag(SX A) -> SX\n"
		"\n"
		"\n"
		"Create diagonal sparsity pattern.\n"
		"\n"
		"\n"
		""},
	 { "unite", _wrap_unite, METH_VARARGS, "\n"
		"unite(MX A, MX B) -> MX\n"
		"unite(DM A, DM B) -> DM\n"
		"unite(SX A, SX B) -> SX\n"
		"\n"
		"\n"
		"Union of two sparsity patterns.\n"
		"\n"
		"\n"
		""},
	 { "densify", _wrap_densify, METH_VARARGS, "\n"
		"densify(MX x) -> MX\n"
		"densify(DM x) -> DM\n"
		"densify(SX x) -> SX\n"
		"\n"
		"\n"
		"Make the matrix dense and assign nonzeros to a value.\n"
		"\n"
		"\n"
		""},
	 { "project", _wrap_project, METH_VARARGS, "\n"
		"project(MX A, Sparsity sp, bool intersect=False) -> MX\n"
		"project(DM A, Sparsity sp, bool intersect=False) -> DM\n"
		"project(SX A, Sparsity sp, bool intersect=False) -> SX\n"
		"\n"
		"\n"
		"Create a new matrix with a given sparsity pattern but with the nonzeros\n"
		"taken from an existing matrix.\n"
		"\n"
		"\n"
		""},
	 { "if_else", _wrap_if_else, METH_VARARGS, "\n"
		"if_else(MX cond, MX if_true, MX if_false, bool short_circuit=False) -> MX\n"
		"if_else(DM cond, DM if_true, DM if_false, bool short_circuit=False) -> DM\n"
		"if_else(SX cond, SX if_true, SX if_false, bool short_circuit=False) -> SX\n"
		"\n"
		"\n"
		"Branching on MX nodes Ternary operator, \"cond ? if_true : if_false\".\n"
		"\n"
		"\n"
		""},
	 { "conditional", _wrap_conditional, METH_VARARGS, "\n"
		"conditional(MX ind, std::vector< casadi::MX,std::allocator< casadi::MX > > const & x, MX x_default, bool short_circuit=False) -> MX\n"
		"conditional(DM ind, std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & x, DM x_default, bool short_circuit=False) -> DM\n"
		"conditional(SX ind, std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & x, SX x_default, bool short_circuit=False) -> SX\n"
		"\n"
		"\n"
		"Create a switch.\n"
		"\n"
		"If the condition\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"ind:  evaluates to the integer k, where 0<=k<f.size(), then x[k] will be\n"
		"returned, otherwise\n"
		"\n"
		"x_default:  will be returned.\n"
		"\n"
		"\n"
		""},
	 { "depends_on", _wrap_depends_on, METH_VARARGS, "\n"
		"depends_on(MX f, MX arg) -> bool\n"
		"depends_on(DM f, DM arg) -> bool\n"
		"depends_on(SX f, SX arg) -> bool\n"
		"\n"
		"\n"
		"Check if expression depends on the argument The argument must be symbolic.\n"
		"\n"
		"\n"
		""},
	 { "solve", _wrap_solve, METH_VARARGS, "\n"
		"solve(MX A, MX b) -> MX\n"
		"solve(MX A, MX b, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> MX\n"
		"solve(DM A, DM b) -> DM\n"
		"solve(DM A, DM b, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> DM\n"
		"solve(SX A, SX b) -> SX\n"
		"solve(SX A, SX b, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> SX\n"
		"\n"
		"\n"
		"Solve the QP.\n"
		"\n"
		"\n"
		""},
	 { "pinv", _wrap_pinv, METH_VARARGS, "\n"
		"pinv(MX A) -> MX\n"
		"pinv(MX A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> MX\n"
		"pinv(DM A) -> DM\n"
		"pinv(DM A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> DM\n"
		"pinv(SX A) -> SX\n"
		"pinv(SX A, std::string const & lsolver, casadi::Dict const & opts=casadi::Dict()) -> SX\n"
		"\n"
		"\n"
		"Computes the Moore-Penrose pseudo-inverse.\n"
		"\n"
		"If the matrix A is fat (size1>size2), mul(A, pinv(A)) is unity. If the\n"
		"matrix A is slender (size2<size1), mul(pinv(A), A) is unity.\n"
		"\n"
		"\n"
		""},
	 { "expm_const", _wrap_expm_const, METH_VARARGS, "\n"
		"expm_const(MX A, MX t) -> MX\n"
		"expm_const(DM A, DM t) -> DM\n"
		"expm_const(SX A, SX t) -> SX\n"
		""},
	 { "expm", _wrap_expm, METH_VARARGS, "\n"
		"expm(MX A) -> MX\n"
		"expm(DM A) -> DM\n"
		"expm(SX A) -> SX\n"
		""},
	 { "jacobian", _wrap_jacobian, METH_VARARGS, "\n"
		"jacobian(MX ex, MX arg, casadi::Dict const & opts=casadi::Dict()) -> MX\n"
		"jacobian(DM ex, DM arg, casadi::Dict const & opts=casadi::Dict()) -> DM\n"
		"jacobian(SX ex, SX arg, casadi::Dict const & opts=casadi::Dict()) -> SX\n"
		"\n"
		"\n"
		"Calculate Jacobian.\n"
		"\n"
		"\n"
		""},
	 { "jtimes", _wrap_jtimes, METH_VARARGS, "\n"
		"jtimes(MX ex, MX arg, MX v, bool tr=False) -> MX\n"
		"jtimes(DM ex, DM arg, DM v, bool tr=False) -> DM\n"
		"jtimes(SX ex, SX arg, SX v, bool tr=False) -> SX\n"
		"\n"
		"\n"
		"Calculate the Jacobian and multiply by a vector from the right This is\n"
		"equivalent to mul(jacobian(ex, arg), v) or mul(jacobian(ex, arg).T, v) for\n"
		"tr set to false and true respectively. If contrast to these expressions, it\n"
		"will use directional derivatives which is typically (but not necessarily)\n"
		"more efficient if the complete Jacobian is not needed and v has few rows.\n"
		"\n"
		"\n"
		""},
	 { "linearize", _wrap_linearize, METH_VARARGS, "\n"
		"linearize(MX f, MX x, MX x0) -> MX\n"
		"linearize(DM f, DM x, DM x0) -> DM\n"
		"linearize(SX f, SX x, SX x0) -> SX\n"
		"\n"
		"\n"
		"Linearize an expression.\n"
		"\n"
		"\n"
		""},
	 { "which_depends", _wrap_which_depends, METH_VARARGS, "\n"
		"which_depends(MX expr, MX var, casadi_int order=1, bool tr=False) -> std::vector< bool,std::allocator< bool > >\n"
		"which_depends(DM expr, DM var, casadi_int order=1, bool tr=False) -> std::vector< bool,std::allocator< bool > >\n"
		"which_depends(SX expr, SX var, casadi_int order=1, bool tr=False) -> std::vector< bool,std::allocator< bool > >\n"
		"\n"
		"\n"
		"Find out which variables enter with some order.\n"
		"\n"
		"\n"
		""},
	 { "is_linear", _wrap_is_linear, METH_VARARGS, "\n"
		"is_linear(MX expr, MX var) -> bool\n"
		"is_linear(DM expr, DM var) -> bool\n"
		"is_linear(SX expr, SX var) -> bool\n"
		"\n"
		"\n"
		"Is expr linear in var?\n"
		"\n"
		"False negatives are possible (an expression may not be recognised as linear\n"
		"while it really is), false positives not.\n"
		"\n"
		"\n"
		""},
	 { "is_quadratic", _wrap_is_quadratic, METH_VARARGS, "\n"
		"is_quadratic(MX expr, MX var) -> bool\n"
		"is_quadratic(DM expr, DM var) -> bool\n"
		"is_quadratic(SX expr, SX var) -> bool\n"
		"\n"
		"\n"
		"Is expr quadratic in var?\n"
		"\n"
		"False negatives are possible (an expression may not be recognised as\n"
		"quadratic while it really is), false positives not.\n"
		"\n"
		"\n"
		""},
	 { "gradient", _wrap_gradient, METH_VARARGS, "\n"
		"gradient(MX ex, MX arg) -> MX\n"
		"gradient(DM ex, DM arg) -> DM\n"
		"gradient(SX ex, SX arg) -> SX\n"
		"\n"
		"\n"
		"Calculate Jacobian.\n"
		"\n"
		"\n"
		""},
	 { "tangent", _wrap_tangent, METH_VARARGS, "\n"
		"tangent(MX ex, MX arg) -> MX\n"
		"tangent(DM ex, DM arg) -> DM\n"
		"tangent(SX ex, SX arg) -> SX\n"
		"\n"
		"\n"
		"Calculate Jacobian.\n"
		"\n"
		"\n"
		""},
	 { "hessian", _wrap_hessian, METH_VARARGS, "\n"
		"hessian(MX ex, MX arg) -> MX\n"
		"hessian(DM ex, DM arg) -> DM\n"
		"hessian(SX ex, SX arg) -> SX\n"
		""},
	 { "quadratic_coeff", _wrap_quadratic_coeff, METH_VARARGS, "\n"
		"quadratic_coeff(MX ex, MX arg, bool check=True)\n"
		"quadratic_coeff(DM ex, DM arg, bool check=True)\n"
		"quadratic_coeff(SX ex, SX arg, bool check=True)\n"
		"\n"
		"\n"
		"Recognizes quadratic form in scalar expression.\n"
		"\n"
		"1/2*x' A x + b' x + c\n"
		"\n"
		"e = 0.5*bilin(A,x,x)+dot(b,x)+c\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"check[in]:  When true (default), A is checked to be independent of x.\n"
		"Provided to deal with false positive dependency checks.\n"
		"\n"
		"\n"
		""},
	 { "linear_coeff", _wrap_linear_coeff, METH_VARARGS, "\n"
		"linear_coeff(MX ex, MX arg, bool check=True)\n"
		"linear_coeff(DM ex, DM arg, bool check=True)\n"
		"linear_coeff(SX ex, SX arg, bool check=True)\n"
		"\n"
		"\n"
		"Recognizes linear form in vector expression.\n"
		"\n"
		"A x + b\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"check[in]:  When true (default)m, A is checked to be independent of x.\n"
		"Provided to deal with false positive dependency checks.\n"
		"\n"
		"\n"
		""},
	 { "n_nodes", _wrap_n_nodes, METH_VARARGS, "\n"
		"n_nodes(MX A) -> casadi_int\n"
		"n_nodes(DM A) -> casadi_int\n"
		"n_nodes(SX A) -> casadi_int\n"
		""},
	 { "print_operator", _wrap_print_operator, METH_VARARGS, "\n"
		"print_operator(MX xb, std::vector< std::string,std::allocator< std::string > > const & args) -> std::string\n"
		"print_operator(DM xb, std::vector< std::string,std::allocator< std::string > > const & args) -> std::string\n"
		"print_operator(SX xb, std::vector< std::string,std::allocator< std::string > > const & args) -> std::string\n"
		"\n"
		"\n"
		"Get a string representation for a binary MatType, using custom arguments.\n"
		"\n"
		"\n"
		""},
	 { "repsum", _wrap_repsum, METH_VARARGS, "\n"
		"repsum(MX A, casadi_int n, casadi_int m=1) -> MX\n"
		"repsum(DM A, casadi_int n, casadi_int m=1) -> DM\n"
		"repsum(SX A, casadi_int n, casadi_int m=1) -> SX\n"
		"\n"
		"\n"
		"Given a repeated matrix, computes the sum of repeated parts.\n"
		"\n"
		"\n"
		""},
	 { "diff", _wrap_diff, METH_VARARGS, "\n"
		"diff(MX A, casadi_int n=1, casadi_index axis=-1) -> MX\n"
		"diff(DM A, casadi_int n=1, casadi_index axis=-1) -> DM\n"
		"diff(SX A, casadi_int n=1, casadi_index axis=-1) -> SX\n"
		"\n"
		"\n"
		"Returns difference (n-th order) along given axis (MATLAB convention)\n"
		"\n"
		"\n"
		""},
	 { "cumsum", _wrap_cumsum, METH_VARARGS, "\n"
		"cumsum(MX A, casadi_index axis=-1) -> MX\n"
		"cumsum(DM A, casadi_index axis=-1) -> DM\n"
		"cumsum(SX A, casadi_index axis=-1) -> SX\n"
		"\n"
		"\n"
		"Returns cumulative sum along given axis (MATLAB convention)\n"
		"\n"
		"\n"
		""},
	 { "einstein", _wrap_einstein, METH_VARARGS, "\n"
		"einstein(MX A, MX B, MX C, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_a, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_b, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_c, std::vector< casadi_int,std::allocator< casadi_int > > const & a, std::vector< casadi_int,std::allocator< casadi_int > > const & b, std::vector< casadi_int,std::allocator< casadi_int > > const & c) -> MX\n"
		"einstein(MX A, MX B, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_a, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_b, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_c, std::vector< casadi_int,std::allocator< casadi_int > > const & a, std::vector< casadi_int,std::allocator< casadi_int > > const & b, std::vector< casadi_int,std::allocator< casadi_int > > const & c) -> MX\n"
		"einstein(DM A, DM B, DM C, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_a, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_b, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_c, std::vector< casadi_int,std::allocator< casadi_int > > const & a, std::vector< casadi_int,std::allocator< casadi_int > > const & b, std::vector< casadi_int,std::allocator< casadi_int > > const & c) -> DM\n"
		"einstein(DM A, DM B, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_a, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_b, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_c, std::vector< casadi_int,std::allocator< casadi_int > > const & a, std::vector< casadi_int,std::allocator< casadi_int > > const & b, std::vector< casadi_int,std::allocator< casadi_int > > const & c) -> DM\n"
		"einstein(SX A, SX B, SX C, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_a, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_b, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_c, std::vector< casadi_int,std::allocator< casadi_int > > const & a, std::vector< casadi_int,std::allocator< casadi_int > > const & b, std::vector< casadi_int,std::allocator< casadi_int > > const & c) -> SX\n"
		"einstein(SX A, SX B, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_a, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_b, std::vector< casadi_int,std::allocator< casadi_int > > const & dim_c, std::vector< casadi_int,std::allocator< casadi_int > > const & a, std::vector< casadi_int,std::allocator< casadi_int > > const & b, std::vector< casadi_int,std::allocator< casadi_int > > const & c) -> SX\n"
		"\n"
		"\n"
		"Computes an einstein dense tensor contraction.\n"
		"\n"
		"Computes the product: C_c = A_a + B_b where a b c are index/einstein\n"
		"notation in an encoded form\n"
		"\n"
		"For example, an matrix-matrix product may be written as: C_ij = A_ik B_kj\n"
		"\n"
		"The encoded form uses strictly negative numbers to indicate labels. For the\n"
		"above example, we would have: a {-1, -3} b {-3, -2} c {-1 -2}\n"
		"\n"
		"\n"
		""},
	 { "mmin", _wrap_mmin, METH_VARARGS, "\n"
		"mmin(MX x) -> MX\n"
		"mmin(DM x) -> DM\n"
		"mmin(SX x) -> SX\n"
		"\n"
		"\n"
		"Smallest element in a matrix.\n"
		"\n"
		"\n"
		""},
	 { "mmax", _wrap_mmax, METH_VARARGS, "\n"
		"mmax(MX x) -> MX\n"
		"mmax(DM x) -> DM\n"
		"mmax(SX x) -> SX\n"
		"\n"
		"\n"
		"Largest element in a matrix.\n"
		"\n"
		"\n"
		""},
	 { "evalf", _wrap_evalf, METH_VARARGS, "\n"
		"evalf(MX x) -> DM\n"
		"evalf(DM x) -> DM\n"
		"evalf(SX x) -> DM\n"
		"\n"
		"\n"
		"Evaluates the expression numerically.\n"
		"\n"
		"An error is raised when the expression contains symbols\n"
		"\n"
		"\n"
		""},
	 { "forward", _wrap_forward, METH_VARARGS, "\n"
		"forward(std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const & v, casadi::Dict const & opts=casadi::Dict()) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >\n"
		"forward(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & ex, std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & arg, std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const & v, casadi::Dict const & opts=casadi::Dict()) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >\n"
		"forward(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & ex, std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & arg, std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const & v, casadi::Dict const & opts=casadi::Dict()) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >\n"
		"\n"
		"\n"
		"Forward directional derivative.\n"
		"\n"
		"\n"
		""},
	 { "reverse", _wrap_reverse, METH_VARARGS, "\n"
		"reverse(std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex, std::vector< casadi::MX,std::allocator< casadi::MX > > const & arg, std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const & v, casadi::Dict const & opts=casadi::Dict()) -> std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > >\n"
		"reverse(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & ex, std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & arg, std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const & v, casadi::Dict const & opts=casadi::Dict()) -> std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > >\n"
		"reverse(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & ex, std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & arg, std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const & v, casadi::Dict const & opts=casadi::Dict()) -> std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > >\n"
		"\n"
		"\n"
		"Reverse directional derivative.\n"
		"\n"
		"\n"
		""},
	 { "substitute", _wrap_substitute, METH_VARARGS, "\n"
		"substitute(MX ex, MX v, MX vdef) -> MX\n"
		"substitute(std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex, std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, std::vector< casadi::MX,std::allocator< casadi::MX > > const & vdef) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"substitute(DM ex, DM v, DM vdef) -> DM\n"
		"substitute(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & ex, std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v, std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & vdef) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >\n"
		"substitute(SX ex, SX v, SX vdef) -> SX\n"
		"substitute(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & ex, std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v, std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & vdef) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >\n"
		"\n"
		"\n"
		"Substitute variable var with expression expr in multiple expressions.\n"
		"\n"
		"\n"
		""},
	 { "substitute_inplace", _wrap_substitute_inplace, METH_VARARGS, "\n"
		"substitute_inplace(std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, std::vector< casadi::MX,std::allocator< casadi::MX > > & INOUT1, std::vector< casadi::MX,std::allocator< casadi::MX > > & INOUT2, bool reverse=False)\n"
		"substitute_inplace(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & v, std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > & INOUT1, std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > & INOUT2, bool reverse=False)\n"
		"substitute_inplace(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & v, std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > & INOUT1, std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > & INOUT2, bool reverse=False)\n"
		"\n"
		"\n"
		"Inplace substitution with piggyback expressions Substitute variables v out\n"
		"of the expressions vdef sequentially, as well as out of a number of other\n"
		"expressions piggyback.\n"
		"\n"
		"\n"
		""},
	 { "shared", _wrap_shared, METH_VARARGS, "\n"
		"shared(std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex, std::string const & v_prefix=\"v_\", std::string const & v_suffix=\"\")\n"
		"shared(std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & ex, std::string const & v_prefix=\"v_\", std::string const & v_suffix=\"\")\n"
		"shared(std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & ex, std::string const & v_prefix=\"v_\", std::string const & v_suffix=\"\")\n"
		"\n"
		"\n"
		"Get a shared (owning) reference.\n"
		"\n"
		"\n"
		""},
	 { "blockcat", _wrap_blockcat, METH_VARARGS, "\n"
		"blockcat(Sparsity A, Sparsity B, Sparsity C, Sparsity D) -> Sparsity\n"
		"blockcat(MX A, MX B, MX C, MX D) -> MX\n"
		"blockcat(DM A, DM B, DM C, DM D) -> DM\n"
		"blockcat(SX A, SX B, SX C, SX D) -> SX\n"
		"blockcat(std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > const & v) -> MX\n"
		"blockcat(std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > const & v) -> DM\n"
		"blockcat(std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > const & v) -> SX\n"
		""},
	 { "logic_all", _wrap_logic_all, METH_VARARGS, "\n"
		"logic_all(DM x) -> DM\n"
		"logic_all(SX x) -> SX\n"
		"\n"
		"\n"
		"Get a vector of indices (nested slice)\n"
		"\n"
		"\n"
		""},
	 { "logic_any", _wrap_logic_any, METH_VARARGS, "\n"
		"logic_any(DM x) -> DM\n"
		"logic_any(SX x) -> SX\n"
		"\n"
		"\n"
		"Returns true only if any element in the matrix is true.\n"
		"\n"
		"\n"
		""},
	 { "adj", _wrap_adj, METH_VARARGS, "\n"
		"adj(DM A) -> DM\n"
		"adj(SX A) -> SX\n"
		"\n"
		"\n"
		"Matrix adjoint.\n"
		"\n"
		"\n"
		""},
	 { "minor", _wrap_minor, METH_VARARGS, "\n"
		"minor(DM x, casadi_int i, casadi_int j) -> DM\n"
		"minor(SX x, casadi_int i, casadi_int j) -> SX\n"
		"\n"
		"\n"
		"Get the (i,j) minor matrix.\n"
		"\n"
		"\n"
		""},
	 { "cofactor", _wrap_cofactor, METH_VARARGS, "\n"
		"cofactor(DM x, casadi_int i, casadi_int j) -> DM\n"
		"cofactor(SX x, casadi_int i, casadi_int j) -> SX\n"
		"\n"
		"\n"
		"Get the (i,j) cofactor matrix.\n"
		"\n"
		"\n"
		""},
	 { "qr", _wrap_qr, METH_VARARGS, "\n"
		"qr(DM A)\n"
		"qr(SX A)\n"
		"\n"
		"\n"
		"QR factorization using the modified Gram-Schmidt algorithm More stable than\n"
		"the classical Gram-Schmidt, but may break down if the rows of A are nearly\n"
		"linearly dependent See J. Demmel: Applied Numerical Linear Algebra\n"
		"(algorithm 3.1.). Note that in SWIG, Q and R are returned by value.\n"
		"\n"
		"\n"
		""},
	 { "qr_sparse", _wrap_qr_sparse, METH_VARARGS, "\n"
		"qr_sparse(DM A, bool amd=True)\n"
		"qr_sparse(SX A, bool amd=True)\n"
		"\n"
		"\n"
		"Symbolic QR factorization Returns the sparsity pattern of V (compact\n"
		"representation of Q) and R as well as vectors needed for the numerical\n"
		"factorization and solution. The implementation is a modified version of\n"
		"CSparse Copyright(c) Timothy A. Davis, 2006-2009 Licensed as a derivative\n"
		"work under the GNU LGPL.\n"
		"\n"
		"\n"
		""},
	 { "qr_solve", _wrap_qr_solve, METH_VARARGS, "\n"
		"qr_solve(DM b, DM v, DM r, DM beta, std::vector< casadi_int,std::allocator< casadi_int > > const & prinv, std::vector< casadi_int,std::allocator< casadi_int > > const & pc, bool tr=False) -> DM\n"
		"qr_solve(SX b, SX v, SX r, SX beta, std::vector< casadi_int,std::allocator< casadi_int > > const & prinv, std::vector< casadi_int,std::allocator< casadi_int > > const & pc, bool tr=False) -> SX\n"
		"\n"
		"\n"
		"Solve using a sparse QR factorization.\n"
		"\n"
		"\n"
		""},
	 { "ldl", _wrap_ldl, METH_VARARGS, "\n"
		"ldl(DM A, bool amd=True)\n"
		"ldl(SX A, bool amd=True)\n"
		"\n"
		"\n"
		"Symbolic LDL factorization Returns the sparsity pattern of L^T.\n"
		"\n"
		"The implementation is a modified version of LDL Copyright(c) Timothy A.\n"
		"Davis, 2005-2013 Licensed as a derivative work under the GNU LGPL\n"
		"\n"
		"\n"
		""},
	 { "ldl_solve", _wrap_ldl_solve, METH_VARARGS, "\n"
		"ldl_solve(DM b, DM D, DM LT, std::vector< casadi_int,std::allocator< casadi_int > > const & p) -> DM\n"
		"ldl_solve(SX b, SX D, SX LT, std::vector< casadi_int,std::allocator< casadi_int > > const & p) -> SX\n"
		"\n"
		"\n"
		"Solve using a sparse LDL^T factorization.\n"
		"\n"
		"\n"
		""},
	 { "chol", _wrap_chol, METH_VARARGS, "\n"
		"chol(DM A) -> DM\n"
		"chol(SX A) -> SX\n"
		"\n"
		"\n"
		"Obtain a Cholesky factorisation of a matrix Performs and LDL transformation\n"
		"[L,D] = ldl(A) and returns diag(sqrt(D))*L'.\n"
		"\n"
		"\n"
		""},
	 { "norm_inf_mul", _wrap_norm_inf_mul, METH_VARARGS, "\n"
		"norm_inf_mul(DM x, DM y) -> DM\n"
		"norm_inf_mul(SX x, SX y) -> SX\n"
		"\n"
		"\n"
		"Inf-norm of a Matrix-Matrix product.\n"
		"\n"
		"\n"
		""},
	 { "sparsify", _wrap_sparsify, METH_VARARGS, "\n"
		"sparsify(DM A, double tol=0) -> DM\n"
		"sparsify(SX A, double tol=0) -> SX\n"
		"\n"
		"\n"
		"Make a matrix sparse by removing numerical zeros.\n"
		"\n"
		"\n"
		""},
	 { "expand", _wrap_expand, METH_VARARGS, "\n"
		"expand(DM ex)\n"
		"expand(SX ex)\n"
		"\n"
		"\n"
		"Expand the expression as a weighted sum (with constant weights)\n"
		"\n"
		"\n"
		""},
	 { "pw_const", _wrap_pw_const, METH_VARARGS, "\n"
		"pw_const(DM t, DM tval, DM val) -> DM\n"
		"pw_const(SX t, SX tval, SX val) -> SX\n"
		"\n"
		"\n"
		"Create a piecewise constant function Create a piecewise constant function\n"
		"with n=val.size() intervals.\n"
		"\n"
		"Inputs:\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"t:  a scalar variable (e.g. time)\n"
		"\n"
		"tval:  vector with the discrete values of t at the interval transitions\n"
		"(length n-1)\n"
		"\n"
		"val:  vector with the value of the function for each interval (length n)\n"
		"\n"
		"\n"
		""},
	 { "pw_lin", _wrap_pw_lin, METH_VARARGS, "\n"
		"pw_lin(DM t, DM tval, DM val) -> DM\n"
		"pw_lin(SX t, SX tval, SX val) -> SX\n"
		"\n"
		"\n"
		"t a scalar variable (e.g. time)\n"
		"\n"
		"Create a piecewise linear function Create a piecewise linear function:\n"
		"\n"
		"Inputs: tval vector with the the discrete values of t (monotonically\n"
		"increasing) val vector with the corresponding function values (same length\n"
		"as tval)\n"
		"\n"
		"\n"
		""},
	 { "heaviside", _wrap_heaviside, METH_VARARGS, "\n"
		"heaviside(DM x) -> DM\n"
		"heaviside(SX x) -> SX\n"
		"\n"
		"\n"
		"Heaviside function.\n"
		"\n"
		"\\\\[ \\\\begin {cases} H(x) = 0 & x<0 \\\\\\\\ H(x) = 1/2 & x=0 \\\\\\\\\n"
		"H(x) = 1 & x>0 \\\\\\\\ \\\\end {cases} \\\\]\n"
		"\n"
		"\n"
		""},
	 { "rectangle", _wrap_rectangle, METH_VARARGS, "\n"
		"rectangle(DM x) -> DM\n"
		"rectangle(SX x) -> SX\n"
		"\n"
		"\n"
		"rectangle function\n"
		"\n"
		"\\\\[ \\\\begin {cases} \\\\Pi(x) = 1 & |x| < 1/2 \\\\\\\\ \\\\Pi(x) = 1/2 &\n"
		"|x| = 1/2 \\\\\\\\ \\\\Pi(x) = 0 & |x| > 1/2 \\\\\\\\ \\\\end {cases} \\\\]\n"
		"\n"
		"Also called: gate function, block function, band function, pulse function,\n"
		"window function\n"
		"\n"
		"\n"
		""},
	 { "triangle", _wrap_triangle, METH_VARARGS, "\n"
		"triangle(DM x) -> DM\n"
		"triangle(SX x) -> SX\n"
		"\n"
		"\n"
		"triangle function\n"
		"\n"
		"\\\\[ \\\\begin {cases} \\\\Lambda(x) = 0 & |x| >= 1 \\\\\\\\ \\\\Lambda(x)\n"
		"= 1-|x| & |x| < 1 \\\\end {cases} \\\\]\n"
		"\n"
		"\n"
		""},
	 { "ramp", _wrap_ramp, METH_VARARGS, "\n"
		"ramp(DM x) -> DM\n"
		"ramp(SX x) -> SX\n"
		"\n"
		"\n"
		"ramp function\n"
		"\n"
		"\\\\[ \\\\begin {cases} R(x) = 0 & x <= 1 \\\\\\\\ R(x) = x & x > 1 \\\\\\\\\n"
		"\\\\end {cases} \\\\]\n"
		"\n"
		"Also called: slope function\n"
		"\n"
		"\n"
		""},
	 { "gauss_quadrature", _wrap_gauss_quadrature, METH_VARARGS, "\n"
		"gauss_quadrature(DM f, DM x, DM a, DM b, casadi_int order=5) -> DM\n"
		"gauss_quadrature(DM f, DM x, DM a, DM b, casadi_int order, DM w) -> DM\n"
		"gauss_quadrature(SX f, SX x, SX a, SX b, casadi_int order=5) -> SX\n"
		"gauss_quadrature(SX f, SX x, SX a, SX b, casadi_int order, SX w) -> SX\n"
		"\n"
		"\n"
		"Matrix adjoint.\n"
		"\n"
		"\n"
		""},
	 { "taylor", _wrap_taylor, METH_VARARGS, "\n"
		"taylor(DM ex, DM x, DM a=0, casadi_int order=1) -> DM\n"
		"taylor(SX ex, SX x, SX a=0, casadi_int order=1) -> SX\n"
		"\n"
		"\n"
		"univariate Taylor series expansion\n"
		"\n"
		"Calculate the Taylor expansion of expression 'ex' up to order 'order' with\n"
		"respect to variable 'x' around the point 'a'\n"
		"\n"
		"$(x)=f(a)+f'(a)(x-a)+f''(a)\\\\frac\n"
		"{(x-a)^2}{2!}+f'''(a)\\\\frac{(x-a)^3}{3!}+\\\\ldots$\n"
		"\n"
		"Example usage:\n"
		"\n"
		"::\n"
		"\n"
		">>   x\n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "mtaylor", _wrap_mtaylor, METH_VARARGS, "\n"
		"mtaylor(DM ex, DM x, DM a, casadi_int order=1) -> DM\n"
		"mtaylor(DM ex, DM x, DM a, casadi_int order, std::vector< casadi_int,std::allocator< casadi_int > > const & order_contributions) -> DM\n"
		"mtaylor(SX ex, SX x, SX a, casadi_int order=1) -> SX\n"
		"mtaylor(SX ex, SX x, SX a, casadi_int order, std::vector< casadi_int,std::allocator< casadi_int > > const & order_contributions) -> SX\n"
		"\n"
		"\n"
		"multivariate Taylor series expansion\n"
		"\n"
		"Do Taylor expansions until the aggregated order of a term is equal to\n"
		"'order'. The aggregated order of $x^n y^m$ equals $n+m$.\n"
		"\n"
		"The argument order_contributions can denote how match each variable\n"
		"contributes to the aggregated order. If x=[x, y] and order_contributions=[1,\n"
		"2], then the aggregated order of $x^n y^m$ equals $1n+2m$.\n"
		"\n"
		"Example usage\n"
		"\n"
		"$ \\\\sin(b+a)+\\\\cos(b+a)(x-a)+\\\\cos(b+a)(y-b) $ $ y+x-(x^3+3y x^2+3 y^2\n"
		"x+y^3)/6 $ $ (-3 x^2 y-x^3)/6+y+x $\n"
		"\n"
		"\n"
		""},
	 { "poly_coeff", _wrap_poly_coeff, METH_VARARGS, "\n"
		"poly_coeff(DM ex, DM x) -> DM\n"
		"poly_coeff(SX ex, SX x) -> SX\n"
		"\n"
		"\n"
		"extracts polynomial coefficients from an expression\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"ex:  Scalar expression that represents a polynomial\n"
		"\n"
		"x:  Scalar symbol that the polynomial is build up with\n"
		"\n"
		"\n"
		""},
	 { "poly_roots", _wrap_poly_roots, METH_VARARGS, "\n"
		"poly_roots(DM p) -> DM\n"
		"poly_roots(SX p) -> SX\n"
		"\n"
		"\n"
		"Attempts to find the roots of a polynomial.\n"
		"\n"
		"This will only work for polynomials up to order 3 It is assumed that the\n"
		"roots are real.\n"
		"\n"
		"\n"
		""},
	 { "eig_symbolic", _wrap_eig_symbolic, METH_VARARGS, "\n"
		"eig_symbolic(DM m) -> DM\n"
		"eig_symbolic(SX m) -> SX\n"
		"\n"
		"\n"
		"Attempts to find the eigenvalues of a symbolic matrix This will only work\n"
		"for up to 3x3 matrices.\n"
		"\n"
		"\n"
		""},
	 { "find", _wrap_find, METH_O, "\n"
		"find(MX x) -> MX\n"
		"\n"
		"\n"
		"Get the location of all non-zero elements as they would appear in a Dense\n"
		"matrix A : DenseMatrix 4 x 3 B : SparseMatrix 4 x 3 , 5 structural non-\n"
		"zeros.\n"
		"\n"
		"k = A.find() A[k] will contain the elements of A that are non-zero in B\n"
		"\n"
		"Inverse of nonzeros.\n"
		"\n"
		"\n"
		""},
	 { "low", _wrap_low, METH_VARARGS, "\n"
		"low(MX v, MX p, casadi::Dict const & options=casadi::Dict()) -> MX\n"
		"\n"
		"\n"
		"Find first nonzero If failed, returns the number of rows.\n"
		"\n"
		"\n"
		""},
	 { "inv_node", _wrap_inv_node, METH_O, "\n"
		"inv_node(MX x) -> MX\n"
		"\n"
		"\n"
		"Inverse node.\n"
		"\n"
		"\n"
		""},
	 { "matrix_expand", _wrap_matrix_expand, METH_VARARGS, "\n"
		"matrix_expand(std::vector< casadi::MX,std::allocator< casadi::MX > > const & e, std::vector< casadi::MX,std::allocator< casadi::MX > > const & boundary=std::vector< casadi::MX >(), casadi::Dict const & options=casadi::Dict()) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"matrix_expand(MX e, std::vector< casadi::MX,std::allocator< casadi::MX > > const & boundary=std::vector< casadi::MX >(), casadi::Dict const & options=casadi::Dict()) -> MX\n"
		"\n"
		"\n"
		"Expand MX graph to SXFunction call.\n"
		"\n"
		"Expand the given expression e, optionally supplying expressions contained in\n"
		"it at which expansion should stop.\n"
		"\n"
		"\n"
		""},
	 { "graph_substitute", _wrap_graph_substitute, METH_VARARGS, "\n"
		"graph_substitute(MX ex, std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, std::vector< casadi::MX,std::allocator< casadi::MX > > const & vdef) -> MX\n"
		"graph_substitute(std::vector< casadi::MX,std::allocator< casadi::MX > > const & ex, std::vector< casadi::MX,std::allocator< casadi::MX > > const & v, std::vector< casadi::MX,std::allocator< casadi::MX > > const & vdef) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"Substitute multiple expressions in graph Substitute variable var with\n"
		"expression expr in multiple expressions, preserving nodes.\n"
		"\n"
		"\n"
		""},
	 { "bspline", _wrap_bspline, METH_VARARGS, "\n"
		"bspline(MX x, DM coeffs, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & knots, std::vector< casadi_int,std::allocator< casadi_int > > const & degree, casadi_int m, casadi::Dict const & opts=casadi::Dict()) -> MX\n"
		"bspline(MX x, MX coeffs, std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const & knots, std::vector< casadi_int,std::allocator< casadi_int > > const & degree, casadi_int m, casadi::Dict const & opts=casadi::Dict()) -> MX\n"
		"\n"
		"\n"
		"Find first nonzero If failed, returns the number of rows.\n"
		"\n"
		"\n"
		""},
	 { "convexify", _wrap_convexify, METH_VARARGS, "\n"
		"convexify(MX H, casadi::Dict const & opts=casadi::Dict()) -> MX\n"
		"\n"
		"\n"
		"Find first nonzero If failed, returns the number of rows.\n"
		"\n"
		"\n"
		""},
	 { "Importer_type_name", _wrap_Importer_type_name, METH_NOARGS, "Importer_type_name() -> std::string"},
	 { "Importer_test_cast", _wrap_Importer_test_cast, METH_O, "Importer_test_cast(casadi::SharedObjectInternal const * ptr) -> bool"},
	 { "Importer_has_plugin", _wrap_Importer_has_plugin, METH_O, "Importer_has_plugin(std::string const & name) -> bool"},
	 { "Importer_load_plugin", _wrap_Importer_load_plugin, METH_O, "Importer_load_plugin(std::string const & name)"},
	 { "Importer_doc", _wrap_Importer_doc, METH_O, "Importer_doc(std::string const & name) -> std::string"},
	 { "Importer_plugin_name", _wrap_Importer_plugin_name, METH_O, "\n"
		"Importer_plugin_name(Importer self) -> std::string\n"
		"\n"
		"\n"
		"Query plugin name.\n"
		"\n"
		"\n"
		""},
	 { "Importer_has_function", _wrap_Importer_has_function, METH_VARARGS, "Importer_has_function(Importer self, std::string const & symname) -> bool"},
	 { "Importer_has_meta", _wrap_Importer_has_meta, METH_VARARGS, "\n"
		"Importer_has_meta(Importer self, std::string const & cmd, casadi_int ind=-1) -> bool\n"
		"\n"
		"\n"
		"Does a meta entry exist?\n"
		"\n"
		"\n"
		""},
	 { "Importer_get_meta", _wrap_Importer_get_meta, METH_VARARGS, "\n"
		"Importer_get_meta(Importer self, std::string const & cmd, casadi_int ind=-1) -> std::string\n"
		"\n"
		"\n"
		"Get entry as a text.\n"
		"\n"
		"\n"
		""},
	 { "Importer_inlined", _wrap_Importer_inlined, METH_VARARGS, "\n"
		"Importer_inlined(Importer self, std::string const & symname) -> bool\n"
		"\n"
		"\n"
		"Check if a function is inlined.\n"
		"\n"
		"\n"
		""},
	 { "Importer_body", _wrap_Importer_body, METH_VARARGS, "\n"
		"Importer_body(Importer self, std::string const & symname) -> std::string\n"
		"\n"
		"\n"
		"Get the function body, if inlined.\n"
		"\n"
		"\n"
		""},
	 { "Importer_library", _wrap_Importer_library, METH_O, "\n"
		"Importer_library(Importer self) -> std::string\n"
		"\n"
		"\n"
		"Get library name.\n"
		"\n"
		"\n"
		""},
	 { "Importer_serialize", _wrap_Importer_serialize, METH_VARARGS, "\n"
		"Importer_serialize(Importer self, casadi::SerializingStream & s)\n"
		"\n"
		"\n"
		"Serialize an object.\n"
		"\n"
		"\n"
		""},
	 { "Importer_deserialize", _wrap_Importer_deserialize, METH_O, "Importer_deserialize(casadi::DeserializingStream & s) -> Importer"},
	 { "new_Importer", _wrap_new_Importer, METH_VARARGS, "\n"
		"Importer()\n"
		"Importer(std::string const & name, std::string const & compiler, casadi::Dict const & opts=casadi::Dict())\n"
		"new_Importer(Importer other) -> Importer\n"
		"\n"
		"\n"
		"Importer factory.\n"
		"\n"
		"\n"
		""},
	 { "delete_Importer", _wrap_delete_Importer, METH_O, "delete_Importer(Importer self)"},
	 { "Importer_swigregister", Importer_swigregister, METH_O, NULL},
	 { "Importer_swiginit", Importer_swiginit, METH_VARARGS, NULL},
	 { "Callback_type_name", _wrap_Callback_type_name, METH_NOARGS, "Callback_type_name() -> std::string"},
	 { "new_Callback", _wrap_new_Callback, METH_VARARGS, "\n"
		"Callback()\n"
		"new_Callback(PyObject * _self, Callback obj) -> Callback\n"
		"\n"
		"\n"
		"Default constructor.\n"
		"\n"
		"\n"
		""},
	 { "delete_Callback", _wrap_delete_Callback, METH_O, "\n"
		"delete_Callback(Callback self)\n"
		"\n"
		"\n"
		"Destructor.\n"
		"\n"
		"\n"
		""},
	 { "Callback_construct", _wrap_Callback_construct, METH_VARARGS, "\n"
		"Callback_construct(Callback self, std::string const & name, casadi::Dict const & opts=casadi::Dict())\n"
		"\n"
		"\n"
		"Construct internal object This is the step that actually construct the\n"
		"internal object, as the class constructor only creates a null pointer. It\n"
		"should be called from the user constructor.\n"
		"\n"
		"\n"
		""},
	 { "Callback_init", _wrap_Callback_init, METH_O, "\n"
		"Callback_init(Callback self)\n"
		"\n"
		"\n"
		"Initialize the object This function is called after the object construction\n"
		"(for the whole class hierarchy) is complete, but before the finalization\n"
		"step. It is called recursively for the whole class hierarchy, starting with\n"
		"the lowest level.\n"
		"\n"
		"\n"
		""},
	 { "Callback_finalize", _wrap_Callback_finalize, METH_O, "\n"
		"Callback_finalize(Callback self)\n"
		"\n"
		"\n"
		"Finalize the object This function is called after the construction and init\n"
		"steps are completed, but before user functions are called. It is called\n"
		"recursively for the whole class hierarchy, starting with the highest level.\n"
		"\n"
		"\n"
		""},
	 { "Callback_eval", _wrap_Callback_eval, METH_VARARGS, "\n"
		"Callback_eval(Callback self, std::vector< casadi::DM,std::allocator< casadi::DM > > const & arg) -> std::vector< casadi::DM,std::allocator< casadi::DM > >\n"
		"\n"
		"\n"
		"Evaluate numerically, using temporary matrices and work vectors.\n"
		"\n"
		"This signature is not thread-safe. For guaranteed thread-safety, use\n"
		"eval_buffer\n"
		"\n"
		"\n"
		""},
	 { "Callback_eval_buffer", _wrap_Callback_eval_buffer, METH_VARARGS, "\n"
		"Callback_eval_buffer(Callback self, double const ** arg, std::vector< casadi_int,std::allocator< casadi_int > > const & sizes_arg, double ** res, std::vector< casadi_int,std::allocator< casadi_int > > const & sizes_res) -> int\n"
		"\n"
		"\n"
		"A copy-free low level interface.\n"
		"\n"
		"In Python, you will be passed two tuples of memoryview objects\n"
		"\n"
		"\n"
		""},
	 { "Callback_has_eval_buffer", _wrap_Callback_has_eval_buffer, METH_O, "Callback_has_eval_buffer(Callback self) -> bool"},
	 { "Callback_get_n_in", _wrap_Callback_get_n_in, METH_O, "\n"
		"Callback_get_n_in(Callback self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of inputs This function is called during construction.\n"
		"\n"
		"\n"
		""},
	 { "Callback_get_n_out", _wrap_Callback_get_n_out, METH_O, "\n"
		"Callback_get_n_out(Callback self) -> casadi_int\n"
		"\n"
		"\n"
		"Get the number of outputs This function is called during construction.\n"
		"\n"
		"\n"
		""},
	 { "Callback_get_sparsity_in", _wrap_Callback_get_sparsity_in, METH_VARARGS, "\n"
		"Callback_get_sparsity_in(Callback self, casadi_int i) -> Sparsity\n"
		"\n"
		"\n"
		"Get the sparsity of an input This function is called during construction.\n"
		"\n"
		"\n"
		""},
	 { "Callback_get_sparsity_out", _wrap_Callback_get_sparsity_out, METH_VARARGS, "\n"
		"Callback_get_sparsity_out(Callback self, casadi_int i) -> Sparsity\n"
		"\n"
		"\n"
		"Get the sparsity of an output This function is called during construction.\n"
		"\n"
		"\n"
		""},
	 { "Callback_get_name_in", _wrap_Callback_get_name_in, METH_VARARGS, "\n"
		"Callback_get_name_in(Callback self, casadi_int i) -> std::string\n"
		"\n"
		"\n"
		"Get the sparsity of an input This function is called during construction.\n"
		"\n"
		"\n"
		""},
	 { "Callback_get_name_out", _wrap_Callback_get_name_out, METH_VARARGS, "\n"
		"Callback_get_name_out(Callback self, casadi_int i) -> std::string\n"
		"\n"
		"\n"
		"Get the sparsity of an output This function is called during construction.\n"
		"\n"
		"\n"
		""},
	 { "Callback_uses_output", _wrap_Callback_uses_output, METH_O, "\n"
		"Callback_uses_output(Callback self) -> bool\n"
		"\n"
		"\n"
		"Do the derivative functions need nondifferentiated outputs?\n"
		"\n"
		"\n"
		""},
	 { "Callback_has_jacobian", _wrap_Callback_has_jacobian, METH_O, "\n"
		"Callback_has_jacobian(Callback self) -> bool\n"
		"\n"
		"\n"
		"Return Jacobian of all input elements with respect to all output elements.\n"
		"\n"
		"\n"
		""},
	 { "Callback_get_jacobian", _wrap_Callback_get_jacobian, METH_VARARGS, "\n"
		"Callback_get_jacobian(Callback self, std::string const & name, std::vector< std::string,std::allocator< std::string > > const & inames, std::vector< std::string,std::allocator< std::string > > const & onames, casadi::Dict const & opts) -> Function\n"
		"\n"
		"\n"
		"Return Jacobian of all input elements with respect to all output elements.\n"
		"\n"
		"\n"
		""},
	 { "Callback_has_forward", _wrap_Callback_has_forward, METH_VARARGS, "\n"
		"Callback_has_forward(Callback self, casadi_int nfwd) -> bool\n"
		"\n"
		"\n"
		"Return function that calculates forward derivatives forward(nfwd) returns a\n"
		"cached instance if available, and calls  Function get_forward(casadi_int\n"
		"nfwd) if no cached version is available.\n"
		"\n"
		"\n"
		""},
	 { "Callback_get_forward", _wrap_Callback_get_forward, METH_VARARGS, "\n"
		"Callback_get_forward(Callback self, casadi_int nfwd, std::string const & name, std::vector< std::string,std::allocator< std::string > > const & inames, std::vector< std::string,std::allocator< std::string > > const & onames, casadi::Dict const & opts) -> Function\n"
		"\n"
		"\n"
		"Return function that calculates forward derivatives forward(nfwd) returns a\n"
		"cached instance if available, and calls  Function get_forward(casadi_int\n"
		"nfwd) if no cached version is available.\n"
		"\n"
		"\n"
		""},
	 { "Callback_has_reverse", _wrap_Callback_has_reverse, METH_VARARGS, "\n"
		"Callback_has_reverse(Callback self, casadi_int nadj) -> bool\n"
		"\n"
		"\n"
		"Return function that calculates adjoint derivatives reverse(nadj) returns a\n"
		"cached instance if available, and calls  Function get_reverse(casadi_int\n"
		"nadj) if no cached version is available.\n"
		"\n"
		"\n"
		""},
	 { "Callback_get_reverse", _wrap_Callback_get_reverse, METH_VARARGS, "\n"
		"Callback_get_reverse(Callback self, casadi_int nadj, std::string const & name, std::vector< std::string,std::allocator< std::string > > const & inames, std::vector< std::string,std::allocator< std::string > > const & onames, casadi::Dict const & opts) -> Function\n"
		"\n"
		"\n"
		"Return function that calculates adjoint derivatives reverse(nadj) returns a\n"
		"cached instance if available, and calls  Function get_reverse(casadi_int\n"
		"nadj) if no cached version is available.\n"
		"\n"
		"\n"
		""},
	 { "Callback_has_jacobian_sparsity", _wrap_Callback_has_jacobian_sparsity, METH_O, "\n"
		"Callback_has_jacobian_sparsity(Callback self) -> bool\n"
		"\n"
		"\n"
		"Return sparsity of Jacobian of all input elements with respect to all output\n"
		"elements.\n"
		"\n"
		"\n"
		""},
	 { "Callback_get_jacobian_sparsity", _wrap_Callback_get_jacobian_sparsity, METH_O, "\n"
		"Callback_get_jacobian_sparsity(Callback self) -> Sparsity\n"
		"\n"
		"\n"
		"Return sparsity of Jacobian of all input elements with respect to all output\n"
		"elements.\n"
		"\n"
		"\n"
		""},
	 { "disown_Callback", _wrap_disown_Callback, METH_O, NULL},
	 { "Callback_swigregister", Callback_swigregister, METH_O, NULL},
	 { "Callback_swiginit", Callback_swiginit, METH_VARARGS, NULL},
	 { "GlobalOptions_setSimplificationOnTheFly", _wrap_GlobalOptions_setSimplificationOnTheFly, METH_O, "GlobalOptions_setSimplificationOnTheFly(bool flag)"},
	 { "GlobalOptions_getSimplificationOnTheFly", _wrap_GlobalOptions_getSimplificationOnTheFly, METH_NOARGS, "GlobalOptions_getSimplificationOnTheFly() -> bool"},
	 { "GlobalOptions_setHierarchicalSparsity", _wrap_GlobalOptions_setHierarchicalSparsity, METH_O, "GlobalOptions_setHierarchicalSparsity(bool flag)"},
	 { "GlobalOptions_getHierarchicalSparsity", _wrap_GlobalOptions_getHierarchicalSparsity, METH_NOARGS, "GlobalOptions_getHierarchicalSparsity() -> bool"},
	 { "GlobalOptions_setCasadiPath", _wrap_GlobalOptions_setCasadiPath, METH_O, "GlobalOptions_setCasadiPath(std::string const & path)"},
	 { "GlobalOptions_getCasadiPath", _wrap_GlobalOptions_getCasadiPath, METH_NOARGS, "GlobalOptions_getCasadiPath() -> std::string"},
	 { "GlobalOptions_setCasadiIncludePath", _wrap_GlobalOptions_setCasadiIncludePath, METH_O, "GlobalOptions_setCasadiIncludePath(std::string const & path)"},
	 { "GlobalOptions_getCasadiIncludePath", _wrap_GlobalOptions_getCasadiIncludePath, METH_NOARGS, "GlobalOptions_getCasadiIncludePath() -> std::string"},
	 { "GlobalOptions_setMaxNumDir", _wrap_GlobalOptions_setMaxNumDir, METH_O, "GlobalOptions_setMaxNumDir(casadi_int ndir)"},
	 { "GlobalOptions_getMaxNumDir", _wrap_GlobalOptions_getMaxNumDir, METH_NOARGS, "GlobalOptions_getMaxNumDir() -> casadi_int"},
	 { "new_GlobalOptions", _wrap_new_GlobalOptions, METH_O, "new_GlobalOptions(GlobalOptions other) -> GlobalOptions"},
	 { "delete_GlobalOptions", _wrap_delete_GlobalOptions, METH_O, "delete_GlobalOptions(GlobalOptions self)"},
	 { "GlobalOptions_swigregister", GlobalOptions_swigregister, METH_O, NULL},
	 { "GlobalOptions_swiginit", GlobalOptions_swiginit, METH_VARARGS, NULL},
	 { "CasadiMeta_version", _wrap_CasadiMeta_version, METH_NOARGS, "CasadiMeta_version() -> char const *"},
	 { "CasadiMeta_git_revision", _wrap_CasadiMeta_git_revision, METH_NOARGS, "CasadiMeta_git_revision() -> char const *"},
	 { "CasadiMeta_git_describe", _wrap_CasadiMeta_git_describe, METH_NOARGS, "CasadiMeta_git_describe() -> char const *"},
	 { "CasadiMeta_feature_list", _wrap_CasadiMeta_feature_list, METH_NOARGS, "CasadiMeta_feature_list() -> char const *"},
	 { "CasadiMeta_build_type", _wrap_CasadiMeta_build_type, METH_NOARGS, "CasadiMeta_build_type() -> char const *"},
	 { "CasadiMeta_compiler_id", _wrap_CasadiMeta_compiler_id, METH_NOARGS, "CasadiMeta_compiler_id() -> char const *"},
	 { "CasadiMeta_compiler", _wrap_CasadiMeta_compiler, METH_NOARGS, "CasadiMeta_compiler() -> char const *"},
	 { "CasadiMeta_compiler_flags", _wrap_CasadiMeta_compiler_flags, METH_NOARGS, "CasadiMeta_compiler_flags() -> char const *"},
	 { "CasadiMeta_modules", _wrap_CasadiMeta_modules, METH_NOARGS, "CasadiMeta_modules() -> char const *"},
	 { "CasadiMeta_plugins", _wrap_CasadiMeta_plugins, METH_NOARGS, "CasadiMeta_plugins() -> char const *"},
	 { "CasadiMeta_install_prefix", _wrap_CasadiMeta_install_prefix, METH_NOARGS, "CasadiMeta_install_prefix() -> char const *"},
	 { "new_CasadiMeta", _wrap_new_CasadiMeta, METH_O, "new_CasadiMeta(CasadiMeta other) -> CasadiMeta"},
	 { "delete_CasadiMeta", _wrap_delete_CasadiMeta, METH_O, "delete_CasadiMeta(CasadiMeta self)"},
	 { "CasadiMeta_swigregister", CasadiMeta_swigregister, METH_O, NULL},
	 { "CasadiMeta_swiginit", CasadiMeta_swiginit, METH_VARARGS, NULL},
	 { "collocation_points", _wrap_collocation_points, METH_VARARGS, "\n"
		"collocation_points(casadi_int order, std::string const & scheme=\"radau\") -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Obtain collocation points of specific order and scheme.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"order:  Which order (1 to 9 supported)\n"
		"\n"
		"scheme:  'radau' or 'legendre'\n"
		"\n"
		"\n"
		""},
	 { "collocation_interpolators", _wrap_collocation_interpolators, METH_O, "\n"
		"collocation_interpolators(std::vector< double,std::allocator< double > > const & tau)\n"
		"\n"
		"\n"
		"Obtain collocation interpolating matrices.\n"
		"\n"
		"A collocation method poses a polynomial Pi that interpolates exactly through\n"
		"an initial state (0,X_0) and helper states at collocation points\n"
		"(tau_j,X(j)).\n"
		"\n"
		"This function computes the linear mapping between dPi/dt and coefficients\n"
		"Z=[X_0 X].\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"tau:  location of collocation points, as obtained from collocation_points\n"
		"\n"
		"output_C:  interpolating coefficients to obtain derivatives. Length:\n"
		"order+1, order+1\n"
		"\n"
		"\n"
		"\n"
		"::\n"
		"\n"
		"dPi/dt @Z_j = (1/h) Sum_i C[j][i]*Z_i,\n"
		"\n"
		"\n"
		"\n"
		"with h the length of the integration interval.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"output_D:  interpolating coefficients to obtain end state. Length: order+1\n"
		"\n"
		"\n"
		"\n"
		"::\n"
		"\n"
		"Pi @X_f = Sum_i D[i]*Z_i\n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "collocation_coeff", _wrap_collocation_coeff, METH_O, "\n"
		"collocation_coeff(std::vector< double,std::allocator< double > > const & tau)\n"
		"\n"
		"\n"
		"Obtain collocation interpolating matrices.\n"
		"\n"
		"A collocation method poses a polynomial Pi that interpolates exactly through\n"
		"an initial state (0,X_0) and helper states at collocation points\n"
		"(tau_j,Xc_j) with j=1..degree.\n"
		"\n"
		"This function computes the linear mapping between dPi/dt and coefficients\n"
		"Z=[X_0 Xc].\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"tau:  location of collocation points (length: degree), as obtained from\n"
		"collocation_points\n"
		"\n"
		"C:  interpolating coefficients to obtain derivatives. Size: (degree+1)-by-\n"
		"degree\n"
		"\n"
		"You may find the slopes of Pi at the collocation points as\n"
		"\n"
		"::\n"
		"\n"
		"dPi/dt @ Xc = (1/h) Z*C,\n"
		"\n"
		"\n"
		"\n"
		"with h the length of the integration interval.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"D:  interpolating coefficients to obtain end state. Size: (degree+1)-by-1\n"
		"\n"
		"You may find the end point of Pi as\n"
		"\n"
		"::\n"
		"\n"
		"Pi @X_f = Z*D\n"
		"\n"
		"\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"B:  quadrature coefficients Size: degree-by-1\n"
		"\n"
		"Given quadrature righ-hand-sides 'quad' evaluated at the collocation points,\n"
		"you may find the integrated quadratures as\n"
		"\n"
		"::\n"
		"\n"
		"q = quad*B*h\n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "simpleRK", _wrap_simpleRK, METH_VARARGS, "\n"
		"simpleRK(Function f, casadi_int N=10, casadi_int order=4) -> Function\n"
		"\n"
		"\n"
		"Construct an explicit Runge-Kutta integrator The constructed function has\n"
		"three inputs, corresponding to initial state (x0), parameter (p) and\n"
		"integration time (h) and one output, corresponding to final state (xf).\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"f:  ODE function with two inputs (x and p) and one output (xdot)\n"
		"\n"
		"N:  Number of integrator steps\n"
		"\n"
		"order:  Order of interpolating polynomials\n"
		"\n"
		"\n"
		""},
	 { "simpleIRK", _wrap_simpleIRK, METH_VARARGS, "\n"
		"simpleIRK(Function f, casadi_int N=10, casadi_int order=4, std::string const & scheme=\"radau\", std::string const & solver=\"newton\", casadi::Dict const & solver_options=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Construct an implicit Runge-Kutta integrator using a collocation scheme The\n"
		"constructed function has three inputs, corresponding to initial state (x0),\n"
		"parameter (p) and integration time (h) and one output, corresponding to\n"
		"final state (xf).\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"f:  ODE function with two inputs (x and p) and one output (xdot)\n"
		"\n"
		"N:  Number of integrator steps\n"
		"\n"
		"order:  Order of interpolating polynomials\n"
		"\n"
		"scheme:   Collocation scheme, as excepted by collocationPoints function.\n"
		"\n"
		"solver:  Solver plugin\n"
		"\n"
		"solver_options:  Options to be passed to the solver plugin\n"
		"\n"
		"\n"
		""},
	 { "simpleIntegrator", _wrap_simpleIntegrator, METH_VARARGS, "\n"
		"simpleIntegrator(Function f, std::string const & integrator=\"cvodes\", casadi::Dict const & integrator_options=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Simplified wrapper for the Integrator class Constructs an integrator using\n"
		"the same syntax as simpleRK and simpleIRK. The constructed function has\n"
		"three inputs, corresponding to initial state (x0), parameter (p) and\n"
		"integration time (h) and one output, corresponding to final state (xf).\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"f:  ODE function with two inputs (x and p) and one output (xdot)\n"
		"\n"
		"N:  Number of integrator steps\n"
		"\n"
		"order:  Order of interpolating polynomials\n"
		"\n"
		"scheme:   Collocation scheme, as excepted by collocationPoints function.\n"
		"\n"
		"\n"
		""},
	 { "detect_simple_bounds", _wrap_detect_simple_bounds, METH_VARARGS, "\n"
		"detect_simple_bounds(SX xX, SX p, SX g, SX lbg, SX ubg)\n"
		"detect_simple_bounds(MX xX, MX p, MX g, MX lbg, MX ubg)\n"
		"\n"
		"\n"
		"Detect simple bounds from general constraints.\n"
		"\n"
		"Given parametric constraints:\n"
		"\n"
		"::\n"
		"\n"
		"  *   subject to lbg(p) <= g(x,p) <= ubg(p)\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"Returns an equivalent set\n"
		"\n"
		"::\n"
		"\n"
		"  *   subject to  lbg(p)(gi) <= g(x,p)(gi) <= ubg(p)(gi)\n"
		"  *               lbx(p) <= x                 <= ubx(p)\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"lam_forward:  (lam_g,p)->(lam_sg,lam_x)\n"
		"\n"
		"lam_backward:  (lam_sg,lam_x,p)->(lam_g)\n"
		"\n"
		"\n"
		""},
	 { "NlpBuilder_x_get", _wrap_NlpBuilder_x_get, METH_O, "NlpBuilder_x_get(NlpBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "NlpBuilder_f_get", _wrap_NlpBuilder_f_get, METH_O, "NlpBuilder_f_get(NlpBuilder self) -> MX"},
	 { "NlpBuilder_g_get", _wrap_NlpBuilder_g_get, METH_O, "NlpBuilder_g_get(NlpBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "NlpBuilder_x_lb_get", _wrap_NlpBuilder_x_lb_get, METH_O, "NlpBuilder_x_lb_get(NlpBuilder self) -> std::vector< double,std::allocator< double > > const &"},
	 { "NlpBuilder_x_ub_get", _wrap_NlpBuilder_x_ub_get, METH_O, "NlpBuilder_x_ub_get(NlpBuilder self) -> std::vector< double,std::allocator< double > > const &"},
	 { "NlpBuilder_g_lb_get", _wrap_NlpBuilder_g_lb_get, METH_O, "NlpBuilder_g_lb_get(NlpBuilder self) -> std::vector< double,std::allocator< double > > const &"},
	 { "NlpBuilder_g_ub_get", _wrap_NlpBuilder_g_ub_get, METH_O, "NlpBuilder_g_ub_get(NlpBuilder self) -> std::vector< double,std::allocator< double > > const &"},
	 { "NlpBuilder_x_init_get", _wrap_NlpBuilder_x_init_get, METH_O, "NlpBuilder_x_init_get(NlpBuilder self) -> std::vector< double,std::allocator< double > > const &"},
	 { "NlpBuilder_lambda_init_get", _wrap_NlpBuilder_lambda_init_get, METH_O, "NlpBuilder_lambda_init_get(NlpBuilder self) -> std::vector< double,std::allocator< double > > const &"},
	 { "NlpBuilder_discrete_get", _wrap_NlpBuilder_discrete_get, METH_O, "NlpBuilder_discrete_get(NlpBuilder self) -> std::vector< bool,std::allocator< bool > > const &"},
	 { "NlpBuilder_import_nl", _wrap_NlpBuilder_import_nl, METH_VARARGS, "\n"
		"NlpBuilder_import_nl(NlpBuilder self, std::string const & filename, casadi::Dict const & opts=casadi::Dict())\n"
		"\n"
		"\n"
		"Import an .nl file.\n"
		"\n"
		"\n"
		""},
	 { "NlpBuilder_type_name", _wrap_NlpBuilder_type_name, METH_O, "\n"
		"NlpBuilder_type_name(NlpBuilder self) -> std::string\n"
		"\n"
		"\n"
		"Readable name of the class.\n"
		"\n"
		"\n"
		""},
	 { "NlpBuilder_disp", _wrap_NlpBuilder_disp, METH_VARARGS, "\n"
		"NlpBuilder_disp(NlpBuilder self, bool more=False)\n"
		"\n"
		"\n"
		"Print a description of the object.\n"
		"\n"
		"\n"
		""},
	 { "NlpBuilder_str", _wrap_NlpBuilder_str, METH_VARARGS, "\n"
		"NlpBuilder_str(NlpBuilder self, bool more=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation.\n"
		"\n"
		"\n"
		""},
	 { "new_NlpBuilder", _wrap_new_NlpBuilder, METH_VARARGS, "\n"
		"NlpBuilder()\n"
		"new_NlpBuilder(NlpBuilder other) -> NlpBuilder\n"
		""},
	 { "delete_NlpBuilder", _wrap_delete_NlpBuilder, METH_O, "delete_NlpBuilder(NlpBuilder self)"},
	 { "NlpBuilder_swigregister", NlpBuilder_swigregister, METH_O, NULL},
	 { "NlpBuilder_swiginit", NlpBuilder_swiginit, METH_VARARGS, NULL},
	 { "Variable_name", _wrap_Variable_name, METH_O, "Variable_name(Variable self) -> std::string"},
	 { "Variable_v_get", _wrap_Variable_v_get, METH_O, "Variable_v_get(Variable self) -> MX"},
	 { "Variable_d_get", _wrap_Variable_d_get, METH_O, "Variable_d_get(Variable self) -> MX"},
	 { "Variable_nominal_get", _wrap_Variable_nominal_get, METH_O, "Variable_nominal_get(Variable self) -> double"},
	 { "Variable_start_get", _wrap_Variable_start_get, METH_O, "Variable_start_get(Variable self) -> double"},
	 { "Variable_min_get", _wrap_Variable_min_get, METH_O, "Variable_min_get(Variable self) -> double"},
	 { "Variable_max_get", _wrap_Variable_max_get, METH_O, "Variable_max_get(Variable self) -> double"},
	 { "Variable_guess_get", _wrap_Variable_guess_get, METH_O, "Variable_guess_get(Variable self) -> double"},
	 { "Variable_derivative_start_get", _wrap_Variable_derivative_start_get, METH_O, "Variable_derivative_start_get(Variable self) -> double"},
	 { "Variable_variability_get", _wrap_Variable_variability_get, METH_O, "Variable_variability_get(Variable self) -> casadi::Variability"},
	 { "Variable_causality_get", _wrap_Variable_causality_get, METH_O, "Variable_causality_get(Variable self) -> casadi::Causality"},
	 { "Variable_category_get", _wrap_Variable_category_get, METH_O, "Variable_category_get(Variable self) -> casadi::Category"},
	 { "Variable_alias_get", _wrap_Variable_alias_get, METH_O, "Variable_alias_get(Variable self) -> casadi::Alias"},
	 { "Variable_description_get", _wrap_Variable_description_get, METH_O, "Variable_description_get(Variable self) -> std::string const &"},
	 { "Variable_valueReference_get", _wrap_Variable_valueReference_get, METH_O, "Variable_valueReference_get(Variable self) -> casadi_int"},
	 { "Variable_unit_get", _wrap_Variable_unit_get, METH_O, "Variable_unit_get(Variable self) -> std::string const &"},
	 { "Variable_display_unit_get", _wrap_Variable_display_unit_get, METH_O, "Variable_display_unit_get(Variable self) -> std::string const &"},
	 { "Variable_free_get", _wrap_Variable_free_get, METH_O, "Variable_free_get(Variable self) -> bool"},
	 { "Variable_type_name", _wrap_Variable_type_name, METH_O, "Variable_type_name(Variable self) -> std::string"},
	 { "Variable_disp", _wrap_Variable_disp, METH_VARARGS, "Variable_disp(Variable self, bool more=False)"},
	 { "Variable_str", _wrap_Variable_str, METH_VARARGS, "Variable_str(Variable self, bool more=False) -> std::string"},
	 { "new_Variable", _wrap_new_Variable, METH_VARARGS, "\n"
		"Variable()\n"
		"Variable(std::string const & name, Sparsity sp=casadi::Sparsity::scalar())\n"
		"new_Variable(Variable other) -> Variable\n"
		""},
	 { "delete_Variable", _wrap_delete_Variable, METH_O, "delete_Variable(Variable self)"},
	 { "Variable_swigregister", Variable_swigregister, METH_O, NULL},
	 { "Variable_swiginit", Variable_swiginit, METH_VARARGS, NULL},
	 { "DaeBuilder_t_get", _wrap_DaeBuilder_t_get, METH_O, "DaeBuilder_t_get(DaeBuilder self) -> MX"},
	 { "DaeBuilder_x_get", _wrap_DaeBuilder_x_get, METH_O, "DaeBuilder_x_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_ode_get", _wrap_DaeBuilder_ode_get, METH_O, "DaeBuilder_ode_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_lam_ode_get", _wrap_DaeBuilder_lam_ode_get, METH_O, "DaeBuilder_lam_ode_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_s_get", _wrap_DaeBuilder_s_get, METH_O, "DaeBuilder_s_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_sdot_get", _wrap_DaeBuilder_sdot_get, METH_O, "DaeBuilder_sdot_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_dae_get", _wrap_DaeBuilder_dae_get, METH_O, "DaeBuilder_dae_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_lam_dae_get", _wrap_DaeBuilder_lam_dae_get, METH_O, "DaeBuilder_lam_dae_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_z_get", _wrap_DaeBuilder_z_get, METH_O, "DaeBuilder_z_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_alg_get", _wrap_DaeBuilder_alg_get, METH_O, "DaeBuilder_alg_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_lam_alg_get", _wrap_DaeBuilder_lam_alg_get, METH_O, "DaeBuilder_lam_alg_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_q_get", _wrap_DaeBuilder_q_get, METH_O, "DaeBuilder_q_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_quad_get", _wrap_DaeBuilder_quad_get, METH_O, "DaeBuilder_quad_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_lam_quad_get", _wrap_DaeBuilder_lam_quad_get, METH_O, "DaeBuilder_lam_quad_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_w_get", _wrap_DaeBuilder_w_get, METH_O, "DaeBuilder_w_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_wdef_get", _wrap_DaeBuilder_wdef_get, METH_O, "DaeBuilder_wdef_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_lam_wdef_get", _wrap_DaeBuilder_lam_wdef_get, METH_O, "DaeBuilder_lam_wdef_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_y_get", _wrap_DaeBuilder_y_get, METH_O, "DaeBuilder_y_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_ydef_get", _wrap_DaeBuilder_ydef_get, METH_O, "DaeBuilder_ydef_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_lam_ydef_get", _wrap_DaeBuilder_lam_ydef_get, METH_O, "DaeBuilder_lam_ydef_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_u_get", _wrap_DaeBuilder_u_get, METH_O, "DaeBuilder_u_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_p_get", _wrap_DaeBuilder_p_get, METH_O, "DaeBuilder_p_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_c_get", _wrap_DaeBuilder_c_get, METH_O, "DaeBuilder_c_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_cdef_get", _wrap_DaeBuilder_cdef_get, METH_O, "DaeBuilder_cdef_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_d_get", _wrap_DaeBuilder_d_get, METH_O, "DaeBuilder_d_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_ddef_get", _wrap_DaeBuilder_ddef_get, METH_O, "DaeBuilder_ddef_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_lam_ddef_get", _wrap_DaeBuilder_lam_ddef_get, METH_O, "DaeBuilder_lam_ddef_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_aux_get", _wrap_DaeBuilder_aux_get, METH_O, "DaeBuilder_aux_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_init_get", _wrap_DaeBuilder_init_get, METH_O, "DaeBuilder_init_get(DaeBuilder self) -> std::vector< casadi::MX,std::allocator< casadi::MX > > const &"},
	 { "DaeBuilder_add_p", _wrap_DaeBuilder_add_p, METH_VARARGS, "\n"
		"DaeBuilder_add_p(DaeBuilder self, std::string const & name=std::string(), casadi_int n=1) -> MX\n"
		"\n"
		"\n"
		"Add a new parameter\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_u", _wrap_DaeBuilder_add_u, METH_VARARGS, "\n"
		"DaeBuilder_add_u(DaeBuilder self, std::string const & name=std::string(), casadi_int n=1) -> MX\n"
		"\n"
		"\n"
		"Add a new control.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_x", _wrap_DaeBuilder_add_x, METH_VARARGS, "\n"
		"DaeBuilder_add_x(DaeBuilder self, std::string const & name=std::string(), casadi_int n=1) -> MX\n"
		"\n"
		"\n"
		"Add a new differential state.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_s", _wrap_DaeBuilder_add_s, METH_VARARGS, "\n"
		"DaeBuilder_add_s(DaeBuilder self, std::string const & name=std::string(), casadi_int n=1) -> std::pair< casadi::MX,casadi::MX >\n"
		"\n"
		"\n"
		"Add a implicit state.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_z", _wrap_DaeBuilder_add_z, METH_VARARGS, "\n"
		"DaeBuilder_add_z(DaeBuilder self, std::string const & name=std::string(), casadi_int n=1) -> MX\n"
		"\n"
		"\n"
		"Add a new algebraic variable.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_q", _wrap_DaeBuilder_add_q, METH_VARARGS, "\n"
		"DaeBuilder_add_q(DaeBuilder self, std::string const & name=std::string(), casadi_int n=1) -> MX\n"
		"\n"
		"\n"
		"Add a new quadrature state.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_d", _wrap_DaeBuilder_add_d, METH_VARARGS, "\n"
		"DaeBuilder_add_d(DaeBuilder self, std::string const & name, MX new_ddef) -> MX\n"
		"\n"
		"\n"
		"Add a new dependent parameter.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_y", _wrap_DaeBuilder_add_y, METH_VARARGS, "\n"
		"DaeBuilder_add_y(DaeBuilder self, std::string const & name, MX new_ydef) -> MX\n"
		"\n"
		"\n"
		"Add a new output.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_ode", _wrap_DaeBuilder_add_ode, METH_VARARGS, "\n"
		"DaeBuilder_add_ode(DaeBuilder self, std::string const & name, MX new_ode)\n"
		"\n"
		"\n"
		"Add an ordinary differential equation.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_dae", _wrap_DaeBuilder_add_dae, METH_VARARGS, "\n"
		"DaeBuilder_add_dae(DaeBuilder self, std::string const & name, MX new_dae)\n"
		"\n"
		"\n"
		"Add a differential-algebraic equation.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_alg", _wrap_DaeBuilder_add_alg, METH_VARARGS, "\n"
		"DaeBuilder_add_alg(DaeBuilder self, std::string const & name, MX new_alg)\n"
		"\n"
		"\n"
		"Add an algebraic equation.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_quad", _wrap_DaeBuilder_add_quad, METH_VARARGS, "\n"
		"DaeBuilder_add_quad(DaeBuilder self, std::string const & name, MX new_quad)\n"
		"\n"
		"\n"
		"Add a quadrature equation.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_aux", _wrap_DaeBuilder_add_aux, METH_VARARGS, "\n"
		"DaeBuilder_add_aux(DaeBuilder self, std::string const & name=std::string(), casadi_int n=1) -> MX\n"
		"\n"
		"\n"
		"Add an auxiliary variable.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_sanity_check", _wrap_DaeBuilder_sanity_check, METH_O, "\n"
		"DaeBuilder_sanity_check(DaeBuilder self)\n"
		"\n"
		"\n"
		"Check if dimensions match.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_split_dae", _wrap_DaeBuilder_split_dae, METH_O, "\n"
		"DaeBuilder_split_dae(DaeBuilder self)\n"
		"\n"
		"\n"
		"Identify and separate the algebraic variables and equations in the DAE.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_eliminate_alg", _wrap_DaeBuilder_eliminate_alg, METH_O, "\n"
		"DaeBuilder_eliminate_alg(DaeBuilder self)\n"
		"\n"
		"\n"
		"Eliminate algebraic variables and equations transforming them into outputs.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_make_semi_explicit", _wrap_DaeBuilder_make_semi_explicit, METH_O, "\n"
		"DaeBuilder_make_semi_explicit(DaeBuilder self)\n"
		"\n"
		"\n"
		"Transform the implicit DAE to a semi-explicit DAE.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_make_explicit", _wrap_DaeBuilder_make_explicit, METH_O, "\n"
		"DaeBuilder_make_explicit(DaeBuilder self)\n"
		"\n"
		"\n"
		"Transform the implicit DAE or semi-explicit DAE into an explicit ODE.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_sort_d", _wrap_DaeBuilder_sort_d, METH_O, "\n"
		"DaeBuilder_sort_d(DaeBuilder self)\n"
		"\n"
		"\n"
		"Sort dependent parameters.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_split_d", _wrap_DaeBuilder_split_d, METH_O, "\n"
		"DaeBuilder_split_d(DaeBuilder self)\n"
		"\n"
		"\n"
		"Eliminate interdependencies amongst dependent parameters.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_eliminate_d", _wrap_DaeBuilder_eliminate_d, METH_O, "\n"
		"DaeBuilder_eliminate_d(DaeBuilder self)\n"
		"\n"
		"\n"
		"Eliminate dependent parameters.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_eliminate_quad", _wrap_DaeBuilder_eliminate_quad, METH_O, "\n"
		"DaeBuilder_eliminate_quad(DaeBuilder self)\n"
		"\n"
		"\n"
		"Eliminate quadrature states and turn them into ODE states.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_sort_dae", _wrap_DaeBuilder_sort_dae, METH_O, "\n"
		"DaeBuilder_sort_dae(DaeBuilder self)\n"
		"\n"
		"\n"
		"Sort the DAE and implicitly defined states.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_sort_alg", _wrap_DaeBuilder_sort_alg, METH_O, "\n"
		"DaeBuilder_sort_alg(DaeBuilder self)\n"
		"\n"
		"\n"
		"Sort the algebraic equations and algebraic states.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_scale_variables", _wrap_DaeBuilder_scale_variables, METH_O, "\n"
		"DaeBuilder_scale_variables(DaeBuilder self)\n"
		"\n"
		"\n"
		"Scale the variables.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_scale_equations", _wrap_DaeBuilder_scale_equations, METH_O, "\n"
		"DaeBuilder_scale_equations(DaeBuilder self)\n"
		"\n"
		"\n"
		"Scale the implicit equations.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_fun", _wrap_DaeBuilder_add_fun, METH_VARARGS, "\n"
		"DaeBuilder_add_fun(DaeBuilder self, std::string const & name, std::vector< std::string,std::allocator< std::string > > const & arg, std::vector< std::string,std::allocator< std::string > > const & res, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"DaeBuilder_add_fun(DaeBuilder self, Function f) -> Function\n"
		"DaeBuilder_add_fun(DaeBuilder self, std::string const & name, Importer compiler, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"\n"
		"\n"
		"Add an already existing function.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_has_fun", _wrap_DaeBuilder_has_fun, METH_VARARGS, "\n"
		"DaeBuilder_has_fun(DaeBuilder self, std::string const & name) -> bool\n"
		"\n"
		"\n"
		"Does a particular function already exist?\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_fun", _wrap_DaeBuilder_fun, METH_VARARGS, "\n"
		"DaeBuilder_fun(DaeBuilder self, std::string const & name) -> Function\n"
		"\n"
		"\n"
		"Get function by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_parse_fmi", _wrap_DaeBuilder_parse_fmi, METH_VARARGS, "\n"
		"DaeBuilder_parse_fmi(DaeBuilder self, std::string const & filename)\n"
		"\n"
		"\n"
		"Import existing problem from FMI/XML\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_lc", _wrap_DaeBuilder_add_lc, METH_VARARGS, "\n"
		"DaeBuilder_add_lc(DaeBuilder self, std::string const & name, std::vector< std::string,std::allocator< std::string > > const & f_out) -> MX\n"
		"\n"
		"\n"
		"Add a named linear combination of output expressions.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_create", _wrap_DaeBuilder_create, METH_VARARGS, "\n"
		"DaeBuilder_create(DaeBuilder self, std::string const & fname, std::vector< std::string,std::allocator< std::string > > const & s_in, std::vector< std::string,std::allocator< std::string > > const & s_out) -> Function\n"
		"\n"
		"\n"
		"Construct a function object.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_var", _wrap_DaeBuilder_var, METH_VARARGS, "\n"
		"DaeBuilder_var(DaeBuilder self, std::string const & name) -> MX\n"
		"\n"
		"\n"
		"Get variable expression by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder___call__", _wrap_DaeBuilder___call__, METH_VARARGS, "DaeBuilder___call__(DaeBuilder self, std::string const & name) -> MX"},
	 { "DaeBuilder_der", _wrap_DaeBuilder_der, METH_VARARGS, "\n"
		"DaeBuilder_der(DaeBuilder self, std::string const & name) -> MX\n"
		"DaeBuilder_der(DaeBuilder self, MX var) -> MX\n"
		"\n"
		"\n"
		"Get a derivative expression by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_nominal", _wrap_DaeBuilder_nominal, METH_VARARGS, "\n"
		"DaeBuilder_nominal(DaeBuilder self, std::string const & name) -> double\n"
		"DaeBuilder_nominal(DaeBuilder self, MX var) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Get the nominal value by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_set_nominal", _wrap_DaeBuilder_set_nominal, METH_VARARGS, "\n"
		"DaeBuilder_set_nominal(DaeBuilder self, std::string const & name, double val)\n"
		"DaeBuilder_set_nominal(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val)\n"
		"\n"
		"\n"
		"Set the nominal value by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_min", _wrap_DaeBuilder_min, METH_VARARGS, "\n"
		"DaeBuilder_min(DaeBuilder self, std::string const & name, bool normalized=False) -> double\n"
		"DaeBuilder_min(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Get the lower bound by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_set_min", _wrap_DaeBuilder_set_min, METH_VARARGS, "\n"
		"DaeBuilder_set_min(DaeBuilder self, std::string const & name, double val, bool normalized=False)\n"
		"DaeBuilder_set_min(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)\n"
		"\n"
		"\n"
		"Set the lower bound by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_max", _wrap_DaeBuilder_max, METH_VARARGS, "\n"
		"DaeBuilder_max(DaeBuilder self, std::string const & name, bool normalized=False) -> double\n"
		"DaeBuilder_max(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Get the upper bound by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_set_max", _wrap_DaeBuilder_set_max, METH_VARARGS, "\n"
		"DaeBuilder_set_max(DaeBuilder self, std::string const & name, double val, bool normalized=False)\n"
		"DaeBuilder_set_max(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)\n"
		"\n"
		"\n"
		"Set the upper bound by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_guess", _wrap_DaeBuilder_guess, METH_VARARGS, "\n"
		"DaeBuilder_guess(DaeBuilder self, std::string const & name, bool normalized=False) -> double\n"
		"DaeBuilder_guess(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Get the initial guess by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_set_guess", _wrap_DaeBuilder_set_guess, METH_VARARGS, "\n"
		"DaeBuilder_set_guess(DaeBuilder self, std::string const & name, double val, bool normalized=False)\n"
		"DaeBuilder_set_guess(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)\n"
		"\n"
		"\n"
		"Set the initial guess by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_start", _wrap_DaeBuilder_start, METH_VARARGS, "\n"
		"DaeBuilder_start(DaeBuilder self, std::string const & name, bool normalized=False) -> double\n"
		"DaeBuilder_start(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Get the (optionally normalized) value at time 0 by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_set_start", _wrap_DaeBuilder_set_start, METH_VARARGS, "\n"
		"DaeBuilder_set_start(DaeBuilder self, std::string const & name, double val, bool normalized=False)\n"
		"DaeBuilder_set_start(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)\n"
		"\n"
		"\n"
		"Set the (optionally normalized) value at time 0 by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_derivative_start", _wrap_DaeBuilder_derivative_start, METH_VARARGS, "\n"
		"DaeBuilder_derivative_start(DaeBuilder self, std::string const & name, bool normalized=False) -> double\n"
		"DaeBuilder_derivative_start(DaeBuilder self, MX var, bool normalized=False) -> std::vector< double,std::allocator< double > >\n"
		"\n"
		"\n"
		"Get the (optionally normalized) derivative value at time 0 by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_set_derivative_start", _wrap_DaeBuilder_set_derivative_start, METH_VARARGS, "\n"
		"DaeBuilder_set_derivative_start(DaeBuilder self, std::string const & name, double val, bool normalized=False)\n"
		"DaeBuilder_set_derivative_start(DaeBuilder self, MX var, std::vector< double,std::allocator< double > > const & val, bool normalized=False)\n"
		"\n"
		"\n"
		"Set the (optionally normalized) derivative value at time 0 by name.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_unit", _wrap_DaeBuilder_unit, METH_VARARGS, "\n"
		"DaeBuilder_unit(DaeBuilder self, std::string const & name) -> std::string\n"
		"DaeBuilder_unit(DaeBuilder self, MX var) -> std::string\n"
		"\n"
		"\n"
		"Get the unit for a component.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_set_unit", _wrap_DaeBuilder_set_unit, METH_VARARGS, "\n"
		"DaeBuilder_set_unit(DaeBuilder self, std::string const & name, std::string const & val)\n"
		"\n"
		"\n"
		"Set the unit for a component.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_type_name", _wrap_DaeBuilder_type_name, METH_O, "\n"
		"DaeBuilder_type_name(DaeBuilder self) -> std::string\n"
		"\n"
		"\n"
		"Readable name of the class.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_disp", _wrap_DaeBuilder_disp, METH_VARARGS, "\n"
		"DaeBuilder_disp(DaeBuilder self, bool more=False)\n"
		"\n"
		"\n"
		"Print representation.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_str", _wrap_DaeBuilder_str, METH_VARARGS, "\n"
		"DaeBuilder_str(DaeBuilder self, bool more=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_add_variable", _wrap_DaeBuilder_add_variable, METH_VARARGS, "\n"
		"DaeBuilder_add_variable(DaeBuilder self, std::string const & name, Variable var)\n"
		"DaeBuilder_add_variable(DaeBuilder self, std::string const & name, casadi_int n=1) -> MX\n"
		"DaeBuilder_add_variable(DaeBuilder self, std::string const & name, Sparsity sp) -> MX\n"
		"\n"
		"\n"
		"Add a new variable: returns corresponding symbolic expression.\n"
		"\n"
		"\n"
		""},
	 { "DaeBuilder_variable", _wrap_DaeBuilder_variable, METH_VARARGS, "\n"
		"DaeBuilder_variable(DaeBuilder self, std::string const & name) -> Variable\n"
		"DaeBuilder_variable(DaeBuilder self, std::string const & name) -> Variable\n"
		"\n"
		"\n"
		"Access a variable by name\n"
		"\n"
		"\n"
		""},
	 { "new_DaeBuilder", _wrap_new_DaeBuilder, METH_VARARGS, "\n"
		"DaeBuilder()\n"
		"new_DaeBuilder(DaeBuilder other) -> DaeBuilder\n"
		"\n"
		"\n"
		"Default constructor.\n"
		"\n"
		"\n"
		""},
	 { "delete_DaeBuilder", _wrap_delete_DaeBuilder, METH_O, "delete_DaeBuilder(DaeBuilder self)"},
	 { "DaeBuilder_swigregister", DaeBuilder_swigregister, METH_O, NULL},
	 { "DaeBuilder_swiginit", DaeBuilder_swiginit, METH_VARARGS, NULL},
	 { "XmlFile_type_name", _wrap_XmlFile_type_name, METH_NOARGS, "XmlFile_type_name() -> std::string"},
	 { "delete_XmlFile", _wrap_delete_XmlFile, METH_O, "delete_XmlFile(XmlFile self)"},
	 { "XmlFile_load_plugin", _wrap_XmlFile_load_plugin, METH_O, "XmlFile_load_plugin(std::string const & name)"},
	 { "XmlFile_doc", _wrap_XmlFile_doc, METH_O, "XmlFile_doc(std::string const & name) -> std::string"},
	 { "new_XmlFile", _wrap_new_XmlFile, METH_VARARGS, "\n"
		"XmlFile()\n"
		"XmlFile(std::string const & name)\n"
		"new_XmlFile(XmlFile other) -> XmlFile\n"
		""},
	 { "XmlFile_swigregister", XmlFile_swigregister, METH_O, NULL},
	 { "XmlFile_swiginit", XmlFile_swiginit, METH_VARARGS, NULL},
	 { "delete_SerializerBase", _wrap_delete_SerializerBase, METH_O, "delete_SerializerBase(SerializerBase self)"},
	 { "SerializerBase_pack", _wrap_SerializerBase_pack, METH_VARARGS, "\n"
		"SerializerBase_pack(SerializerBase self, Sparsity e)\n"
		"SerializerBase_pack(SerializerBase self, MX e)\n"
		"SerializerBase_pack(SerializerBase self, DM e)\n"
		"SerializerBase_pack(SerializerBase self, SX e)\n"
		"SerializerBase_pack(SerializerBase self, Linsol e)\n"
		"SerializerBase_pack(SerializerBase self, Function e)\n"
		"SerializerBase_pack(SerializerBase self, GenericType e)\n"
		"SerializerBase_pack(SerializerBase self, casadi_int const & e)\n"
		"SerializerBase_pack(SerializerBase self, double const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::string const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > > const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< casadi::Function,std::allocator< casadi::Function > > const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< casadi::GenericType,std::allocator< casadi::GenericType > > const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< casadi_int,std::allocator< casadi_int > > const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< double,std::allocator< double > > const & e)\n"
		"SerializerBase_pack(SerializerBase self, std::vector< std::string,std::allocator< std::string > > const & e)\n"
		""},
	 { "SerializerBase_type_to_string", _wrap_SerializerBase_type_to_string, METH_O, "SerializerBase_type_to_string(casadi::SerializerBase::SerializationType type) -> std::string"},
	 { "SerializerBase_connect", _wrap_SerializerBase_connect, METH_VARARGS, "SerializerBase_connect(SerializerBase self, DeserializerBase s)"},
	 { "SerializerBase_reset", _wrap_SerializerBase_reset, METH_O, "SerializerBase_reset(SerializerBase self)"},
	 { "SerializerBase_swigregister", SerializerBase_swigregister, METH_O, NULL},
	 { "delete_DeserializerBase", _wrap_delete_DeserializerBase, METH_O, "delete_DeserializerBase(DeserializerBase self)"},
	 { "DeserializerBase__pop_type", _wrap_DeserializerBase__pop_type, METH_O, "DeserializerBase__pop_type(DeserializerBase self) -> casadi::SerializerBase::SerializationType"},
	 { "DeserializerBase_blind_unpack_sparsity", _wrap_DeserializerBase_blind_unpack_sparsity, METH_O, "DeserializerBase_blind_unpack_sparsity(DeserializerBase self) -> Sparsity"},
	 { "DeserializerBase_blind_unpack_mx", _wrap_DeserializerBase_blind_unpack_mx, METH_O, "DeserializerBase_blind_unpack_mx(DeserializerBase self) -> MX"},
	 { "DeserializerBase_blind_unpack_dm", _wrap_DeserializerBase_blind_unpack_dm, METH_O, "DeserializerBase_blind_unpack_dm(DeserializerBase self) -> DM"},
	 { "DeserializerBase_blind_unpack_sx", _wrap_DeserializerBase_blind_unpack_sx, METH_O, "DeserializerBase_blind_unpack_sx(DeserializerBase self) -> SX"},
	 { "DeserializerBase_blind_unpack_linsol", _wrap_DeserializerBase_blind_unpack_linsol, METH_O, "DeserializerBase_blind_unpack_linsol(DeserializerBase self) -> Linsol"},
	 { "DeserializerBase_blind_unpack_function", _wrap_DeserializerBase_blind_unpack_function, METH_O, "DeserializerBase_blind_unpack_function(DeserializerBase self) -> Function"},
	 { "DeserializerBase_blind_unpack_generictype", _wrap_DeserializerBase_blind_unpack_generictype, METH_O, "DeserializerBase_blind_unpack_generictype(DeserializerBase self) -> GenericType"},
	 { "DeserializerBase_blind_unpack_int", _wrap_DeserializerBase_blind_unpack_int, METH_O, "DeserializerBase_blind_unpack_int(DeserializerBase self) -> casadi_int"},
	 { "DeserializerBase_blind_unpack_double", _wrap_DeserializerBase_blind_unpack_double, METH_O, "DeserializerBase_blind_unpack_double(DeserializerBase self) -> double"},
	 { "DeserializerBase_blind_unpack_string", _wrap_DeserializerBase_blind_unpack_string, METH_O, "DeserializerBase_blind_unpack_string(DeserializerBase self) -> std::string"},
	 { "DeserializerBase_blind_unpack_sparsity_vector", _wrap_DeserializerBase_blind_unpack_sparsity_vector, METH_O, "DeserializerBase_blind_unpack_sparsity_vector(DeserializerBase self) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >"},
	 { "DeserializerBase_blind_unpack_mx_vector", _wrap_DeserializerBase_blind_unpack_mx_vector, METH_O, "DeserializerBase_blind_unpack_mx_vector(DeserializerBase self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"},
	 { "DeserializerBase_blind_unpack_dm_vector", _wrap_DeserializerBase_blind_unpack_dm_vector, METH_O, "DeserializerBase_blind_unpack_dm_vector(DeserializerBase self) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >"},
	 { "DeserializerBase_blind_unpack_sx_vector", _wrap_DeserializerBase_blind_unpack_sx_vector, METH_O, "DeserializerBase_blind_unpack_sx_vector(DeserializerBase self) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >"},
	 { "DeserializerBase_blind_unpack_linsol_vector", _wrap_DeserializerBase_blind_unpack_linsol_vector, METH_O, "DeserializerBase_blind_unpack_linsol_vector(DeserializerBase self) -> std::vector< casadi::Linsol,std::allocator< casadi::Linsol > >"},
	 { "DeserializerBase_blind_unpack_function_vector", _wrap_DeserializerBase_blind_unpack_function_vector, METH_O, "DeserializerBase_blind_unpack_function_vector(DeserializerBase self) -> std::vector< casadi::Function,std::allocator< casadi::Function > >"},
	 { "DeserializerBase_blind_unpack_generictype_vector", _wrap_DeserializerBase_blind_unpack_generictype_vector, METH_O, "DeserializerBase_blind_unpack_generictype_vector(DeserializerBase self) -> std::vector< casadi::GenericType,std::allocator< casadi::GenericType > >"},
	 { "DeserializerBase_blind_unpack_int_vector", _wrap_DeserializerBase_blind_unpack_int_vector, METH_O, "DeserializerBase_blind_unpack_int_vector(DeserializerBase self) -> std::vector< casadi_int,std::allocator< casadi_int > >"},
	 { "DeserializerBase_blind_unpack_double_vector", _wrap_DeserializerBase_blind_unpack_double_vector, METH_O, "DeserializerBase_blind_unpack_double_vector(DeserializerBase self) -> std::vector< double,std::allocator< double > >"},
	 { "DeserializerBase_blind_unpack_string_vector", _wrap_DeserializerBase_blind_unpack_string_vector, METH_O, "DeserializerBase_blind_unpack_string_vector(DeserializerBase self) -> std::vector< std::string,std::allocator< std::string > >"},
	 { "DeserializerBase_unpack_sparsity", _wrap_DeserializerBase_unpack_sparsity, METH_O, "DeserializerBase_unpack_sparsity(DeserializerBase self) -> Sparsity"},
	 { "DeserializerBase_unpack_mx", _wrap_DeserializerBase_unpack_mx, METH_O, "DeserializerBase_unpack_mx(DeserializerBase self) -> MX"},
	 { "DeserializerBase_unpack_dm", _wrap_DeserializerBase_unpack_dm, METH_O, "DeserializerBase_unpack_dm(DeserializerBase self) -> DM"},
	 { "DeserializerBase_unpack_sx", _wrap_DeserializerBase_unpack_sx, METH_O, "DeserializerBase_unpack_sx(DeserializerBase self) -> SX"},
	 { "DeserializerBase_unpack_linsol", _wrap_DeserializerBase_unpack_linsol, METH_O, "DeserializerBase_unpack_linsol(DeserializerBase self) -> Linsol"},
	 { "DeserializerBase_unpack_function", _wrap_DeserializerBase_unpack_function, METH_O, "DeserializerBase_unpack_function(DeserializerBase self) -> Function"},
	 { "DeserializerBase_unpack_generictype", _wrap_DeserializerBase_unpack_generictype, METH_O, "DeserializerBase_unpack_generictype(DeserializerBase self) -> GenericType"},
	 { "DeserializerBase_unpack_int", _wrap_DeserializerBase_unpack_int, METH_O, "DeserializerBase_unpack_int(DeserializerBase self) -> casadi_int"},
	 { "DeserializerBase_unpack_double", _wrap_DeserializerBase_unpack_double, METH_O, "DeserializerBase_unpack_double(DeserializerBase self) -> double"},
	 { "DeserializerBase_unpack_string", _wrap_DeserializerBase_unpack_string, METH_O, "DeserializerBase_unpack_string(DeserializerBase self) -> std::string"},
	 { "DeserializerBase_unpack_sparsity_vector", _wrap_DeserializerBase_unpack_sparsity_vector, METH_O, "DeserializerBase_unpack_sparsity_vector(DeserializerBase self) -> std::vector< casadi::Sparsity,std::allocator< casadi::Sparsity > >"},
	 { "DeserializerBase_unpack_mx_vector", _wrap_DeserializerBase_unpack_mx_vector, METH_O, "DeserializerBase_unpack_mx_vector(DeserializerBase self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"},
	 { "DeserializerBase_unpack_dm_vector", _wrap_DeserializerBase_unpack_dm_vector, METH_O, "DeserializerBase_unpack_dm_vector(DeserializerBase self) -> std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >"},
	 { "DeserializerBase_unpack_sx_vector", _wrap_DeserializerBase_unpack_sx_vector, METH_O, "DeserializerBase_unpack_sx_vector(DeserializerBase self) -> std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >"},
	 { "DeserializerBase_unpack_linsol_vector", _wrap_DeserializerBase_unpack_linsol_vector, METH_O, "DeserializerBase_unpack_linsol_vector(DeserializerBase self) -> std::vector< casadi::Linsol,std::allocator< casadi::Linsol > >"},
	 { "DeserializerBase_unpack_function_vector", _wrap_DeserializerBase_unpack_function_vector, METH_O, "DeserializerBase_unpack_function_vector(DeserializerBase self) -> std::vector< casadi::Function,std::allocator< casadi::Function > >"},
	 { "DeserializerBase_unpack_generictype_vector", _wrap_DeserializerBase_unpack_generictype_vector, METH_O, "DeserializerBase_unpack_generictype_vector(DeserializerBase self) -> std::vector< casadi::GenericType,std::allocator< casadi::GenericType > >"},
	 { "DeserializerBase_unpack_int_vector", _wrap_DeserializerBase_unpack_int_vector, METH_O, "DeserializerBase_unpack_int_vector(DeserializerBase self) -> std::vector< casadi_int,std::allocator< casadi_int > >"},
	 { "DeserializerBase_unpack_double_vector", _wrap_DeserializerBase_unpack_double_vector, METH_O, "DeserializerBase_unpack_double_vector(DeserializerBase self) -> std::vector< double,std::allocator< double > >"},
	 { "DeserializerBase_unpack_string_vector", _wrap_DeserializerBase_unpack_string_vector, METH_O, "DeserializerBase_unpack_string_vector(DeserializerBase self) -> std::vector< std::string,std::allocator< std::string > >"},
	 { "DeserializerBase_connect", _wrap_DeserializerBase_connect, METH_VARARGS, "DeserializerBase_connect(DeserializerBase self, SerializerBase s)"},
	 { "DeserializerBase_reset", _wrap_DeserializerBase_reset, METH_O, "DeserializerBase_reset(DeserializerBase self)"},
	 { "DeserializerBase_swigregister", DeserializerBase_swigregister, METH_O, NULL},
	 { "new_StringSerializer", _wrap_new_StringSerializer, METH_VARARGS, "new_StringSerializer(casadi::Dict const & opts=casadi::Dict()) -> StringSerializer"},
	 { "delete_StringSerializer", _wrap_delete_StringSerializer, METH_O, "delete_StringSerializer(StringSerializer self)"},
	 { "StringSerializer_encode", _wrap_StringSerializer_encode, METH_O, "\n"
		"StringSerializer_encode(StringSerializer self) -> std::string\n"
		"\n"
		"\n"
		"Returns a string that holds the serialized objects.\n"
		"\n"
		"As a side effect, this method clears the internal buffer\n"
		"\n"
		"\n"
		""},
	 { "StringSerializer_swigregister", StringSerializer_swigregister, METH_O, NULL},
	 { "StringSerializer_swiginit", StringSerializer_swiginit, METH_VARARGS, NULL},
	 { "new_FileSerializer", _wrap_new_FileSerializer, METH_VARARGS, "\n"
		"new_FileSerializer(std::string const & fname, casadi::Dict const & opts=casadi::Dict()) -> FileSerializer\n"
		"\n"
		"\n"
		"Advanced serialization of CasADi objects.\n"
		"\n"
		"StringSerializer, FileDeserializer\n"
		"\n"
		"\n"
		""},
	 { "delete_FileSerializer", _wrap_delete_FileSerializer, METH_O, "delete_FileSerializer(FileSerializer self)"},
	 { "FileSerializer_swigregister", FileSerializer_swigregister, METH_O, NULL},
	 { "FileSerializer_swiginit", FileSerializer_swiginit, METH_VARARGS, NULL},
	 { "new_StringDeserializer", _wrap_new_StringDeserializer, METH_O, "\n"
		"new_StringDeserializer(std::string const & string) -> StringDeserializer\n"
		"\n"
		"\n"
		"Advanced deserialization of CasADi objects.\n"
		"\n"
		"StringDeserializer\n"
		"\n"
		"\n"
		""},
	 { "delete_StringDeserializer", _wrap_delete_StringDeserializer, METH_O, "delete_StringDeserializer(StringDeserializer self)"},
	 { "StringDeserializer_decode", _wrap_StringDeserializer_decode, METH_VARARGS, "\n"
		"StringDeserializer_decode(StringDeserializer self, std::string const & string)\n"
		"\n"
		"\n"
		"Sets the string to deserialize objects from.\n"
		"\n"
		"\n"
		""},
	 { "StringDeserializer_swigregister", StringDeserializer_swigregister, METH_O, NULL},
	 { "StringDeserializer_swiginit", StringDeserializer_swiginit, METH_VARARGS, NULL},
	 { "new_FileDeserializer", _wrap_new_FileDeserializer, METH_O, "\n"
		"new_FileDeserializer(std::string const & fname) -> FileDeserializer\n"
		"\n"
		"\n"
		"Advanced deserialization of CasADi objects.\n"
		"\n"
		"FileSerializer\n"
		"\n"
		"\n"
		""},
	 { "delete_FileDeserializer", _wrap_delete_FileDeserializer, METH_O, "delete_FileDeserializer(FileDeserializer self)"},
	 { "FileDeserializer_swigregister", FileDeserializer_swigregister, METH_O, NULL},
	 { "FileDeserializer_swiginit", FileDeserializer_swiginit, METH_VARARGS, NULL},
	 { "Opti__variable", _wrap_Opti__variable, METH_VARARGS, "\n"
		"Opti__variable(Opti self, casadi_int n=1, casadi_int m=1, std::string const & attribute=\"full\") -> MX\n"
		"\n"
		"\n"
		"Create a decision variable (symbol)\n"
		"\n"
		"The order of creation matters. The order will be reflected in the\n"
		"optimization problem. It is not required for decision variables to actualy\n"
		"appear in the optimization problem.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"n:  number of rows (default 1)\n"
		"\n"
		"m:  number of columnss (default 1)\n"
		"\n"
		"attribute:  'full' (default) or 'symmetric'\n"
		"\n"
		"\n"
		""},
	 { "Opti__parameter", _wrap_Opti__parameter, METH_VARARGS, "\n"
		"Opti__parameter(Opti self, casadi_int n=1, casadi_int m=1, std::string const & attribute=\"full\") -> MX\n"
		"\n"
		"\n"
		"Create a parameter (symbol); fixed during optimization.\n"
		"\n"
		"The order of creation does not matter. It is not required for parameter to\n"
		"actualy appear in the optimization problem. Parameters that do appear, must\n"
		"be given a value before the problem can be solved.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"n:  number of rows (default 1)\n"
		"\n"
		"m:  number of columnss (default 1)\n"
		"\n"
		"attribute:  'full' (default) or 'symmetric'\n"
		"\n"
		"\n"
		""},
	 { "Opti_minimize", _wrap_Opti_minimize, METH_VARARGS, "\n"
		"Opti_minimize(Opti self, MX f)\n"
		"\n"
		"\n"
		"Set objective.\n"
		"\n"
		"Objective must be a scalar. Default objective: 0 When method is called\n"
		"multiple times, the last call takes effect\n"
		"\n"
		"\n"
		""},
	 { "Opti__subject_to", _wrap_Opti__subject_to, METH_VARARGS, "\n"
		"Opti__subject_to(Opti self, MX g)\n"
		"Opti__subject_to(Opti self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & g)\n"
		"Opti__subject_to(Opti self)\n"
		"\n"
		"\n"
		"Add constraints.\n"
		"\n"
		"Examples:\n"
		"\n"
		"::\n"
		"\n"
		"  * \\\\begin{itemize}\n"
		"  * opti.subject_to( sqrt(x+y) >= 1);\n"
		"  * opti.subject_to( sqrt(x+y) > 1)}: same as above\n"
		"  * opti.subject_to( 1<= sqrt(x+y) )}: same as above\n"
		"  * opti.subject_to( 5*x+y==1 )}: equality\n"
		"  *\n"
		"  * Python\n"
		"  * opti.subject_to([x*y>=1,x==3])\n"
		"  * opti.subject_to(opti.bounded(0,x,1))\n"
		"  *\n"
		"  * MATLAB\n"
		"  * opti.subject_to({x*y>=1,x==3})\n"
		"  * opti.subject_to( 0<=x<=1 )\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"Related functionalities: opti.lbg,opti.g,opti.ubg represent the vector of\n"
		"flattened constraints\n"
		"\n"
		"opti.debug.show_infeasibilities() may be used to inspect which constraints\n"
		"are violated\n"
		"\n"
		"\n"
		""},
	 { "Opti_solver", _wrap_Opti_solver, METH_VARARGS, "\n"
		"Opti_solver(Opti self, std::string const & solver, casadi::Dict const & plugin_options=casadi::Dict(), casadi::Dict const & solver_options=casadi::Dict())\n"
		"\n"
		"\n"
		"Set a solver.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"solver:  any of the nlpsol plugins can be used here In practice, not all\n"
		"nlpsol plugins may be supported yet\n"
		"\n"
		"options:  passed on to nlpsol plugin No stability can be guaranteed about\n"
		"this part of the API\n"
		"\n"
		"options:  to be passed to nlpsol solver No stability can be guaranteed about\n"
		"this part of the API\n"
		"\n"
		"\n"
		""},
	 { "Opti_set_initial", _wrap_Opti_set_initial, METH_VARARGS, "\n"
		"Opti_set_initial(Opti self, MX x, DM v)\n"
		"Opti_set_initial(Opti self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & assignments)\n"
		"\n"
		"\n"
		"Set initial guess for decision variables\n"
		"\n"
		"::\n"
		"\n"
		"  * opti.set_initial(x, 2)\n"
		"  * opti.set_initial(10*x(1), 2)\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "Opti_set_value", _wrap_Opti_set_value, METH_VARARGS, "\n"
		"Opti_set_value(Opti self, MX x, DM v)\n"
		"Opti_set_value(Opti self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & assignments)\n"
		"\n"
		"\n"
		"Set value of parameter.\n"
		"\n"
		"Each parameter must be given a value before 'solve' can be called\n"
		"\n"
		"\n"
		""},
	 { "Opti_solve", _wrap_Opti_solve, METH_O, "\n"
		"Opti_solve(Opti self) -> OptiSol\n"
		"\n"
		"\n"
		"Crunch the numbers; solve the problem.\n"
		"\n"
		"\n"
		""},
	 { "Opti_solve_limited", _wrap_Opti_solve_limited, METH_O, "\n"
		"Opti_solve_limited(Opti self) -> OptiSol\n"
		"\n"
		"\n"
		"Crunch the numbers; solve the problem.\n"
		"\n"
		"Allows the solver to return without error when an iteration or time limit is\n"
		"reached\n"
		"\n"
		"\n"
		""},
	 { "Opti_value", _wrap_Opti_value, METH_VARARGS, "\n"
		"Opti_value(Opti self, MX x, std::vector< casadi::MX,std::allocator< casadi::MX > > const & values=std::vector< casadi::MX >()) -> DM\n"
		"Opti_value(Opti self, DM x, std::vector< casadi::MX,std::allocator< casadi::MX > > const & values=std::vector< casadi::MX >()) -> DM\n"
		"Opti_value(Opti self, SX x, std::vector< casadi::MX,std::allocator< casadi::MX > > const & values=std::vector< casadi::MX >()) -> DM\n"
		"\n"
		"\n"
		"Obtain value of expression at the current value\n"
		"\n"
		"In regular mode, teh current value is the converged solution In debug mode,\n"
		"the value can be non-converged\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"values:  Optional assignment expressions (e.g. x==3) to overrule the current\n"
		"value\n"
		"\n"
		"\n"
		""},
	 { "Opti_stats", _wrap_Opti_stats, METH_O, "\n"
		"Opti_stats(Opti self) -> casadi::Dict\n"
		"\n"
		"\n"
		"Get statistics.\n"
		"\n"
		"nlpsol stats are passed as-is. No stability can be guaranteed about this\n"
		"part of the API\n"
		"\n"
		"\n"
		""},
	 { "Opti_return_status", _wrap_Opti_return_status, METH_O, "\n"
		"Opti_return_status(Opti self) -> std::string\n"
		"\n"
		"\n"
		"Get return status of solver passed as-is from nlpsol No stability can be\n"
		"guaranteed about this part of the API.\n"
		"\n"
		"\n"
		""},
	 { "Opti_initial", _wrap_Opti_initial, METH_O, "\n"
		"Opti_initial(Opti self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"get assignment expressions for initial values\n"
		"\n"
		"\n"
		""},
	 { "Opti_value_variables", _wrap_Opti_value_variables, METH_O, "\n"
		"Opti_value_variables(Opti self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"get assignment expressions for latest values\n"
		"\n"
		"\n"
		""},
	 { "Opti_value_parameters", _wrap_Opti_value_parameters, METH_O, "Opti_value_parameters(Opti self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"},
	 { "Opti_dual", _wrap_Opti_dual, METH_VARARGS, "\n"
		"Opti_dual(Opti self, MX m) -> MX\n"
		"\n"
		"\n"
		"get the dual variable\n"
		"\n"
		"m must be a constraint expression. The returned value is still a symbolic\n"
		"expression. Use value on it to obtain the numerical value.\n"
		"\n"
		"\n"
		""},
	 { "Opti__nx", _wrap_Opti__nx, METH_O, "\n"
		"Opti__nx(Opti self) -> casadi_int\n"
		"\n"
		"\n"
		"Number of (scalarised) decision variables.\n"
		"\n"
		"\n"
		""},
	 { "Opti__np", _wrap_Opti__np, METH_O, "\n"
		"Opti__np(Opti self) -> casadi_int\n"
		"\n"
		"\n"
		"Number of (scalarised) parameters.\n"
		"\n"
		"\n"
		""},
	 { "Opti__ng", _wrap_Opti__ng, METH_O, "\n"
		"Opti__ng(Opti self) -> casadi_int\n"
		"\n"
		"\n"
		"Number of (scalarised) constraints.\n"
		"\n"
		"\n"
		""},
	 { "Opti__x", _wrap_Opti__x, METH_O, "\n"
		"Opti__x(Opti self) -> MX\n"
		"\n"
		"\n"
		"Get all (scalarised) decision variables as a symbolic column vector.\n"
		"\n"
		"\n"
		""},
	 { "Opti__p", _wrap_Opti__p, METH_O, "\n"
		"Opti__p(Opti self) -> MX\n"
		"\n"
		"\n"
		"Get all (scalarised) parameters as a symbolic column vector.\n"
		"\n"
		"\n"
		""},
	 { "Opti__g", _wrap_Opti__g, METH_O, "\n"
		"Opti__g(Opti self) -> MX\n"
		"\n"
		"\n"
		"Get all (scalarised) constraint expressions as a column vector.\n"
		"\n"
		"\n"
		""},
	 { "Opti__f", _wrap_Opti__f, METH_O, "\n"
		"Opti__f(Opti self) -> MX\n"
		"\n"
		"\n"
		"Get objective expression.\n"
		"\n"
		"\n"
		""},
	 { "Opti__lbg", _wrap_Opti__lbg, METH_O, "\n"
		"Opti__lbg(Opti self) -> MX\n"
		"\n"
		"\n"
		"Get all (scalarised) bounds on constraints as a column vector.\n"
		"\n"
		"\n"
		""},
	 { "Opti__ubg", _wrap_Opti__ubg, METH_O, "Opti__ubg(Opti self) -> MX"},
	 { "Opti__lam_g", _wrap_Opti__lam_g, METH_O, "\n"
		"Opti__lam_g(Opti self) -> MX\n"
		"\n"
		"\n"
		"Get all (scalarised) dual variables as a symbolic column vector.\n"
		"\n"
		"Useful for obtaining the Lagrange Hessian:\n"
		"\n"
		"::\n"
		"\n"
		"  * sol.value(hessian(opti.f+opti.lam_g'*opti.g,opti.x)) % MATLAB\n"
		"  * sol.value(hessian(opti.f+dot(opti.lam_g,opti.g),opti.x)[0]) # Python\n"
		"  * \n"
		"\n"
		"\n"
		"\n"
		"\n"
		""},
	 { "Opti_to_function", _wrap_Opti_to_function, METH_VARARGS, "\n"
		"Opti_to_function(Opti self, std::string const & name, std::vector< casadi::MX,std::allocator< casadi::MX > > const & args, std::vector< casadi::MX,std::allocator< casadi::MX > > const & res, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"Opti_to_function(Opti self, std::string const & name, std::vector< casadi::MX,std::allocator< casadi::MX > > const & args, std::vector< casadi::MX,std::allocator< casadi::MX > > const & res, std::vector< std::string,std::allocator< std::string > > const & name_in, std::vector< std::string,std::allocator< std::string > > const & name_out, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		"Opti_to_function(Opti self, std::string const & name, std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > const & dict, std::vector< std::string,std::allocator< std::string > > const & name_in, std::vector< std::string,std::allocator< std::string > > const & name_out, casadi::Dict const & opts=casadi::Dict()) -> Function\n"
		""},
	 { "Opti_bounded", _wrap_Opti_bounded, METH_VARARGS, "Opti_bounded(MX lb, MX expr, MX ub) -> MX"},
	 { "Opti__debug", _wrap_Opti__debug, METH_O, "\n"
		"Opti__debug(Opti self) -> OptiAdvanced\n"
		"\n"
		"\n"
		"Get a copy with advanced functionality.\n"
		"\n"
		"You get access to more methods, but you have no guarantees about API\n"
		"stability\n"
		"\n"
		"The copy is effectively a deep copy: Updating the state of the copy does not\n"
		"update the original.\n"
		"\n"
		"\n"
		""},
	 { "Opti__advanced", _wrap_Opti__advanced, METH_O, "\n"
		"Opti__advanced(Opti self) -> OptiAdvanced\n"
		"\n"
		"\n"
		"Get a copy with advanced functionality.\n"
		"\n"
		"You get access to more methods, but you have no guarantees about API\n"
		"stability\n"
		"\n"
		"The copy is effectively a deep copy: Updating the state of the copy does not\n"
		"update the original.\n"
		"\n"
		"\n"
		""},
	 { "Opti_copy", _wrap_Opti_copy, METH_O, "\n"
		"Opti_copy(Opti self) -> Opti\n"
		"\n"
		"\n"
		"Get a copy of the.\n"
		"\n"
		"The copy is effectively a deep copy: Updating the state of the copy does not\n"
		"update the original.\n"
		"\n"
		"\n"
		""},
	 { "Opti_update_user_dict", _wrap_Opti_update_user_dict, METH_VARARGS, "\n"
		"Opti_update_user_dict(Opti self, MX m, casadi::Dict const & meta)\n"
		"Opti_update_user_dict(Opti self, std::vector< casadi::MX,std::allocator< casadi::MX > > const & m, casadi::Dict const & meta)\n"
		"\n"
		"\n"
		"add user data Add arbitrary data in the form of a dictionary to symbols or\n"
		"constraints\n"
		"\n"
		"\n"
		""},
	 { "Opti_user_dict", _wrap_Opti_user_dict, METH_VARARGS, "\n"
		"Opti_user_dict(Opti self, MX m) -> casadi::Dict\n"
		"\n"
		"\n"
		"Get user data.\n"
		"\n"
		"\n"
		""},
	 { "Opti_type_name", _wrap_Opti_type_name, METH_O, "\n"
		"Opti_type_name(Opti self) -> std::string\n"
		"\n"
		"\n"
		"Readable name of the class.\n"
		"\n"
		"\n"
		""},
	 { "Opti_disp", _wrap_Opti_disp, METH_VARARGS, "\n"
		"Opti_disp(Opti self, bool more=False)\n"
		"\n"
		"\n"
		"Print representation.\n"
		"\n"
		"\n"
		""},
	 { "Opti_str", _wrap_Opti_str, METH_VARARGS, "\n"
		"Opti_str(Opti self, bool more=False) -> std::string\n"
		"\n"
		"\n"
		"Get string representation.\n"
		"\n"
		"\n"
		""},
	 { "Opti_callback_class", _wrap_Opti_callback_class, METH_VARARGS, "\n"
		"Opti_callback_class(Opti self, OptiCallback callback)\n"
		"Opti_callback_class(Opti self)\n"
		"\n"
		"\n"
		"Helper methods for callback()\n"
		"\n"
		"Do not use directly.\n"
		"\n"
		"\n"
		""},
	 { "new_Opti", _wrap_new_Opti, METH_VARARGS, "\n"
		"Opti(std::string const & problem_type=\"nlp\")\n"
		"new_Opti(Opti other) -> Opti\n"
		"\n"
		"\n"
		"Create Opti Context.\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"problem_type:  of optimization 'nlp' or 'conic' (default nlp)\n"
		"\n"
		"\n"
		""},
	 { "delete_Opti", _wrap_delete_Opti, METH_O, "delete_Opti(Opti self)"},
	 { "Opti_swigregister", Opti_swigregister, METH_O, NULL},
	 { "Opti_swiginit", Opti_swiginit, METH_VARARGS, NULL},
	 { "IndexAbstraction_start_get", _wrap_IndexAbstraction_start_get, METH_O, "IndexAbstraction_start_get(IndexAbstraction self) -> casadi_int"},
	 { "IndexAbstraction_stop_get", _wrap_IndexAbstraction_stop_get, METH_O, "IndexAbstraction_stop_get(IndexAbstraction self) -> casadi_int"},
	 { "new_IndexAbstraction", _wrap_new_IndexAbstraction, METH_VARARGS, "\n"
		"IndexAbstraction()\n"
		"new_IndexAbstraction(IndexAbstraction other) -> IndexAbstraction\n"
		""},
	 { "delete_IndexAbstraction", _wrap_delete_IndexAbstraction, METH_O, "delete_IndexAbstraction(IndexAbstraction self)"},
	 { "IndexAbstraction_swigregister", IndexAbstraction_swigregister, METH_O, NULL},
	 { "IndexAbstraction_swiginit", IndexAbstraction_swiginit, METH_VARARGS, NULL},
	 { "MetaCon_original_get", _wrap_MetaCon_original_get, METH_O, "MetaCon_original_get(MetaCon self) -> MX"},
	 { "MetaCon_canon_get", _wrap_MetaCon_canon_get, METH_O, "MetaCon_canon_get(MetaCon self) -> MX"},
	 { "MetaCon_type_get", _wrap_MetaCon_type_get, METH_O, "MetaCon_type_get(MetaCon self) -> casadi::ConstraintType"},
	 { "MetaCon_lb_get", _wrap_MetaCon_lb_get, METH_O, "MetaCon_lb_get(MetaCon self) -> MX"},
	 { "MetaCon_ub_get", _wrap_MetaCon_ub_get, METH_O, "MetaCon_ub_get(MetaCon self) -> MX"},
	 { "MetaCon_n_get", _wrap_MetaCon_n_get, METH_O, "MetaCon_n_get(MetaCon self) -> casadi_int"},
	 { "MetaCon_flipped_get", _wrap_MetaCon_flipped_get, METH_O, "MetaCon_flipped_get(MetaCon self) -> bool"},
	 { "MetaCon_dual_canon_get", _wrap_MetaCon_dual_canon_get, METH_O, "MetaCon_dual_canon_get(MetaCon self) -> MX"},
	 { "MetaCon_dual_get", _wrap_MetaCon_dual_get, METH_O, "MetaCon_dual_get(MetaCon self) -> MX"},
	 { "MetaCon_extra_get", _wrap_MetaCon_extra_get, METH_O, "MetaCon_extra_get(MetaCon self) -> casadi::Dict const &"},
	 { "new_MetaCon", _wrap_new_MetaCon, METH_VARARGS, "\n"
		"MetaCon()\n"
		"new_MetaCon(MetaCon other) -> MetaCon\n"
		""},
	 { "delete_MetaCon", _wrap_delete_MetaCon, METH_O, "delete_MetaCon(MetaCon self)"},
	 { "MetaCon_swigregister", MetaCon_swigregister, METH_O, NULL},
	 { "MetaCon_swiginit", MetaCon_swiginit, METH_VARARGS, NULL},
	 { "MetaVar_attribute_get", _wrap_MetaVar_attribute_get, METH_O, "MetaVar_attribute_get(MetaVar self) -> std::string const &"},
	 { "MetaVar_n_get", _wrap_MetaVar_n_get, METH_O, "MetaVar_n_get(MetaVar self) -> casadi_int"},
	 { "MetaVar_m_get", _wrap_MetaVar_m_get, METH_O, "MetaVar_m_get(MetaVar self) -> casadi_int"},
	 { "MetaVar_type_get", _wrap_MetaVar_type_get, METH_O, "MetaVar_type_get(MetaVar self) -> casadi::VariableType"},
	 { "MetaVar_count_get", _wrap_MetaVar_count_get, METH_O, "MetaVar_count_get(MetaVar self) -> casadi_int"},
	 { "MetaVar_i_get", _wrap_MetaVar_i_get, METH_O, "MetaVar_i_get(MetaVar self) -> casadi_int"},
	 { "MetaVar_active_i_get", _wrap_MetaVar_active_i_get, METH_O, "MetaVar_active_i_get(MetaVar self) -> casadi_int"},
	 { "MetaVar_extra_get", _wrap_MetaVar_extra_get, METH_O, "MetaVar_extra_get(MetaVar self) -> casadi::Dict const &"},
	 { "new_MetaVar", _wrap_new_MetaVar, METH_VARARGS, "\n"
		"MetaVar()\n"
		"new_MetaVar(MetaVar other) -> MetaVar\n"
		""},
	 { "delete_MetaVar", _wrap_delete_MetaVar, METH_O, "delete_MetaVar(MetaVar self)"},
	 { "MetaVar_swigregister", MetaVar_swigregister, METH_O, NULL},
	 { "MetaVar_swiginit", MetaVar_swiginit, METH_VARARGS, NULL},
	 { "new_OptiCallback", _wrap_new_OptiCallback, METH_VARARGS, "\n"
		"OptiCallback()\n"
		"new_OptiCallback(PyObject * _self, OptiCallback obj) -> OptiCallback\n"
		""},
	 { "OptiCallback_call", _wrap_OptiCallback_call, METH_VARARGS, "OptiCallback_call(OptiCallback self, casadi_int i)"},
	 { "delete_OptiCallback", _wrap_delete_OptiCallback, METH_O, "delete_OptiCallback(OptiCallback self)"},
	 { "disown_OptiCallback", _wrap_disown_OptiCallback, METH_O, NULL},
	 { "OptiCallback_swigregister", OptiCallback_swigregister, METH_O, NULL},
	 { "OptiCallback_swiginit", OptiCallback_swiginit, METH_VARARGS, NULL},
	 { "delete_OptiAdvanced", _wrap_delete_OptiAdvanced, METH_O, "\n"
		"delete_OptiAdvanced(OptiAdvanced self)\n"
		"\n"
		"\n"
		"Destructor.\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced__casadi_solver", _wrap_OptiAdvanced__casadi_solver, METH_O, "\n"
		"OptiAdvanced__casadi_solver(OptiAdvanced self) -> Function\n"
		"\n"
		"\n"
		"Get the underlying CasADi solver of the Opti stack.\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced_is_parametric", _wrap_OptiAdvanced_is_parametric, METH_VARARGS, "\n"
		"OptiAdvanced_is_parametric(OptiAdvanced self, MX expr) -> bool\n"
		"\n"
		"\n"
		"return true if expression is only dependant on Opti parameters, not\n"
		"variables\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced_symvar", _wrap_OptiAdvanced_symvar, METH_VARARGS, "\n"
		"OptiAdvanced_symvar(OptiAdvanced self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"OptiAdvanced_symvar(OptiAdvanced self, MX expr) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"OptiAdvanced_symvar(OptiAdvanced self, MX expr, casadi::VariableType type) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"Get symbols present in expression.\n"
		"\n"
		"Returned vector is ordered according to the order of variable()/parameter()\n"
		"calls used to create the variables\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced_canon_expr", _wrap_OptiAdvanced_canon_expr, METH_VARARGS, "\n"
		"OptiAdvanced_canon_expr(OptiAdvanced self, MX expr) -> MetaCon\n"
		"\n"
		"\n"
		"Interpret an expression (for internal use only)\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced_get_meta", _wrap_OptiAdvanced_get_meta, METH_VARARGS, "\n"
		"OptiAdvanced_get_meta(OptiAdvanced self, MX m) -> MetaVar\n"
		"\n"
		"\n"
		"Get meta-data of symbol (for internal use only)\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced_get_meta_con", _wrap_OptiAdvanced_get_meta_con, METH_VARARGS, "\n"
		"OptiAdvanced_get_meta_con(OptiAdvanced self, MX m) -> MetaCon\n"
		"\n"
		"\n"
		"Get meta-data of symbol (for internal use only)\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced_set_meta", _wrap_OptiAdvanced_set_meta, METH_VARARGS, "\n"
		"OptiAdvanced_set_meta(OptiAdvanced self, MX m, MetaVar meta)\n"
		"\n"
		"\n"
		"Set meta-data of an expression.\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced_set_meta_con", _wrap_OptiAdvanced_set_meta_con, METH_VARARGS, "\n"
		"OptiAdvanced_set_meta_con(OptiAdvanced self, MX m, MetaCon meta)\n"
		"\n"
		"\n"
		"Set meta-data of an expression.\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced_assert_active_symbol", _wrap_OptiAdvanced_assert_active_symbol, METH_VARARGS, "OptiAdvanced_assert_active_symbol(OptiAdvanced self, MX m)"},
	 { "OptiAdvanced_active_symvar", _wrap_OptiAdvanced_active_symvar, METH_VARARGS, "OptiAdvanced_active_symvar(OptiAdvanced self, casadi::VariableType type) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"},
	 { "OptiAdvanced_active_values", _wrap_OptiAdvanced_active_values, METH_VARARGS, "OptiAdvanced_active_values(OptiAdvanced self, casadi::VariableType type) -> std::vector< casadi::DM,std::allocator< casadi::DM > >"},
	 { "OptiAdvanced_x_lookup", _wrap_OptiAdvanced_x_lookup, METH_VARARGS, "OptiAdvanced_x_lookup(OptiAdvanced self, casadi_index i) -> MX"},
	 { "OptiAdvanced_g_lookup", _wrap_OptiAdvanced_g_lookup, METH_VARARGS, "OptiAdvanced_g_lookup(OptiAdvanced self, casadi_index i) -> MX"},
	 { "OptiAdvanced_x_describe", _wrap_OptiAdvanced_x_describe, METH_VARARGS, "OptiAdvanced_x_describe(OptiAdvanced self, casadi_index i) -> std::string"},
	 { "OptiAdvanced_g_describe", _wrap_OptiAdvanced_g_describe, METH_VARARGS, "OptiAdvanced_g_describe(OptiAdvanced self, casadi_index i) -> std::string"},
	 { "OptiAdvanced_describe", _wrap_OptiAdvanced_describe, METH_VARARGS, "OptiAdvanced_describe(OptiAdvanced self, MX x, casadi_index indent=0) -> std::string"},
	 { "OptiAdvanced_show_infeasibilities", _wrap_OptiAdvanced_show_infeasibilities, METH_VARARGS, "OptiAdvanced_show_infeasibilities(OptiAdvanced self, double tol=0)"},
	 { "OptiAdvanced_solve_prepare", _wrap_OptiAdvanced_solve_prepare, METH_O, "OptiAdvanced_solve_prepare(OptiAdvanced self)"},
	 { "OptiAdvanced_solve_actual", _wrap_OptiAdvanced_solve_actual, METH_VARARGS, "OptiAdvanced_solve_actual(OptiAdvanced self, casadi::DMDict const & args) -> casadi::DMDict"},
	 { "OptiAdvanced_arg", _wrap_OptiAdvanced_arg, METH_O, "OptiAdvanced_arg(OptiAdvanced self) -> casadi::DMDict"},
	 { "OptiAdvanced_res", _wrap_OptiAdvanced_res, METH_VARARGS, "\n"
		"OptiAdvanced_res(OptiAdvanced self, casadi::DMDict const & res)\n"
		"OptiAdvanced_res(OptiAdvanced self) -> casadi::DMDict\n"
		""},
	 { "OptiAdvanced_constraints", _wrap_OptiAdvanced_constraints, METH_O, "OptiAdvanced_constraints(OptiAdvanced self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"},
	 { "OptiAdvanced_objective", _wrap_OptiAdvanced_objective, METH_O, "OptiAdvanced_objective(OptiAdvanced self) -> MX"},
	 { "OptiAdvanced_baked_copy", _wrap_OptiAdvanced_baked_copy, METH_O, "OptiAdvanced_baked_copy(OptiAdvanced self) -> OptiAdvanced"},
	 { "OptiAdvanced_assert_empty", _wrap_OptiAdvanced_assert_empty, METH_O, "OptiAdvanced_assert_empty(OptiAdvanced self)"},
	 { "OptiAdvanced_bake", _wrap_OptiAdvanced_bake, METH_O, "\n"
		"OptiAdvanced_bake(OptiAdvanced self)\n"
		"\n"
		"\n"
		"Fix the structure of the optimization problem.\n"
		"\n"
		"\n"
		""},
	 { "OptiAdvanced_problem_dirty__get", _wrap_OptiAdvanced_problem_dirty__get, METH_O, "OptiAdvanced_problem_dirty__get(OptiAdvanced self) -> bool"},
	 { "OptiAdvanced_mark_problem_dirty", _wrap_OptiAdvanced_mark_problem_dirty, METH_VARARGS, "OptiAdvanced_mark_problem_dirty(OptiAdvanced self, bool flag=True)"},
	 { "OptiAdvanced_problem_dirty", _wrap_OptiAdvanced_problem_dirty, METH_O, "OptiAdvanced_problem_dirty(OptiAdvanced self) -> bool"},
	 { "OptiAdvanced_solver_dirty__get", _wrap_OptiAdvanced_solver_dirty__get, METH_O, "OptiAdvanced_solver_dirty__get(OptiAdvanced self) -> bool"},
	 { "OptiAdvanced_mark_solver_dirty", _wrap_OptiAdvanced_mark_solver_dirty, METH_VARARGS, "OptiAdvanced_mark_solver_dirty(OptiAdvanced self, bool flag=True)"},
	 { "OptiAdvanced_solver_dirty", _wrap_OptiAdvanced_solver_dirty, METH_O, "OptiAdvanced_solver_dirty(OptiAdvanced self) -> bool"},
	 { "OptiAdvanced_solved__get", _wrap_OptiAdvanced_solved__get, METH_O, "OptiAdvanced_solved__get(OptiAdvanced self) -> bool"},
	 { "OptiAdvanced_mark_solved", _wrap_OptiAdvanced_mark_solved, METH_VARARGS, "OptiAdvanced_mark_solved(OptiAdvanced self, bool flag=True)"},
	 { "OptiAdvanced_solved", _wrap_OptiAdvanced_solved, METH_O, "OptiAdvanced_solved(OptiAdvanced self) -> bool"},
	 { "OptiAdvanced_assert_solved", _wrap_OptiAdvanced_assert_solved, METH_O, "OptiAdvanced_assert_solved(OptiAdvanced self)"},
	 { "OptiAdvanced_assert_baked", _wrap_OptiAdvanced_assert_baked, METH_O, "OptiAdvanced_assert_baked(OptiAdvanced self)"},
	 { "OptiAdvanced_instance_number", _wrap_OptiAdvanced_instance_number, METH_O, "OptiAdvanced_instance_number(OptiAdvanced self) -> casadi_int"},
	 { "new_OptiAdvanced", _wrap_new_OptiAdvanced, METH_VARARGS, "\n"
		"OptiAdvanced(Opti x)\n"
		"new_OptiAdvanced(OptiAdvanced other) -> OptiAdvanced\n"
		""},
	 { "OptiAdvanced_swigregister", OptiAdvanced_swigregister, METH_O, NULL},
	 { "OptiAdvanced_swiginit", OptiAdvanced_swiginit, METH_VARARGS, NULL},
	 { "OptiSol_type_name", _wrap_OptiSol_type_name, METH_O, "OptiSol_type_name(OptiSol self) -> std::string"},
	 { "OptiSol_disp", _wrap_OptiSol_disp, METH_VARARGS, "OptiSol_disp(OptiSol self, bool more=False)"},
	 { "OptiSol_str", _wrap_OptiSol_str, METH_VARARGS, "OptiSol_str(OptiSol self, bool more=False) -> std::string"},
	 { "OptiSol_value", _wrap_OptiSol_value, METH_VARARGS, "\n"
		"OptiSol_value(OptiSol self, MX x, std::vector< casadi::MX,std::allocator< casadi::MX > > const & values=std::vector< casadi::MX >()) -> DM\n"
		"OptiSol_value(OptiSol self, DM x, std::vector< casadi::MX,std::allocator< casadi::MX > > const & values=std::vector< casadi::MX >()) -> DM\n"
		"OptiSol_value(OptiSol self, SX x, std::vector< casadi::MX,std::allocator< casadi::MX > > const & values=std::vector< casadi::MX >()) -> DM\n"
		"\n"
		"\n"
		"Obtain value of expression at the current value\n"
		"\n"
		"In regular mode, teh current value is the converged solution In debug mode,\n"
		"the value can be non-converged\n"
		"\n"
		"Parameters:\n"
		"-----------\n"
		"\n"
		"values:  Optional assignment expressions (e.g. x==3) to overrule the current\n"
		"value\n"
		"\n"
		"\n"
		""},
	 { "OptiSol_value_variables", _wrap_OptiSol_value_variables, METH_O, "\n"
		"OptiSol_value_variables(OptiSol self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >\n"
		"\n"
		"\n"
		"get assignment expressions for the optimal solution\n"
		"\n"
		"\n"
		""},
	 { "OptiSol_value_parameters", _wrap_OptiSol_value_parameters, METH_O, "OptiSol_value_parameters(OptiSol self) -> std::vector< casadi::MX,std::allocator< casadi::MX > >"},
	 { "OptiSol_stats", _wrap_OptiSol_stats, METH_O, "\n"
		"OptiSol_stats(OptiSol self) -> casadi::Dict\n"
		"\n"
		"\n"
		"Get statistics.\n"
		"\n"
		"nlpsol stats are passed as-is. No stability can be guaranteed about this\n"
		"part of the API\n"
		"\n"
		"\n"
		""},
	 { "OptiSol__opti", _wrap_OptiSol__opti, METH_O, "OptiSol__opti(OptiSol self) -> Opti"},
	 { "new_OptiSol", _wrap_new_OptiSol, METH_VARARGS, NULL},
	 { "delete_OptiSol", _wrap_delete_OptiSol, METH_O, "delete_OptiSol(OptiSol self)"},
	 { "OptiSol_swigregister", OptiSol_swigregister, METH_O, NULL},
	 { "OptiSol_swiginit", OptiSol_swiginit, METH_VARARGS, NULL},
	 { NULL, NULL, 0, NULL }
};

static PyMethodDef SwigMethods_proxydocs[] = {
	 { NULL, NULL, 0, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_tTo_p_casadi__SparsityInterfaceCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SparsityInterfaceCommon *)  ((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) x));
}
static void *_p_casadi__GenericMatrixT_casadi__MX_tTo_p_casadi__SparsityInterfaceCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SparsityInterfaceCommon *)  ((casadi::GenericMatrix< casadi::MX > *) x));
}
static void *_p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__SparsityInterfaceCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SparsityInterfaceCommon *) (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) ((casadi::Matrix< casadi::SXElem > *) x));
}
static void *_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_tTo_p_casadi__SparsityInterfaceCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SparsityInterfaceCommon *)  ((casadi::GenericMatrix< casadi::Matrix< double > > *) x));
}
static void *_p_casadi__SparsityTo_p_casadi__SparsityInterfaceCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SparsityInterfaceCommon *)  ((casadi::Sparsity *) x));
}
static void *_p_casadi__MatrixT_double_tTo_p_casadi__SparsityInterfaceCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SparsityInterfaceCommon *) (casadi::GenericMatrix< casadi::Matrix< double > > *) ((casadi::Matrix< double > *) x));
}
static void *_p_casadi__MXTo_p_casadi__SparsityInterfaceCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SparsityInterfaceCommon *) (casadi::GenericMatrix< casadi::MX > *) ((casadi::MX *) x));
}
static void *_p_casadi__SliceTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Slice *) x));
}
static void *_p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Matrix< casadi::SXElem > *) x));
}
static void *_p_casadi__OptiAdvancedTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *) (casadi::Opti *) ((casadi::OptiAdvanced *) x));
}
static void *_p_casadi__SparsityTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Sparsity *) x));
}
static void *_p_casadi__FunctionTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Function *) x));
}
static void *_p_casadi__OptiTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Opti *) x));
}
static void *_p_casadi__CallbackTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *) (casadi::Function *) ((casadi::Callback *) x));
}
static void *_p_casadi__MatrixT_double_tTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Matrix< double > *) x));
}
static void *_p_casadi__OptiSolTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::OptiSol *) x));
}
static void *_p_casadi__DaeBuilderTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::DaeBuilder *) x));
}
static void *_p_casadi__VariableTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Variable *) x));
}
static void *_p_casadi__NlpBuilderTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::NlpBuilder *) x));
}
static void *_p_casadi__GenericTypeTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::GenericType *) x));
}
static void *_p_casadi__MXTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::MX *) x));
}
static void *_p_casadi__LinsolTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Linsol *) x));
}
static void *_p_casadi__ImporterTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Importer *) x));
}
static void *_p_casadi__MatrixT_long_long_tTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::Matrix< long long > *) x));
}
static void *_p_casadi__XmlFileTo_p_casadi__PrintableCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::PrintableCommon *)  ((casadi::XmlFile *) x));
}
static void *_p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__MatrixCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::MatrixCommon *)  ((casadi::Matrix< casadi::SXElem > *) x));
}
static void *_p_casadi__MatrixT_long_long_tTo_p_casadi__MatrixCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::MatrixCommon *)  ((casadi::Matrix< long long > *) x));
}
static void *_p_casadi__MatrixT_double_tTo_p_casadi__MatrixCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::MatrixCommon *)  ((casadi::Matrix< double > *) x));
}
static void *_p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__GenericExpressionCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericExpressionCommon *)  ((casadi::Matrix< casadi::SXElem > *) x));
}
static void *_p_casadi__MatrixT_long_long_tTo_p_casadi__GenericExpressionCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericExpressionCommon *)  ((casadi::Matrix< long long > *) x));
}
static void *_p_casadi__MatrixT_double_tTo_p_casadi__GenericExpressionCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericExpressionCommon *)  ((casadi::Matrix< double > *) x));
}
static void *_p_casadi__MXTo_p_casadi__GenericExpressionCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericExpressionCommon *)  ((casadi::MX *) x));
}
static void *_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_tTo_p_casadi__GenericMatrixCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericMatrixCommon *)  ((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) x));
}
static void *_p_casadi__GenericMatrixT_casadi__MX_tTo_p_casadi__GenericMatrixCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericMatrixCommon *)  ((casadi::GenericMatrix< casadi::MX > *) x));
}
static void *_p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__GenericMatrixCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericMatrixCommon *) (casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *) ((casadi::Matrix< casadi::SXElem > *) x));
}
static void *_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_tTo_p_casadi__GenericMatrixCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericMatrixCommon *)  ((casadi::GenericMatrix< casadi::Matrix< double > > *) x));
}
static void *_p_casadi__MatrixT_double_tTo_p_casadi__GenericMatrixCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericMatrixCommon *) (casadi::GenericMatrix< casadi::Matrix< double > > *) ((casadi::Matrix< double > *) x));
}
static void *_p_casadi__MXTo_p_casadi__GenericMatrixCommon(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericMatrixCommon *) (casadi::GenericMatrix< casadi::MX > *) ((casadi::MX *) x));
}
static void *_p_casadi__OptiAdvancedTo_p_casadi__Opti(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::Opti *)  ((casadi::OptiAdvanced *) x));
}
static void *_p_casadi__CallbackTo_p_casadi__Function(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::Function *)  ((casadi::Callback *) x));
}
static void *_p_casadi__OptiTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *)  ((casadi::Opti *) x));
}
static void *_p_casadi__FunctionTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *)  ((casadi::Function *) x));
}
static void *_p_casadi__ImporterTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *)  ((casadi::Importer *) x));
}
static void *_p_casadi__SparsityTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *)  ((casadi::Sparsity *) x));
}
static void *_p_casadi__MXTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *)  ((casadi::MX *) x));
}
static void *_p_casadi__CallbackTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *) (casadi::Function *) ((casadi::Callback *) x));
}
static void *_p_casadi__XmlFileTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *)  ((casadi::XmlFile *) x));
}
static void *_p_casadi__WeakRefTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *)  ((casadi::WeakRef *) x));
}
static void *_p_casadi__LinsolTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *)  ((casadi::Linsol *) x));
}
static void *_p_casadi__OptiAdvancedTo_p_casadi__SharedObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SharedObject *) (casadi::Opti *) ((casadi::OptiAdvanced *) x));
}
static void *_p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *)  ((casadi::Matrix< casadi::SXElem > *) x));
}
static void *_p_casadi__StringDeserializerTo_p_casadi__DeserializerBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::DeserializerBase *)  ((casadi::StringDeserializer *) x));
}
static void *_p_casadi__FileDeserializerTo_p_casadi__DeserializerBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::DeserializerBase *)  ((casadi::FileDeserializer *) x));
}
static void *_p_casadi__StringSerializerTo_p_casadi__SerializerBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SerializerBase *)  ((casadi::StringSerializer *) x));
}
static void *_p_casadi__FileSerializerTo_p_casadi__SerializerBase(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::SerializerBase *)  ((casadi::FileSerializer *) x));
}
static void *_p_casadi__MXTo_p_casadi__GenericMatrixT_casadi__MX_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericMatrix< casadi::MX > *)  ((casadi::MX *) x));
}
static void *_p_casadi__MatrixT_double_tTo_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::GenericMatrix< casadi::Matrix< double > > *)  ((casadi::Matrix< double > *) x));
}
static void *_p_casadi__MetaConTo_p_casadi__IndexAbstraction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::IndexAbstraction *)  ((casadi::MetaCon *) x));
}
static void *_p_casadi__MetaVarTo_p_casadi__IndexAbstraction(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((casadi::IndexAbstraction *)  ((casadi::MetaVar *) x));
}
static swig_type_info _swigt__p_AuxOut = {"_p_AuxOut", "AuxOut *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Dict = {"_p_Dict", "Dict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MXDict = {"_p_MXDict", "MXDict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_allocator_type = {"_p_allocator_type", "allocator_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__Callback = {"_p_casadi__Callback", "casadi::Callback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__CasadiMeta = {"_p_casadi__CasadiMeta", "casadi::CasadiMeta *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__CodeGenerator = {"_p_casadi__CodeGenerator", "casadi::CodeGenerator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__DaeBuilder = {"_p_casadi__DaeBuilder", "casadi::DaeBuilder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__DeserializerBase = {"_p_casadi__DeserializerBase", "casadi::DeserializerBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__DeserializingStream = {"_p_casadi__DeserializingStream", "casadi::DeserializingStream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__FileDeserializer = {"_p_casadi__FileDeserializer", "casadi::FileDeserializer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__FileSerializer = {"_p_casadi__FileSerializer", "casadi::FileSerializer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__Function = {"_p_casadi__Function", "casadi::Function *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__FunctionBuffer = {"_p_casadi__FunctionBuffer", "casadi::FunctionBuffer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__GenericExpressionCommon = {"_p_casadi__GenericExpressionCommon", "casadi::GenericExpressionCommon *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__MatrixT_long_long_t = {"_p_casadi__MatrixT_long_long_t", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_casadi__GenericMatrixCommon = {"_p_casadi__GenericMatrixCommon", "casadi::GenericMatrixCommon *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__GenericMatrixT_casadi__MX_t = {"_p_casadi__GenericMatrixT_casadi__MX_t", "casadi::GenericMatrix< casadi::MX > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t = {"_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t", "casadi::GenericMatrix< casadi::Matrix< casadi::SXElem > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t = {"_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t", "casadi::GenericMatrix< casadi::Matrix< double > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__GenericType = {"_p_casadi__GenericType", "casadi::GenericType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__GlobalOptions = {"_p_casadi__GlobalOptions", "casadi::GlobalOptions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__Importer = {"_p_casadi__Importer", "casadi::Importer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__IndexAbstraction = {"_p_casadi__IndexAbstraction", "casadi::IndexAbstraction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__Linsol = {"_p_casadi__Linsol", "casadi::Linsol *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__MX = {"_p_casadi__MX", "casadi::MX *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__MatrixCommon = {"_p_casadi__MatrixCommon", "casadi::MatrixCommon *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__MatrixT_casadi__SXElem_t = {"_p_casadi__MatrixT_casadi__SXElem_t", "casadi::Matrix< casadi::SXElem > *|casadi::SX *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__MatrixT_double_t = {"_p_casadi__MatrixT_double_t", "casadi::DM *|casadi::Matrix< double > *|casadi::native_DM *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__MetaCon = {"_p_casadi__MetaCon", "casadi::MetaCon *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__MetaVar = {"_p_casadi__MetaVar", "casadi::MetaVar *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__NlpBuilder = {"_p_casadi__NlpBuilder", "casadi::NlpBuilder *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__Opti = {"_p_casadi__Opti", "casadi::Opti *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__OptiAdvanced = {"_p_casadi__OptiAdvanced", "casadi::OptiAdvanced *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__OptiCallback = {"_p_casadi__OptiCallback", "casadi::OptiCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__OptiSol = {"_p_casadi__OptiSol", "casadi::OptiSol *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__PrintableCommon = {"_p_casadi__PrintableCommon", "casadi::PrintableCommon *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__SXElem = {"_p_casadi__SXElem", "casadi::SXElem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__SerializerBase = {"_p_casadi__SerializerBase", "casadi::SerializerBase *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__SerializingStream = {"_p_casadi__SerializingStream", "casadi::SerializingStream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__SharedObject = {"_p_casadi__SharedObject", "casadi::SharedObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__SharedObjectInternal = {"_p_casadi__SharedObjectInternal", "casadi::SharedObjectInternal *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__Slice = {"_p_casadi__Slice", "casadi::Slice *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__Sparsity = {"_p_casadi__Sparsity", "casadi::Sparsity *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__SparsityInterfaceCommon = {"_p_casadi__SparsityInterfaceCommon", "casadi::SparsityInterfaceCommon *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__StringDeserializer = {"_p_casadi__StringDeserializer", "casadi::StringDeserializer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__StringSerializer = {"_p_casadi__StringSerializer", "casadi::StringSerializer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__Variable = {"_p_casadi__Variable", "casadi::Variable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__WeakRef = {"_p_casadi__WeakRef", "casadi::WeakRef *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_casadi__XmlFile = {"_p_casadi__XmlFile", "casadi::XmlFile *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_const_reference = {"_p_const_reference", "const_reference *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_double = {"_p_double", "double *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_first_type = {"_p_first_type", "first_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_key_type = {"_p_key_type", "key_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long_long = {"_p_long_long", "casadi_index *|long long *|casadi_int *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_mapped_type = {"_p_mapped_type", "mapped_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_double = {"_p_p_double", "double **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_second_type = {"_p_second_type", "second_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__initializer_listT_casadi__MX_t = {"_p_std__initializer_listT_casadi__MX_t", "casadi::MXIList *|std::initializer_list< casadi::MX > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__initializer_listT_casadi__MatrixT_casadi__SXElem_t_t = {"_p_std__initializer_listT_casadi__MatrixT_casadi__SXElem_t_t", "std::initializer_list< casadi::Matrix< casadi::SXElem > > *|casadi::SXIList *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__invalid_argument = {"_p_std__invalid_argument", "std::invalid_argument *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__istream = {"_p_std__istream", "std::istream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__string_casadi__GenericType_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__GenericType_t_t_t = {"_p_std__mapT_std__string_casadi__GenericType_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__GenericType_t_t_t", "std::map< std::string,casadi::GenericType,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::GenericType > > > *|casadi::Dict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__string_casadi__MX_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MX_t_t_t = {"_p_std__mapT_std__string_casadi__MX_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MX_t_t_t", "std::map< std::string,casadi::MX,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::MX > > > *|casadi::MXDict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__string_casadi__MatrixT_casadi__SXElem_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_casadi__SXElem_t_t_t_t = {"_p_std__mapT_std__string_casadi__MatrixT_casadi__SXElem_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_casadi__SXElem_t_t_t_t", "std::map< std::string,casadi::Matrix< casadi::SXElem >,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::Matrix< casadi::SXElem > > > > *|casadi::SXDict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__string_casadi__MatrixT_double_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_double_t_t_t_t = {"_p_std__mapT_std__string_casadi__MatrixT_double_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_double_t_t_t_t", "std::map< std::string,casadi::Matrix< double >,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::Matrix< double > > > > *|casadi::DMDict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__mapT_std__string_casadi__Sparsity_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__Sparsity_t_t_t = {"_p_std__mapT_std__string_casadi__Sparsity_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__Sparsity_t_t_t", "std::map< std::string,casadi::Sparsity,std::less< std::string >,std::allocator< std::pair< std::string const,casadi::Sparsity > > > *|casadi::SpDict *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__ostream = {"_p_std__ostream", "std::ostream *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__pairT_casadi__Slice_casadi__Slice_t = {"_p_std__pairT_casadi__Slice_casadi__Slice_t", "std::pair< casadi::Slice,casadi::Slice > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__size_t = {"_p_std__size_t", "std::size_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__string = {"_p_std__string", "std::string *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t = {"_p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t", "std::vector< casadi::Linsol,std::allocator< casadi::Linsol > > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t = {"_p_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t", "std::vector< casadi::MX,std::allocator< casadi::MX > > *|casadi::MXVector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t = {"_p_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t", "std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > *|casadi::SXVector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t = {"_p_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t", "std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > *|casadi::DMVector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_std__allocatorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_t_t = {"_p_std__vectorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_std__allocatorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_t_t", "std::vector< std::vector< casadi::MX,std::allocator< casadi::MX > >,std::allocator< std::vector< casadi::MX,std::allocator< casadi::MX > > > > *|casadi::MXVectorVector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_t_t = {"_p_std__vectorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_t_t", "std::vector< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > >,std::allocator< std::vector< casadi::Matrix< casadi::SXElem >,std::allocator< casadi::Matrix< casadi::SXElem > > > > > *|casadi::SXVectorVector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_t_t = {"_p_std__vectorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_t_t", "std::vector< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > >,std::allocator< std::vector< casadi::Matrix< double >,std::allocator< casadi::Matrix< double > > > > > *|casadi::DMVectorVector *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_swig__SwigPyIterator = {"_p_swig__SwigPyIterator", "swig::SwigPyIterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_AuxOut,
  &_swigt__p_Dict,
  &_swigt__p_MXDict,
  &_swigt__p_allocator_type,
  &_swigt__p_casadi__Callback,
  &_swigt__p_casadi__CasadiMeta,
  &_swigt__p_casadi__CodeGenerator,
  &_swigt__p_casadi__DaeBuilder,
  &_swigt__p_casadi__DeserializerBase,
  &_swigt__p_casadi__DeserializingStream,
  &_swigt__p_casadi__FileDeserializer,
  &_swigt__p_casadi__FileSerializer,
  &_swigt__p_casadi__Function,
  &_swigt__p_casadi__FunctionBuffer,
  &_swigt__p_casadi__GenericExpressionCommon,
  &_swigt__p_casadi__GenericMatrixCommon,
  &_swigt__p_casadi__GenericMatrixT_casadi__MX_t,
  &_swigt__p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t,
  &_swigt__p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t,
  &_swigt__p_casadi__GenericType,
  &_swigt__p_casadi__GlobalOptions,
  &_swigt__p_casadi__Importer,
  &_swigt__p_casadi__IndexAbstraction,
  &_swigt__p_casadi__Linsol,
  &_swigt__p_casadi__MX,
  &_swigt__p_casadi__MatrixCommon,
  &_swigt__p_casadi__MatrixT_casadi__SXElem_t,
  &_swigt__p_casadi__MatrixT_double_t,
  &_swigt__p_casadi__MatrixT_long_long_t,
  &_swigt__p_casadi__MetaCon,
  &_swigt__p_casadi__MetaVar,
  &_swigt__p_casadi__NlpBuilder,
  &_swigt__p_casadi__Opti,
  &_swigt__p_casadi__OptiAdvanced,
  &_swigt__p_casadi__OptiCallback,
  &_swigt__p_casadi__OptiSol,
  &_swigt__p_casadi__PrintableCommon,
  &_swigt__p_casadi__SXElem,
  &_swigt__p_casadi__SerializerBase,
  &_swigt__p_casadi__SerializingStream,
  &_swigt__p_casadi__SharedObject,
  &_swigt__p_casadi__SharedObjectInternal,
  &_swigt__p_casadi__Slice,
  &_swigt__p_casadi__Sparsity,
  &_swigt__p_casadi__SparsityInterfaceCommon,
  &_swigt__p_casadi__StringDeserializer,
  &_swigt__p_casadi__StringSerializer,
  &_swigt__p_casadi__Variable,
  &_swigt__p_casadi__WeakRef,
  &_swigt__p_casadi__XmlFile,
  &_swigt__p_char,
  &_swigt__p_const_reference,
  &_swigt__p_difference_type,
  &_swigt__p_double,
  &_swigt__p_first_type,
  &_swigt__p_key_type,
  &_swigt__p_long_long,
  &_swigt__p_mapped_type,
  &_swigt__p_p_double,
  &_swigt__p_second_type,
  &_swigt__p_size_type,
  &_swigt__p_std__initializer_listT_casadi__MX_t,
  &_swigt__p_std__initializer_listT_casadi__MatrixT_casadi__SXElem_t_t,
  &_swigt__p_std__invalid_argument,
  &_swigt__p_std__istream,
  &_swigt__p_std__mapT_std__string_casadi__GenericType_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__GenericType_t_t_t,
  &_swigt__p_std__mapT_std__string_casadi__MX_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MX_t_t_t,
  &_swigt__p_std__mapT_std__string_casadi__MatrixT_casadi__SXElem_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_casadi__SXElem_t_t_t_t,
  &_swigt__p_std__mapT_std__string_casadi__MatrixT_double_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_double_t_t_t_t,
  &_swigt__p_std__mapT_std__string_casadi__Sparsity_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__Sparsity_t_t_t,
  &_swigt__p_std__ostream,
  &_swigt__p_std__pairT_casadi__Slice_casadi__Slice_t,
  &_swigt__p_std__size_t,
  &_swigt__p_std__string,
  &_swigt__p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t,
  &_swigt__p_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t,
  &_swigt__p_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t,
  &_swigt__p_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t,
  &_swigt__p_std__vectorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_std__allocatorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_t_t,
  &_swigt__p_std__vectorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_t_t,
  &_swigt__p_std__vectorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_t_t,
  &_swigt__p_swig__SwigPyIterator,
  &_swigt__p_value_type,
};

static swig_cast_info _swigc__p_AuxOut[] = {  {&_swigt__p_AuxOut, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Dict[] = {  {&_swigt__p_Dict, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MXDict[] = {  {&_swigt__p_MXDict, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_allocator_type[] = {  {&_swigt__p_allocator_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__Callback[] = {  {&_swigt__p_casadi__Callback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__CasadiMeta[] = {  {&_swigt__p_casadi__CasadiMeta, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__CodeGenerator[] = {  {&_swigt__p_casadi__CodeGenerator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__DaeBuilder[] = {  {&_swigt__p_casadi__DaeBuilder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__DeserializerBase[] = {  {&_swigt__p_casadi__DeserializerBase, 0, 0, 0},  {&_swigt__p_casadi__StringDeserializer, _p_casadi__StringDeserializerTo_p_casadi__DeserializerBase, 0, 0},  {&_swigt__p_casadi__FileDeserializer, _p_casadi__FileDeserializerTo_p_casadi__DeserializerBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__DeserializingStream[] = {  {&_swigt__p_casadi__DeserializingStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__FileDeserializer[] = {  {&_swigt__p_casadi__FileDeserializer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__FileSerializer[] = {  {&_swigt__p_casadi__FileSerializer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__Function[] = {  {&_swigt__p_casadi__Function, 0, 0, 0},  {&_swigt__p_casadi__Callback, _p_casadi__CallbackTo_p_casadi__Function, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__FunctionBuffer[] = {  {&_swigt__p_casadi__FunctionBuffer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__MatrixT_long_long_t[] = {{&_swigt__p_casadi__MatrixT_long_long_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__GenericExpressionCommon[] = {  {&_swigt__p_casadi__GenericExpressionCommon, 0, 0, 0},  {&_swigt__p_casadi__MatrixT_double_t, _p_casadi__MatrixT_double_tTo_p_casadi__GenericExpressionCommon, 0, 0},  {&_swigt__p_casadi__MX, _p_casadi__MXTo_p_casadi__GenericExpressionCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_casadi__SXElem_t, _p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__GenericExpressionCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_long_long_t, _p_casadi__MatrixT_long_long_tTo_p_casadi__GenericExpressionCommon, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__GenericMatrixCommon[] = {  {&_swigt__p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, _p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_tTo_p_casadi__GenericMatrixCommon, 0, 0},  {&_swigt__p_casadi__GenericMatrixT_casadi__MX_t, _p_casadi__GenericMatrixT_casadi__MX_tTo_p_casadi__GenericMatrixCommon, 0, 0},  {&_swigt__p_casadi__GenericMatrixCommon, 0, 0, 0},  {&_swigt__p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, _p_casadi__GenericMatrixT_casadi__MatrixT_double_t_tTo_p_casadi__GenericMatrixCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_double_t, _p_casadi__MatrixT_double_tTo_p_casadi__GenericMatrixCommon, 0, 0},  {&_swigt__p_casadi__MX, _p_casadi__MXTo_p_casadi__GenericMatrixCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_casadi__SXElem_t, _p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__GenericMatrixCommon, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__GenericMatrixT_casadi__MX_t[] = {  {&_swigt__p_casadi__GenericMatrixT_casadi__MX_t, 0, 0, 0},  {&_swigt__p_casadi__MX, _p_casadi__MXTo_p_casadi__GenericMatrixT_casadi__MX_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t[] = {  {&_swigt__p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0, 0, 0},  {&_swigt__p_casadi__MatrixT_casadi__SXElem_t, _p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t[] = {  {&_swigt__p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0, 0, 0},  {&_swigt__p_casadi__MatrixT_double_t, _p_casadi__MatrixT_double_tTo_p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__GenericType[] = {  {&_swigt__p_casadi__GenericType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__GlobalOptions[] = {  {&_swigt__p_casadi__GlobalOptions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__Importer[] = {  {&_swigt__p_casadi__Importer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__IndexAbstraction[] = {  {&_swigt__p_casadi__IndexAbstraction, 0, 0, 0},  {&_swigt__p_casadi__MetaCon, _p_casadi__MetaConTo_p_casadi__IndexAbstraction, 0, 0},  {&_swigt__p_casadi__MetaVar, _p_casadi__MetaVarTo_p_casadi__IndexAbstraction, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__Linsol[] = {  {&_swigt__p_casadi__Linsol, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__MX[] = {  {&_swigt__p_casadi__MX, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__MatrixCommon[] = {  {&_swigt__p_casadi__MatrixCommon, 0, 0, 0},  {&_swigt__p_casadi__MatrixT_double_t, _p_casadi__MatrixT_double_tTo_p_casadi__MatrixCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_casadi__SXElem_t, _p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__MatrixCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_long_long_t, _p_casadi__MatrixT_long_long_tTo_p_casadi__MatrixCommon, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__MatrixT_casadi__SXElem_t[] = {  {&_swigt__p_casadi__MatrixT_casadi__SXElem_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__MatrixT_double_t[] = {  {&_swigt__p_casadi__MatrixT_double_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__MetaCon[] = {  {&_swigt__p_casadi__MetaCon, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__MetaVar[] = {  {&_swigt__p_casadi__MetaVar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__NlpBuilder[] = {  {&_swigt__p_casadi__NlpBuilder, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__Opti[] = {  {&_swigt__p_casadi__Opti, 0, 0, 0},  {&_swigt__p_casadi__OptiAdvanced, _p_casadi__OptiAdvancedTo_p_casadi__Opti, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__OptiAdvanced[] = {  {&_swigt__p_casadi__OptiAdvanced, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__OptiCallback[] = {  {&_swigt__p_casadi__OptiCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__OptiSol[] = {  {&_swigt__p_casadi__OptiSol, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__PrintableCommon[] = {  {&_swigt__p_casadi__MatrixT_long_long_t, _p_casadi__MatrixT_long_long_tTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_casadi__SXElem_t, _p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__Opti, _p_casadi__OptiTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__MX, _p_casadi__MXTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__OptiAdvanced, _p_casadi__OptiAdvancedTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__Slice, _p_casadi__SliceTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__Sparsity, _p_casadi__SparsityTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_double_t, _p_casadi__MatrixT_double_tTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__Function, _p_casadi__FunctionTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__PrintableCommon, 0, 0, 0},  {&_swigt__p_casadi__Callback, _p_casadi__CallbackTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__OptiSol, _p_casadi__OptiSolTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__Variable, _p_casadi__VariableTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__NlpBuilder, _p_casadi__NlpBuilderTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__DaeBuilder, _p_casadi__DaeBuilderTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__Linsol, _p_casadi__LinsolTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__GenericType, _p_casadi__GenericTypeTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__Importer, _p_casadi__ImporterTo_p_casadi__PrintableCommon, 0, 0},  {&_swigt__p_casadi__XmlFile, _p_casadi__XmlFileTo_p_casadi__PrintableCommon, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__SXElem[] = {  {&_swigt__p_casadi__SXElem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__SerializerBase[] = {  {&_swigt__p_casadi__SerializerBase, 0, 0, 0},  {&_swigt__p_casadi__StringSerializer, _p_casadi__StringSerializerTo_p_casadi__SerializerBase, 0, 0},  {&_swigt__p_casadi__FileSerializer, _p_casadi__FileSerializerTo_p_casadi__SerializerBase, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__SerializingStream[] = {  {&_swigt__p_casadi__SerializingStream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__SharedObject[] = {  {&_swigt__p_casadi__Linsol, _p_casadi__LinsolTo_p_casadi__SharedObject, 0, 0},  {&_swigt__p_casadi__Function, _p_casadi__FunctionTo_p_casadi__SharedObject, 0, 0},  {&_swigt__p_casadi__SharedObject, 0, 0, 0},  {&_swigt__p_casadi__Importer, _p_casadi__ImporterTo_p_casadi__SharedObject, 0, 0},  {&_swigt__p_casadi__MX, _p_casadi__MXTo_p_casadi__SharedObject, 0, 0},  {&_swigt__p_casadi__Opti, _p_casadi__OptiTo_p_casadi__SharedObject, 0, 0},  {&_swigt__p_casadi__Sparsity, _p_casadi__SparsityTo_p_casadi__SharedObject, 0, 0},  {&_swigt__p_casadi__Callback, _p_casadi__CallbackTo_p_casadi__SharedObject, 0, 0},  {&_swigt__p_casadi__XmlFile, _p_casadi__XmlFileTo_p_casadi__SharedObject, 0, 0},  {&_swigt__p_casadi__OptiAdvanced, _p_casadi__OptiAdvancedTo_p_casadi__SharedObject, 0, 0},  {&_swigt__p_casadi__WeakRef, _p_casadi__WeakRefTo_p_casadi__SharedObject, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__SharedObjectInternal[] = {  {&_swigt__p_casadi__SharedObjectInternal, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__Slice[] = {  {&_swigt__p_casadi__Slice, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__Sparsity[] = {  {&_swigt__p_casadi__Sparsity, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__SparsityInterfaceCommon[] = {  {&_swigt__p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t, _p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_tTo_p_casadi__SparsityInterfaceCommon, 0, 0},  {&_swigt__p_casadi__GenericMatrixT_casadi__MX_t, _p_casadi__GenericMatrixT_casadi__MX_tTo_p_casadi__SparsityInterfaceCommon, 0, 0},  {&_swigt__p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t, _p_casadi__GenericMatrixT_casadi__MatrixT_double_t_tTo_p_casadi__SparsityInterfaceCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_double_t, _p_casadi__MatrixT_double_tTo_p_casadi__SparsityInterfaceCommon, 0, 0},  {&_swigt__p_casadi__SparsityInterfaceCommon, 0, 0, 0},  {&_swigt__p_casadi__MX, _p_casadi__MXTo_p_casadi__SparsityInterfaceCommon, 0, 0},  {&_swigt__p_casadi__MatrixT_casadi__SXElem_t, _p_casadi__MatrixT_casadi__SXElem_tTo_p_casadi__SparsityInterfaceCommon, 0, 0},  {&_swigt__p_casadi__Sparsity, _p_casadi__SparsityTo_p_casadi__SparsityInterfaceCommon, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__StringDeserializer[] = {  {&_swigt__p_casadi__StringDeserializer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__StringSerializer[] = {  {&_swigt__p_casadi__StringSerializer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__Variable[] = {  {&_swigt__p_casadi__Variable, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__WeakRef[] = {  {&_swigt__p_casadi__WeakRef, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_casadi__XmlFile[] = {  {&_swigt__p_casadi__XmlFile, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_const_reference[] = {  {&_swigt__p_const_reference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_double[] = {  {&_swigt__p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_first_type[] = {  {&_swigt__p_first_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_key_type[] = {  {&_swigt__p_key_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_mapped_type[] = {  {&_swigt__p_mapped_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_double[] = {  {&_swigt__p_p_double, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_second_type[] = {  {&_swigt__p_second_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__initializer_listT_casadi__MX_t[] = {  {&_swigt__p_std__initializer_listT_casadi__MX_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__initializer_listT_casadi__MatrixT_casadi__SXElem_t_t[] = {  {&_swigt__p_std__initializer_listT_casadi__MatrixT_casadi__SXElem_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__invalid_argument[] = {  {&_swigt__p_std__invalid_argument, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__istream[] = {  {&_swigt__p_std__istream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__string_casadi__GenericType_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__GenericType_t_t_t[] = {  {&_swigt__p_std__mapT_std__string_casadi__GenericType_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__GenericType_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__string_casadi__MX_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MX_t_t_t[] = {  {&_swigt__p_std__mapT_std__string_casadi__MX_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MX_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__string_casadi__MatrixT_casadi__SXElem_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_casadi__SXElem_t_t_t_t[] = {  {&_swigt__p_std__mapT_std__string_casadi__MatrixT_casadi__SXElem_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_casadi__SXElem_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__string_casadi__MatrixT_double_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_double_t_t_t_t[] = {  {&_swigt__p_std__mapT_std__string_casadi__MatrixT_double_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_double_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__mapT_std__string_casadi__Sparsity_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__Sparsity_t_t_t[] = {  {&_swigt__p_std__mapT_std__string_casadi__Sparsity_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__Sparsity_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__ostream[] = {  {&_swigt__p_std__ostream, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__pairT_casadi__Slice_casadi__Slice_t[] = {  {&_swigt__p_std__pairT_casadi__Slice_casadi__Slice_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__size_t[] = {  {&_swigt__p_std__size_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__string[] = {  {&_swigt__p_std__string, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t[] = {  {&_swigt__p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t[] = {  {&_swigt__p_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t[] = {  {&_swigt__p_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t[] = {  {&_swigt__p_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_std__allocatorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_std__allocatorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_t_t[] = {  {&_swigt__p_std__vectorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_swig__SwigPyIterator[] = {  {&_swigt__p_swig__SwigPyIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_AuxOut,
  _swigc__p_Dict,
  _swigc__p_MXDict,
  _swigc__p_allocator_type,
  _swigc__p_casadi__Callback,
  _swigc__p_casadi__CasadiMeta,
  _swigc__p_casadi__CodeGenerator,
  _swigc__p_casadi__DaeBuilder,
  _swigc__p_casadi__DeserializerBase,
  _swigc__p_casadi__DeserializingStream,
  _swigc__p_casadi__FileDeserializer,
  _swigc__p_casadi__FileSerializer,
  _swigc__p_casadi__Function,
  _swigc__p_casadi__FunctionBuffer,
  _swigc__p_casadi__GenericExpressionCommon,
  _swigc__p_casadi__GenericMatrixCommon,
  _swigc__p_casadi__GenericMatrixT_casadi__MX_t,
  _swigc__p_casadi__GenericMatrixT_casadi__MatrixT_casadi__SXElem_t_t,
  _swigc__p_casadi__GenericMatrixT_casadi__MatrixT_double_t_t,
  _swigc__p_casadi__GenericType,
  _swigc__p_casadi__GlobalOptions,
  _swigc__p_casadi__Importer,
  _swigc__p_casadi__IndexAbstraction,
  _swigc__p_casadi__Linsol,
  _swigc__p_casadi__MX,
  _swigc__p_casadi__MatrixCommon,
  _swigc__p_casadi__MatrixT_casadi__SXElem_t,
  _swigc__p_casadi__MatrixT_double_t,
  _swigc__p_casadi__MatrixT_long_long_t,
  _swigc__p_casadi__MetaCon,
  _swigc__p_casadi__MetaVar,
  _swigc__p_casadi__NlpBuilder,
  _swigc__p_casadi__Opti,
  _swigc__p_casadi__OptiAdvanced,
  _swigc__p_casadi__OptiCallback,
  _swigc__p_casadi__OptiSol,
  _swigc__p_casadi__PrintableCommon,
  _swigc__p_casadi__SXElem,
  _swigc__p_casadi__SerializerBase,
  _swigc__p_casadi__SerializingStream,
  _swigc__p_casadi__SharedObject,
  _swigc__p_casadi__SharedObjectInternal,
  _swigc__p_casadi__Slice,
  _swigc__p_casadi__Sparsity,
  _swigc__p_casadi__SparsityInterfaceCommon,
  _swigc__p_casadi__StringDeserializer,
  _swigc__p_casadi__StringSerializer,
  _swigc__p_casadi__Variable,
  _swigc__p_casadi__WeakRef,
  _swigc__p_casadi__XmlFile,
  _swigc__p_char,
  _swigc__p_const_reference,
  _swigc__p_difference_type,
  _swigc__p_double,
  _swigc__p_first_type,
  _swigc__p_key_type,
  _swigc__p_long_long,
  _swigc__p_mapped_type,
  _swigc__p_p_double,
  _swigc__p_second_type,
  _swigc__p_size_type,
  _swigc__p_std__initializer_listT_casadi__MX_t,
  _swigc__p_std__initializer_listT_casadi__MatrixT_casadi__SXElem_t_t,
  _swigc__p_std__invalid_argument,
  _swigc__p_std__istream,
  _swigc__p_std__mapT_std__string_casadi__GenericType_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__GenericType_t_t_t,
  _swigc__p_std__mapT_std__string_casadi__MX_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MX_t_t_t,
  _swigc__p_std__mapT_std__string_casadi__MatrixT_casadi__SXElem_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_casadi__SXElem_t_t_t_t,
  _swigc__p_std__mapT_std__string_casadi__MatrixT_double_t_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__MatrixT_double_t_t_t_t,
  _swigc__p_std__mapT_std__string_casadi__Sparsity_std__lessT_std__string_t_std__allocatorT_std__pairT_std__string_const_casadi__Sparsity_t_t_t,
  _swigc__p_std__ostream,
  _swigc__p_std__pairT_casadi__Slice_casadi__Slice_t,
  _swigc__p_std__size_t,
  _swigc__p_std__string,
  _swigc__p_std__vectorT_casadi__Linsol_std__allocatorT_casadi__Linsol_t_t,
  _swigc__p_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t,
  _swigc__p_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t,
  _swigc__p_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t,
  _swigc__p_std__vectorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_std__allocatorT_std__vectorT_casadi__MX_std__allocatorT_casadi__MX_t_t_t_t,
  _swigc__p_std__vectorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_casadi__SXElem_t_std__allocatorT_casadi__MatrixT_casadi__SXElem_t_t_t_t_t,
  _swigc__p_std__vectorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_std__allocatorT_std__vectorT_casadi__MatrixT_double_t_std__allocatorT_casadi__MatrixT_double_t_t_t_t_t,
  _swigc__p_swig__SwigPyIterator,
  _swigc__p_value_type,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        "swigvarlink",                      /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        0,                                  /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
        0,                                  /* tp_del */
        0,                                  /* tp_version_tag */
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#if PY_VERSION_HEX >= 0x03080000
        0,                                  /* tp_vectorcall */
#endif
#if (PY_VERSION_HEX >= 0x03080000) && (PY_VERSION_HEX < 0x03090000)
        0,                                  /* tp_print */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
        0,                                  /* tp_prev */
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, const char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        memcpy(gv->name, name, size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *globals = 0;
    if (!globals) {
      globals = SWIG_newvarlink();
    }
    return globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              memcpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              memcpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
  /* -----------------------------------------------------------------------------
   * Method creation and docstring support functions
   * ----------------------------------------------------------------------------- */
  
  /* -----------------------------------------------------------------------------
   * Function to find the method definition with the correct docstring for the
   * proxy module as opposed to the low-level API
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyMethodDef *SWIG_PythonGetProxyDoc(const char *name) {
    /* Find the function in the modified method table */
    size_t offset = 0;
    int found = 0;
    while (SwigMethods_proxydocs[offset].ml_meth != NULL) {
      if (strcmp(SwigMethods_proxydocs[offset].ml_name, name) == 0) {
        found = 1;
        break;
      }
      offset++;
    }
    /* Use the copy with the modified docstring if available */
    return found ? &SwigMethods_proxydocs[offset] : NULL;
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyInstanceMethod_New() used in Python 3
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
#if PY_VERSION_HEX >= 0x03000000
    return PyInstanceMethod_New(func);
#else
    return PyMethod_New(func, NULL, NULL);
#endif
  }
  
  /* -----------------------------------------------------------------------------
   * Wrapper of PyStaticMethod_New()
   * It is exported to the generated module, used for -fastproxy
   * ----------------------------------------------------------------------------- */
  
  SWIGINTERN PyObject *SWIG_PyStaticMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func) {
    if (PyCFunction_Check(func)) {
      PyCFunctionObject *funcobj = (PyCFunctionObject *)func;
      PyMethodDef *ml = SWIG_PythonGetProxyDoc(funcobj->m_ml->ml_name);
      if (ml)
      func = PyCFunction_NewEx(ml, funcobj->m_self, funcobj->m_module);
    }
    return PyStaticMethod_New(func);
  }
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md, *globals;
  
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
    PyModuleDef_HEAD_INIT,
    SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    SwigPyObject_own,
    SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  (void)globals;
  
  /* Create singletons now to avoid potential deadlocks with multi-threaded usage after module initialization */
  SWIG_This();
  SWIG_Python_TypeCache();
  SwigPyPacked_type();
#ifndef SWIGPYTHON_BUILTIN
  SwigPyObject_type();
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule(SWIG_name, SwigMethods);
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  SWIG_Python_SetConstant(d, "CASADI_INT_TYPE_STR",SWIG_FromCharPtr("long long int"));
  
  // Set logger functions
  casadi::Logger::writeFun = casadi::pythonlogger;
  
  // @jgillis: please document
  casadi::InterruptHandler::checkInterrupted = casadi::pythoncheckinterrupted;
  
  casadi::InterruptHandler::is_main_thread();
  
  
  SWIG_Python_SetConstant(d, "MNAME",SWIG_FromCharPtr("$name"));
  SWIG_Python_SetConstant(d, "L_INT",SWIG_FromCharPtr("int"));
  SWIG_Python_SetConstant(d, "L_BOOL",SWIG_FromCharPtr("bool"));
  SWIG_Python_SetConstant(d, "LL",SWIG_FromCharPtr("["));
  SWIG_Python_SetConstant(d, "LR",SWIG_FromCharPtr("]"));
  SWIG_Python_SetConstant(d, "L_DICT",SWIG_FromCharPtr("dict"));
  SWIG_Python_SetConstant(d, "L_DOUBLE",SWIG_FromCharPtr("float"));
  SWIG_Python_SetConstant(d, "L_STR",SWIG_FromCharPtr("str"));
  SWIG_Python_SetConstant(d, "LABEL",SWIG_FromCharPtr("(int,int)"));
  SWIG_Python_SetConstant(d, "SWIG_IND1",SWIG_From_bool(static_cast< bool >(false)));
  SWIG_Python_SetConstant(d, "OP_ASSIGN",SWIG_From_int(static_cast< int >(casadi::OP_ASSIGN)));
  SWIG_Python_SetConstant(d, "OP_ADD",SWIG_From_int(static_cast< int >(casadi::OP_ADD)));
  SWIG_Python_SetConstant(d, "OP_SUB",SWIG_From_int(static_cast< int >(casadi::OP_SUB)));
  SWIG_Python_SetConstant(d, "OP_MUL",SWIG_From_int(static_cast< int >(casadi::OP_MUL)));
  SWIG_Python_SetConstant(d, "OP_DIV",SWIG_From_int(static_cast< int >(casadi::OP_DIV)));
  SWIG_Python_SetConstant(d, "OP_NEG",SWIG_From_int(static_cast< int >(casadi::OP_NEG)));
  SWIG_Python_SetConstant(d, "OP_EXP",SWIG_From_int(static_cast< int >(casadi::OP_EXP)));
  SWIG_Python_SetConstant(d, "OP_LOG",SWIG_From_int(static_cast< int >(casadi::OP_LOG)));
  SWIG_Python_SetConstant(d, "OP_POW",SWIG_From_int(static_cast< int >(casadi::OP_POW)));
  SWIG_Python_SetConstant(d, "OP_CONSTPOW",SWIG_From_int(static_cast< int >(casadi::OP_CONSTPOW)));
  SWIG_Python_SetConstant(d, "OP_SQRT",SWIG_From_int(static_cast< int >(casadi::OP_SQRT)));
  SWIG_Python_SetConstant(d, "OP_SQ",SWIG_From_int(static_cast< int >(casadi::OP_SQ)));
  SWIG_Python_SetConstant(d, "OP_TWICE",SWIG_From_int(static_cast< int >(casadi::OP_TWICE)));
  SWIG_Python_SetConstant(d, "OP_SIN",SWIG_From_int(static_cast< int >(casadi::OP_SIN)));
  SWIG_Python_SetConstant(d, "OP_COS",SWIG_From_int(static_cast< int >(casadi::OP_COS)));
  SWIG_Python_SetConstant(d, "OP_TAN",SWIG_From_int(static_cast< int >(casadi::OP_TAN)));
  SWIG_Python_SetConstant(d, "OP_ASIN",SWIG_From_int(static_cast< int >(casadi::OP_ASIN)));
  SWIG_Python_SetConstant(d, "OP_ACOS",SWIG_From_int(static_cast< int >(casadi::OP_ACOS)));
  SWIG_Python_SetConstant(d, "OP_ATAN",SWIG_From_int(static_cast< int >(casadi::OP_ATAN)));
  SWIG_Python_SetConstant(d, "OP_LT",SWIG_From_int(static_cast< int >(casadi::OP_LT)));
  SWIG_Python_SetConstant(d, "OP_LE",SWIG_From_int(static_cast< int >(casadi::OP_LE)));
  SWIG_Python_SetConstant(d, "OP_EQ",SWIG_From_int(static_cast< int >(casadi::OP_EQ)));
  SWIG_Python_SetConstant(d, "OP_NE",SWIG_From_int(static_cast< int >(casadi::OP_NE)));
  SWIG_Python_SetConstant(d, "OP_NOT",SWIG_From_int(static_cast< int >(casadi::OP_NOT)));
  SWIG_Python_SetConstant(d, "OP_AND",SWIG_From_int(static_cast< int >(casadi::OP_AND)));
  SWIG_Python_SetConstant(d, "OP_OR",SWIG_From_int(static_cast< int >(casadi::OP_OR)));
  SWIG_Python_SetConstant(d, "OP_FLOOR",SWIG_From_int(static_cast< int >(casadi::OP_FLOOR)));
  SWIG_Python_SetConstant(d, "OP_CEIL",SWIG_From_int(static_cast< int >(casadi::OP_CEIL)));
  SWIG_Python_SetConstant(d, "OP_FMOD",SWIG_From_int(static_cast< int >(casadi::OP_FMOD)));
  SWIG_Python_SetConstant(d, "OP_FABS",SWIG_From_int(static_cast< int >(casadi::OP_FABS)));
  SWIG_Python_SetConstant(d, "OP_SIGN",SWIG_From_int(static_cast< int >(casadi::OP_SIGN)));
  SWIG_Python_SetConstant(d, "OP_COPYSIGN",SWIG_From_int(static_cast< int >(casadi::OP_COPYSIGN)));
  SWIG_Python_SetConstant(d, "OP_IF_ELSE_ZERO",SWIG_From_int(static_cast< int >(casadi::OP_IF_ELSE_ZERO)));
  SWIG_Python_SetConstant(d, "OP_ERF",SWIG_From_int(static_cast< int >(casadi::OP_ERF)));
  SWIG_Python_SetConstant(d, "OP_FMIN",SWIG_From_int(static_cast< int >(casadi::OP_FMIN)));
  SWIG_Python_SetConstant(d, "OP_FMAX",SWIG_From_int(static_cast< int >(casadi::OP_FMAX)));
  SWIG_Python_SetConstant(d, "OP_INV",SWIG_From_int(static_cast< int >(casadi::OP_INV)));
  SWIG_Python_SetConstant(d, "OP_SINH",SWIG_From_int(static_cast< int >(casadi::OP_SINH)));
  SWIG_Python_SetConstant(d, "OP_COSH",SWIG_From_int(static_cast< int >(casadi::OP_COSH)));
  SWIG_Python_SetConstant(d, "OP_TANH",SWIG_From_int(static_cast< int >(casadi::OP_TANH)));
  SWIG_Python_SetConstant(d, "OP_ASINH",SWIG_From_int(static_cast< int >(casadi::OP_ASINH)));
  SWIG_Python_SetConstant(d, "OP_ACOSH",SWIG_From_int(static_cast< int >(casadi::OP_ACOSH)));
  SWIG_Python_SetConstant(d, "OP_ATANH",SWIG_From_int(static_cast< int >(casadi::OP_ATANH)));
  SWIG_Python_SetConstant(d, "OP_ATAN2",SWIG_From_int(static_cast< int >(casadi::OP_ATAN2)));
  SWIG_Python_SetConstant(d, "OP_CONST",SWIG_From_int(static_cast< int >(casadi::OP_CONST)));
  SWIG_Python_SetConstant(d, "OP_INPUT",SWIG_From_int(static_cast< int >(casadi::OP_INPUT)));
  SWIG_Python_SetConstant(d, "OP_OUTPUT",SWIG_From_int(static_cast< int >(casadi::OP_OUTPUT)));
  SWIG_Python_SetConstant(d, "OP_PARAMETER",SWIG_From_int(static_cast< int >(casadi::OP_PARAMETER)));
  SWIG_Python_SetConstant(d, "OP_CALL",SWIG_From_int(static_cast< int >(casadi::OP_CALL)));
  SWIG_Python_SetConstant(d, "OP_FIND",SWIG_From_int(static_cast< int >(casadi::OP_FIND)));
  SWIG_Python_SetConstant(d, "OP_LOW",SWIG_From_int(static_cast< int >(casadi::OP_LOW)));
  SWIG_Python_SetConstant(d, "OP_MAP",SWIG_From_int(static_cast< int >(casadi::OP_MAP)));
  SWIG_Python_SetConstant(d, "OP_MTIMES",SWIG_From_int(static_cast< int >(casadi::OP_MTIMES)));
  SWIG_Python_SetConstant(d, "OP_SOLVE",SWIG_From_int(static_cast< int >(casadi::OP_SOLVE)));
  SWIG_Python_SetConstant(d, "OP_TRANSPOSE",SWIG_From_int(static_cast< int >(casadi::OP_TRANSPOSE)));
  SWIG_Python_SetConstant(d, "OP_DETERMINANT",SWIG_From_int(static_cast< int >(casadi::OP_DETERMINANT)));
  SWIG_Python_SetConstant(d, "OP_INVERSE",SWIG_From_int(static_cast< int >(casadi::OP_INVERSE)));
  SWIG_Python_SetConstant(d, "OP_DOT",SWIG_From_int(static_cast< int >(casadi::OP_DOT)));
  SWIG_Python_SetConstant(d, "OP_BILIN",SWIG_From_int(static_cast< int >(casadi::OP_BILIN)));
  SWIG_Python_SetConstant(d, "OP_RANK1",SWIG_From_int(static_cast< int >(casadi::OP_RANK1)));
  SWIG_Python_SetConstant(d, "OP_HORZCAT",SWIG_From_int(static_cast< int >(casadi::OP_HORZCAT)));
  SWIG_Python_SetConstant(d, "OP_VERTCAT",SWIG_From_int(static_cast< int >(casadi::OP_VERTCAT)));
  SWIG_Python_SetConstant(d, "OP_DIAGCAT",SWIG_From_int(static_cast< int >(casadi::OP_DIAGCAT)));
  SWIG_Python_SetConstant(d, "OP_HORZSPLIT",SWIG_From_int(static_cast< int >(casadi::OP_HORZSPLIT)));
  SWIG_Python_SetConstant(d, "OP_VERTSPLIT",SWIG_From_int(static_cast< int >(casadi::OP_VERTSPLIT)));
  SWIG_Python_SetConstant(d, "OP_DIAGSPLIT",SWIG_From_int(static_cast< int >(casadi::OP_DIAGSPLIT)));
  SWIG_Python_SetConstant(d, "OP_RESHAPE",SWIG_From_int(static_cast< int >(casadi::OP_RESHAPE)));
  SWIG_Python_SetConstant(d, "OP_SUBREF",SWIG_From_int(static_cast< int >(casadi::OP_SUBREF)));
  SWIG_Python_SetConstant(d, "OP_SUBASSIGN",SWIG_From_int(static_cast< int >(casadi::OP_SUBASSIGN)));
  SWIG_Python_SetConstant(d, "OP_GETNONZEROS",SWIG_From_int(static_cast< int >(casadi::OP_GETNONZEROS)));
  SWIG_Python_SetConstant(d, "OP_GETNONZEROS_PARAM",SWIG_From_int(static_cast< int >(casadi::OP_GETNONZEROS_PARAM)));
  SWIG_Python_SetConstant(d, "OP_ADDNONZEROS",SWIG_From_int(static_cast< int >(casadi::OP_ADDNONZEROS)));
  SWIG_Python_SetConstant(d, "OP_ADDNONZEROS_PARAM",SWIG_From_int(static_cast< int >(casadi::OP_ADDNONZEROS_PARAM)));
  SWIG_Python_SetConstant(d, "OP_SETNONZEROS",SWIG_From_int(static_cast< int >(casadi::OP_SETNONZEROS)));
  SWIG_Python_SetConstant(d, "OP_SETNONZEROS_PARAM",SWIG_From_int(static_cast< int >(casadi::OP_SETNONZEROS_PARAM)));
  SWIG_Python_SetConstant(d, "OP_PROJECT",SWIG_From_int(static_cast< int >(casadi::OP_PROJECT)));
  SWIG_Python_SetConstant(d, "OP_ASSERTION",SWIG_From_int(static_cast< int >(casadi::OP_ASSERTION)));
  SWIG_Python_SetConstant(d, "OP_MONITOR",SWIG_From_int(static_cast< int >(casadi::OP_MONITOR)));
  SWIG_Python_SetConstant(d, "OP_NORM2",SWIG_From_int(static_cast< int >(casadi::OP_NORM2)));
  SWIG_Python_SetConstant(d, "OP_NORM1",SWIG_From_int(static_cast< int >(casadi::OP_NORM1)));
  SWIG_Python_SetConstant(d, "OP_NORMINF",SWIG_From_int(static_cast< int >(casadi::OP_NORMINF)));
  SWIG_Python_SetConstant(d, "OP_NORMF",SWIG_From_int(static_cast< int >(casadi::OP_NORMF)));
  SWIG_Python_SetConstant(d, "OP_MMIN",SWIG_From_int(static_cast< int >(casadi::OP_MMIN)));
  SWIG_Python_SetConstant(d, "OP_MMAX",SWIG_From_int(static_cast< int >(casadi::OP_MMAX)));
  SWIG_Python_SetConstant(d, "OP_HORZREPMAT",SWIG_From_int(static_cast< int >(casadi::OP_HORZREPMAT)));
  SWIG_Python_SetConstant(d, "OP_HORZREPSUM",SWIG_From_int(static_cast< int >(casadi::OP_HORZREPSUM)));
  SWIG_Python_SetConstant(d, "OP_ERFINV",SWIG_From_int(static_cast< int >(casadi::OP_ERFINV)));
  SWIG_Python_SetConstant(d, "OP_PRINTME",SWIG_From_int(static_cast< int >(casadi::OP_PRINTME)));
  SWIG_Python_SetConstant(d, "OP_LIFT",SWIG_From_int(static_cast< int >(casadi::OP_LIFT)));
  SWIG_Python_SetConstant(d, "OP_EINSTEIN",SWIG_From_int(static_cast< int >(casadi::OP_EINSTEIN)));
  SWIG_Python_SetConstant(d, "OP_BSPLINE",SWIG_From_int(static_cast< int >(casadi::OP_BSPLINE)));
  SWIG_Python_SetConstant(d, "OP_CONVEXIFY",SWIG_From_int(static_cast< int >(casadi::OP_CONVEXIFY)));
  SWIG_Python_SetConstant(d, "IS_GLOBAL",SWIG_From_int(static_cast< int >(0x1)));
  SWIG_Python_SetConstant(d, "IS_MEMBER",SWIG_From_int(static_cast< int >(0x10)));
  SWIG_Python_SetConstant(d, "IS_SPARSITY",SWIG_From_int(static_cast< int >(0x100)));
  SWIG_Python_SetConstant(d, "IS_DMATRIX",SWIG_From_int(static_cast< int >(0x1000)));
  SWIG_Python_SetConstant(d, "IS_IMATRIX",SWIG_From_int(static_cast< int >(0x10000)));
  SWIG_Python_SetConstant(d, "IS_SX",SWIG_From_int(static_cast< int >(0x100000)));
  SWIG_Python_SetConstant(d, "IS_MX",SWIG_From_int(static_cast< int >(0x1000000)));
  SWIG_Python_SetConstant(d, "IS_DOUBLE",SWIG_From_int(static_cast< int >(0x10000000)));
  SWIG_Python_SetConstant(d, "FLAG",SWIG_From_int(static_cast< int >((0x1|0x10))));
  SWIG_Python_SetConstant(d, "LEGENDRE",SWIG_From_int(static_cast< int >(casadi::LEGENDRE)));
  SWIG_Python_SetConstant(d, "RADAU",SWIG_From_int(static_cast< int >(casadi::RADAU)));
  SWIG_Python_SetConstant(d, "CONSTANT",SWIG_From_int(static_cast< int >(casadi::CONSTANT)));
  SWIG_Python_SetConstant(d, "PARAMETER",SWIG_From_int(static_cast< int >(casadi::PARAMETER)));
  SWIG_Python_SetConstant(d, "DISCRETE",SWIG_From_int(static_cast< int >(casadi::DISCRETE)));
  SWIG_Python_SetConstant(d, "CONTINUOUS",SWIG_From_int(static_cast< int >(casadi::CONTINUOUS)));
  SWIG_Python_SetConstant(d, "INPUT",SWIG_From_int(static_cast< int >(casadi::INPUT)));
  SWIG_Python_SetConstant(d, "OUTPUT",SWIG_From_int(static_cast< int >(casadi::OUTPUT)));
  SWIG_Python_SetConstant(d, "INTERNAL",SWIG_From_int(static_cast< int >(casadi::INTERNAL)));
  SWIG_Python_SetConstant(d, "ALGEBRAIC",SWIG_From_int(static_cast< int >(casadi::ALGEBRAIC)));
  SWIG_Python_SetConstant(d, "DIFFERENTIAL",SWIG_From_int(static_cast< int >(casadi::DIFFERENTIAL)));
  SWIG_Python_SetConstant(d, "NO_ALIAS",SWIG_From_int(static_cast< int >(casadi::NO_ALIAS)));
  SWIG_Python_SetConstant(d, "ALIAS",SWIG_From_int(static_cast< int >(casadi::ALIAS)));
  SWIG_Python_SetConstant(d, "NEGATED_ALIAS",SWIG_From_int(static_cast< int >(casadi::NEGATED_ALIAS)));
  SWIG_Python_SetConstant(d, "CAT_UNKNOWN",SWIG_From_int(static_cast< int >(casadi::CAT_UNKNOWN)));
  SWIG_Python_SetConstant(d, "CAT_DERIVATIVE",SWIG_From_int(static_cast< int >(casadi::CAT_DERIVATIVE)));
  SWIG_Python_SetConstant(d, "CAT_STATE",SWIG_From_int(static_cast< int >(casadi::CAT_STATE)));
  SWIG_Python_SetConstant(d, "CAT_DEPENDENT_CONSTANT",SWIG_From_int(static_cast< int >(casadi::CAT_DEPENDENT_CONSTANT)));
  SWIG_Python_SetConstant(d, "CAT_INDEPENDENT_CONSTANT",SWIG_From_int(static_cast< int >(casadi::CAT_INDEPENDENT_CONSTANT)));
  SWIG_Python_SetConstant(d, "CAT_DEPENDENT_PARAMETER",SWIG_From_int(static_cast< int >(casadi::CAT_DEPENDENT_PARAMETER)));
  SWIG_Python_SetConstant(d, "CAT_INDEPENDENT_PARAMETER",SWIG_From_int(static_cast< int >(casadi::CAT_INDEPENDENT_PARAMETER)));
  SWIG_Python_SetConstant(d, "CAT_ALGEBRAIC",SWIG_From_int(static_cast< int >(casadi::CAT_ALGEBRAIC)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_SPARSITY",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_SPARSITY)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_MX",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_MX)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_DM",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_DM)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_SX",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_SX)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_LINSOL",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_LINSOL)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_FUNCTION",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_FUNCTION)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_GENERICTYPE",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_GENERICTYPE)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_INT",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_INT)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_DOUBLE",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_DOUBLE)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_STRING",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_STRING)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_SPARSITY_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_SPARSITY_VECTOR)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_MX_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_MX_VECTOR)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_DM_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_DM_VECTOR)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_SX_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_SX_VECTOR)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_LINSOL_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_LINSOL_VECTOR)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_FUNCTION_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_FUNCTION_VECTOR)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_GENERICTYPE_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_GENERICTYPE_VECTOR)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_INT_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_INT_VECTOR)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_DOUBLE_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_DOUBLE_VECTOR)));
  SWIG_Python_SetConstant(d, "SerializerBase__SERIALIZED_STRING_VECTOR",SWIG_From_int(static_cast< int >(casadi::SerializerBase::SERIALIZED_STRING_VECTOR)));
  SWIG_Python_SetConstant(d, "OPTI_GENERIC_EQUALITY",SWIG_From_int(static_cast< int >(casadi::OPTI_GENERIC_EQUALITY)));
  SWIG_Python_SetConstant(d, "OPTI_GENERIC_INEQUALITY",SWIG_From_int(static_cast< int >(casadi::OPTI_GENERIC_INEQUALITY)));
  SWIG_Python_SetConstant(d, "OPTI_EQUALITY",SWIG_From_int(static_cast< int >(casadi::OPTI_EQUALITY)));
  SWIG_Python_SetConstant(d, "OPTI_INEQUALITY",SWIG_From_int(static_cast< int >(casadi::OPTI_INEQUALITY)));
  SWIG_Python_SetConstant(d, "OPTI_DOUBLE_INEQUALITY",SWIG_From_int(static_cast< int >(casadi::OPTI_DOUBLE_INEQUALITY)));
  SWIG_Python_SetConstant(d, "OPTI_PSD",SWIG_From_int(static_cast< int >(casadi::OPTI_PSD)));
  SWIG_Python_SetConstant(d, "OPTI_UNKNOWN",SWIG_From_int(static_cast< int >(casadi::OPTI_UNKNOWN)));
  SWIG_Python_SetConstant(d, "OPTI_VAR",SWIG_From_int(static_cast< int >(casadi::OPTI_VAR)));
  SWIG_Python_SetConstant(d, "OPTI_PAR",SWIG_From_int(static_cast< int >(casadi::OPTI_PAR)));
  SWIG_Python_SetConstant(d, "OPTI_DUAL_G",SWIG_From_int(static_cast< int >(casadi::OPTI_DUAL_G)));
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

